// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package cloudfront provides a client for Amazon CloudFront.
package cloudfront

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"strconv"
	"strings"
)

// CloudFront is a client for Amazon CloudFront.
type CloudFront struct {
	client *aws.RestClient
}

// New returns a new CloudFront client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *CloudFront {
	if client == nil {
		client = http.DefaultClient
	}

	service := "cloudfront"
	endpoint, service, region := endpoints.Lookup("cloudfront", region)

	return &CloudFront{
		client: &aws.RestClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2014-10-21",
		},
	}
}

// CreateCloudFrontOriginAccessIdentity is undocumented.
func (c *CloudFront) CreateCloudFrontOriginAccessIdentity(req *CreateCloudFrontOriginAccessIdentityRequest) (resp *CreateCloudFrontOriginAccessIdentityResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateCloudFrontOriginAccessIdentityResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.CloudFrontOriginAccessIdentityConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateDistribution is undocumented.
func (c *CloudFront) CreateDistribution(req *CreateDistributionRequest) (resp *CreateDistributionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.DistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/distribution"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateInvalidation is undocumented.
func (c *CloudFront) CreateInvalidation(req *CreateInvalidationRequest) (resp *CreateInvalidationResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateInvalidationResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.InvalidationBatch)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/distribution/{DistributionId}/invalidation"

	if req.DistributionID != nil {
		uri = strings.Replace(uri, "{"+"DistributionId"+"}", *req.DistributionID, -1)
		uri = strings.Replace(uri, "{"+"DistributionId+"+"}", *req.DistributionID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateStreamingDistribution is undocumented.
func (c *CloudFront) CreateStreamingDistribution(req *CreateStreamingDistributionRequest) (resp *CreateStreamingDistributionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateStreamingDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.StreamingDistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// DeleteCloudFrontOriginAccessIdentity is undocumented.
func (c *CloudFront) DeleteCloudFrontOriginAccessIdentity(req *DeleteCloudFrontOriginAccessIdentityRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteDistribution is undocumented.
func (c *CloudFront) DeleteDistribution(req *DeleteDistributionRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteStreamingDistribution is undocumented.
func (c *CloudFront) DeleteStreamingDistribution(req *DeleteStreamingDistributionRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// GetCloudFrontOriginAccessIdentity get the information about an origin
// access identity.
func (c *CloudFront) GetCloudFrontOriginAccessIdentity(req *GetCloudFrontOriginAccessIdentityRequest) (resp *GetCloudFrontOriginAccessIdentityResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetCloudFrontOriginAccessIdentityResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetCloudFrontOriginAccessIdentityConfig get the configuration
// information about an origin access identity.
func (c *CloudFront) GetCloudFrontOriginAccessIdentityConfig(req *GetCloudFrontOriginAccessIdentityConfigRequest) (resp *GetCloudFrontOriginAccessIdentityConfigResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetCloudFrontOriginAccessIdentityConfigResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetDistribution is undocumented.
func (c *CloudFront) GetDistribution(req *GetDistributionRequest) (resp *GetDistributionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetDistributionResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetDistributionConfig get the configuration information about a
// distribution.
func (c *CloudFront) GetDistributionConfig(req *GetDistributionConfigRequest) (resp *GetDistributionConfigResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetDistributionConfigResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetInvalidation is undocumented.
func (c *CloudFront) GetInvalidation(req *GetInvalidationRequest) (resp *GetInvalidationResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetInvalidationResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{DistributionId}/invalidation/{Id}"

	if req.DistributionID != nil {
		uri = strings.Replace(uri, "{"+"DistributionId"+"}", *req.DistributionID, -1)
		uri = strings.Replace(uri, "{"+"DistributionId+"+"}", *req.DistributionID, -1)
	}

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetStreamingDistribution get the information about a streaming
// distribution.
func (c *CloudFront) GetStreamingDistribution(req *GetStreamingDistributionRequest) (resp *GetStreamingDistributionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetStreamingDistributionResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetStreamingDistributionConfig get the configuration information about a
// streaming distribution.
func (c *CloudFront) GetStreamingDistributionConfig(req *GetStreamingDistributionConfigRequest) (resp *GetStreamingDistributionConfigResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetStreamingDistributionConfigResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// ListCloudFrontOriginAccessIdentities is undocumented.
func (c *CloudFront) ListCloudFrontOriginAccessIdentities(req *ListCloudFrontOriginAccessIdentitiesRequest) (resp *ListCloudFrontOriginAccessIdentitiesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListCloudFrontOriginAccessIdentitiesResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListDistributions is undocumented.
func (c *CloudFront) ListDistributions(req *ListDistributionsRequest) (resp *ListDistributionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListDistributionsResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListInvalidations is undocumented.
func (c *CloudFront) ListInvalidations(req *ListInvalidationsRequest) (resp *ListInvalidationsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListInvalidationsResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{DistributionId}/invalidation"

	if req.DistributionID != nil {
		uri = strings.Replace(uri, "{"+"DistributionId"+"}", *req.DistributionID, -1)
		uri = strings.Replace(uri, "{"+"DistributionId+"+"}", *req.DistributionID, -1)
	}

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListStreamingDistributions is undocumented.
func (c *CloudFront) ListStreamingDistributions(req *ListStreamingDistributionsRequest) (resp *ListStreamingDistributionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListStreamingDistributionsResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// UpdateCloudFrontOriginAccessIdentity is undocumented.
func (c *CloudFront) UpdateCloudFrontOriginAccessIdentity(req *UpdateCloudFrontOriginAccessIdentityRequest) (resp *UpdateCloudFrontOriginAccessIdentityResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateCloudFrontOriginAccessIdentityResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.CloudFrontOriginAccessIdentityConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// UpdateDistribution is undocumented.
func (c *CloudFront) UpdateDistribution(req *UpdateDistributionRequest) (resp *UpdateDistributionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.DistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// UpdateStreamingDistribution is undocumented.
func (c *CloudFront) UpdateStreamingDistribution(req *UpdateStreamingDistributionRequest) (resp *UpdateStreamingDistributionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateStreamingDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.StreamingDistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// ActiveTrustedSigners is undocumented.
type ActiveTrustedSigners struct {
	XMLName xml.Name `xml:"ActiveTrustedSigners"`

	Enabled  aws.BooleanValue `xml:"Enabled"`
	Items    []Signer         `xml:"Items>Signer,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *ActiveTrustedSigners) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ActiveTrustedSigners) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Aliases is undocumented.
type Aliases struct {
	XMLName xml.Name `xml:"Aliases"`

	Items    []string         `xml:"Items>CNAME,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *Aliases) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Aliases) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AllowedMethods is undocumented.
type AllowedMethods struct {
	XMLName xml.Name `xml:"AllowedMethods"`

	CachedMethods *CachedMethods   `xml:"CachedMethods,omitempty"`
	Items         []string         `xml:"Items>Method,omitempty"`
	Quantity      aws.IntegerValue `xml:"Quantity"`
}

func (v *AllowedMethods) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *AllowedMethods) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Items"); err != nil {
		errors["Items"] = append(errors["Items"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CacheBehavior is undocumented.
type CacheBehavior struct {
	XMLName xml.Name `xml:"CacheBehavior"`

	AllowedMethods       *AllowedMethods  `xml:"AllowedMethods,omitempty"`
	ForwardedValues      *ForwardedValues `xml:"ForwardedValues,omitempty"`
	MinTTL               aws.LongValue    `xml:"MinTTL"`
	PathPattern          aws.StringValue  `xml:"PathPattern"`
	SmoothStreaming      aws.BooleanValue `xml:"SmoothStreaming"`
	TargetOriginID       aws.StringValue  `xml:"TargetOriginId"`
	TrustedSigners       *TrustedSigners  `xml:"TrustedSigners,omitempty"`
	ViewerProtocolPolicy aws.StringValue  `xml:"ViewerProtocolPolicy"`
}

func (v *CacheBehavior) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CacheBehavior) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ForwardedValues"); err != nil {
		errors["ForwardedValues"] = append(errors["ForwardedValues"], err)
	}

	if err := model.ValidateRequired(v, "MinTTL"); err != nil {
		errors["MinTTL"] = append(errors["MinTTL"], err)
	}

	if err := model.ValidateRequired(v, "PathPattern"); err != nil {
		errors["PathPattern"] = append(errors["PathPattern"], err)
	}

	if err := model.ValidateRequired(v, "TargetOriginID"); err != nil {
		errors["TargetOriginID"] = append(errors["TargetOriginID"], err)
	}

	if err := model.ValidateRequired(v, "TrustedSigners"); err != nil {
		errors["TrustedSigners"] = append(errors["TrustedSigners"], err)
	}

	if err := model.ValidateRequired(v, "ViewerProtocolPolicy"); err != nil {
		errors["ViewerProtocolPolicy"] = append(errors["ViewerProtocolPolicy"], err)
	}

	ViewerProtocolPolicyEnum := []string{
		ViewerProtocolPolicyAllowAll,
		ViewerProtocolPolicyHTTPSOnly,
		ViewerProtocolPolicyRedirectToHTTPS,
	}
	if err := model.ValidateEnum(v, "ViewerProtocolPolicy", ViewerProtocolPolicyEnum); err != nil {
		errors["ViewerProtocolPolicy"] = append(errors["ViewerProtocolPolicy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CacheBehaviors is undocumented.
type CacheBehaviors struct {
	XMLName xml.Name `xml:"CacheBehaviors"`

	Items    []CacheBehavior  `xml:"Items>CacheBehavior,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *CacheBehaviors) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CacheBehaviors) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CachedMethods is undocumented.
type CachedMethods struct {
	XMLName xml.Name `xml:"CachedMethods"`

	Items    []string         `xml:"Items>Method,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *CachedMethods) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CachedMethods) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Items"); err != nil {
		errors["Items"] = append(errors["Items"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CloudFrontOriginAccessIdentity is undocumented.
type CloudFrontOriginAccessIdentity struct {
	XMLName xml.Name `xml:"CloudFrontOriginAccessIdentity"`

	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig,omitempty"`
	ID                                   aws.StringValue                       `xml:"Id"`
	S3CanonicalUserID                    aws.StringValue                       `xml:"S3CanonicalUserId"`
}

func (v *CloudFrontOriginAccessIdentity) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CloudFrontOriginAccessIdentity) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "S3CanonicalUserID"); err != nil {
		errors["S3CanonicalUserID"] = append(errors["S3CanonicalUserID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CloudFrontOriginAccessIdentityConfig is undocumented.
type CloudFrontOriginAccessIdentityConfig struct {
	XMLName xml.Name `xml:"CloudFrontOriginAccessIdentityConfig"`

	CallerReference aws.StringValue `xml:"CallerReference"`
	Comment         aws.StringValue `xml:"Comment"`
}

func (v *CloudFrontOriginAccessIdentityConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CloudFrontOriginAccessIdentityConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CallerReference"); err != nil {
		errors["CallerReference"] = append(errors["CallerReference"], err)
	}

	if err := model.ValidateRequired(v, "Comment"); err != nil {
		errors["Comment"] = append(errors["Comment"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CloudFrontOriginAccessIdentityList is undocumented.
type CloudFrontOriginAccessIdentityList struct {
	XMLName xml.Name `xml:"CloudFrontOriginAccessIdentityList"`

	IsTruncated aws.BooleanValue                        `xml:"IsTruncated"`
	Items       []CloudFrontOriginAccessIdentitySummary `xml:"Items>CloudFrontOriginAccessIdentitySummary,omitempty"`
	Marker      aws.StringValue                         `xml:"Marker"`
	MaxItems    aws.IntegerValue                        `xml:"MaxItems"`
	NextMarker  aws.StringValue                         `xml:"NextMarker"`
	Quantity    aws.IntegerValue                        `xml:"Quantity"`
}

func (v *CloudFrontOriginAccessIdentityList) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CloudFrontOriginAccessIdentityList) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IsTruncated"); err != nil {
		errors["IsTruncated"] = append(errors["IsTruncated"], err)
	}

	if err := model.ValidateRequired(v, "Marker"); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "MaxItems"); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CloudFrontOriginAccessIdentitySummary is undocumented.
type CloudFrontOriginAccessIdentitySummary struct {
	XMLName xml.Name `xml:"CloudFrontOriginAccessIdentitySummary"`

	Comment           aws.StringValue `xml:"Comment"`
	ID                aws.StringValue `xml:"Id"`
	S3CanonicalUserID aws.StringValue `xml:"S3CanonicalUserId"`
}

func (v *CloudFrontOriginAccessIdentitySummary) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CloudFrontOriginAccessIdentitySummary) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Comment"); err != nil {
		errors["Comment"] = append(errors["Comment"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "S3CanonicalUserID"); err != nil {
		errors["S3CanonicalUserID"] = append(errors["S3CanonicalUserID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CookieNames is undocumented.
type CookieNames struct {
	XMLName xml.Name `xml:"CookieNames"`

	Items    []string         `xml:"Items>Name,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *CookieNames) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CookieNames) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CookiePreference is undocumented.
type CookiePreference struct {
	XMLName xml.Name `xml:"CookiePreference"`

	Forward          aws.StringValue `xml:"Forward"`
	WhitelistedNames *CookieNames    `xml:"WhitelistedNames,omitempty"`
}

func (v *CookiePreference) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CookiePreference) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Forward"); err != nil {
		errors["Forward"] = append(errors["Forward"], err)
	}

	ForwardEnum := []string{
		ItemSelectionAll,
		ItemSelectionNone,
		ItemSelectionWhitelist,
	}
	if err := model.ValidateEnum(v, "Forward", ForwardEnum); err != nil {
		errors["Forward"] = append(errors["Forward"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateCloudFrontOriginAccessIdentityRequest is undocumented.
type CreateCloudFrontOriginAccessIdentityRequest struct {
	XMLName xml.Name `xml:""`

	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig,omitempty"`
}

func (v *CreateCloudFrontOriginAccessIdentityRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateCloudFrontOriginAccessIdentityRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CloudFrontOriginAccessIdentityConfig"); err != nil {
		errors["CloudFrontOriginAccessIdentityConfig"] = append(errors["CloudFrontOriginAccessIdentityConfig"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateCloudFrontOriginAccessIdentityResult is undocumented.
type CreateCloudFrontOriginAccessIdentityResult struct {
	XMLName xml.Name `xml:"CreateCloudFrontOriginAccessIdentityResult"`

	CloudFrontOriginAccessIdentity *CloudFrontOriginAccessIdentity `xml:"CloudFrontOriginAccessIdentity,omitempty"`
	ETag                           aws.StringValue                 `xml:"-"`
	Location                       aws.StringValue                 `xml:"-"`
}

func (v *CreateCloudFrontOriginAccessIdentityResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateCloudFrontOriginAccessIdentityResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateDistributionRequest is undocumented.
type CreateDistributionRequest struct {
	XMLName xml.Name `xml:""`

	DistributionConfig *DistributionConfig `xml:"DistributionConfig,omitempty"`
}

func (v *CreateDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DistributionConfig"); err != nil {
		errors["DistributionConfig"] = append(errors["DistributionConfig"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateDistributionResult is undocumented.
type CreateDistributionResult struct {
	XMLName xml.Name `xml:"CreateDistributionResult"`

	Distribution *Distribution   `xml:"Distribution,omitempty"`
	ETag         aws.StringValue `xml:"-"`
	Location     aws.StringValue `xml:"-"`
}

func (v *CreateDistributionResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateDistributionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInvalidationRequest is undocumented.
type CreateInvalidationRequest struct {
	XMLName xml.Name `xml:""`

	DistributionID    aws.StringValue    `xml:"-"`
	InvalidationBatch *InvalidationBatch `xml:"InvalidationBatch,omitempty"`
}

func (v *CreateInvalidationRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateInvalidationRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DistributionID"); err != nil {
		errors["DistributionID"] = append(errors["DistributionID"], err)
	}

	if err := model.ValidateRequired(v, "InvalidationBatch"); err != nil {
		errors["InvalidationBatch"] = append(errors["InvalidationBatch"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInvalidationResult is undocumented.
type CreateInvalidationResult struct {
	XMLName xml.Name `xml:"CreateInvalidationResult"`

	Invalidation *Invalidation   `xml:"Invalidation,omitempty"`
	Location     aws.StringValue `xml:"-"`
}

func (v *CreateInvalidationResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateInvalidationResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateStreamingDistributionRequest is undocumented.
type CreateStreamingDistributionRequest struct {
	XMLName xml.Name `xml:""`

	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig,omitempty"`
}

func (v *CreateStreamingDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateStreamingDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "StreamingDistributionConfig"); err != nil {
		errors["StreamingDistributionConfig"] = append(errors["StreamingDistributionConfig"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateStreamingDistributionResult is undocumented.
type CreateStreamingDistributionResult struct {
	XMLName xml.Name `xml:"CreateStreamingDistributionResult"`

	ETag                  aws.StringValue        `xml:"-"`
	Location              aws.StringValue        `xml:"-"`
	StreamingDistribution *StreamingDistribution `xml:"StreamingDistribution,omitempty"`
}

func (v *CreateStreamingDistributionResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CreateStreamingDistributionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CustomErrorResponse is undocumented.
type CustomErrorResponse struct {
	XMLName xml.Name `xml:"CustomErrorResponse"`

	ErrorCachingMinTTL aws.LongValue    `xml:"ErrorCachingMinTTL"`
	ErrorCode          aws.IntegerValue `xml:"ErrorCode"`
	ResponseCode       aws.StringValue  `xml:"ResponseCode"`
	ResponsePagePath   aws.StringValue  `xml:"ResponsePagePath"`
}

func (v *CustomErrorResponse) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CustomErrorResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ErrorCode"); err != nil {
		errors["ErrorCode"] = append(errors["ErrorCode"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CustomErrorResponses is undocumented.
type CustomErrorResponses struct {
	XMLName xml.Name `xml:"CustomErrorResponses"`

	Items    []CustomErrorResponse `xml:"Items>CustomErrorResponse,omitempty"`
	Quantity aws.IntegerValue      `xml:"Quantity"`
}

func (v *CustomErrorResponses) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CustomErrorResponses) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CustomOriginConfig is undocumented.
type CustomOriginConfig struct {
	XMLName xml.Name `xml:"CustomOriginConfig"`

	HTTPPort             aws.IntegerValue `xml:"HTTPPort"`
	HTTPSPort            aws.IntegerValue `xml:"HTTPSPort"`
	OriginProtocolPolicy aws.StringValue  `xml:"OriginProtocolPolicy"`
}

func (v *CustomOriginConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *CustomOriginConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "HTTPPort"); err != nil {
		errors["HTTPPort"] = append(errors["HTTPPort"], err)
	}

	if err := model.ValidateRequired(v, "HTTPSPort"); err != nil {
		errors["HTTPSPort"] = append(errors["HTTPSPort"], err)
	}

	if err := model.ValidateRequired(v, "OriginProtocolPolicy"); err != nil {
		errors["OriginProtocolPolicy"] = append(errors["OriginProtocolPolicy"], err)
	}

	OriginProtocolPolicyEnum := []string{
		OriginProtocolPolicyHTTPOnly,
		OriginProtocolPolicyMatchViewer,
	}
	if err := model.ValidateEnum(v, "OriginProtocolPolicy", OriginProtocolPolicyEnum); err != nil {
		errors["OriginProtocolPolicy"] = append(errors["OriginProtocolPolicy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefaultCacheBehavior is undocumented.
type DefaultCacheBehavior struct {
	XMLName xml.Name `xml:"DefaultCacheBehavior"`

	AllowedMethods       *AllowedMethods  `xml:"AllowedMethods,omitempty"`
	ForwardedValues      *ForwardedValues `xml:"ForwardedValues,omitempty"`
	MinTTL               aws.LongValue    `xml:"MinTTL"`
	SmoothStreaming      aws.BooleanValue `xml:"SmoothStreaming"`
	TargetOriginID       aws.StringValue  `xml:"TargetOriginId"`
	TrustedSigners       *TrustedSigners  `xml:"TrustedSigners,omitempty"`
	ViewerProtocolPolicy aws.StringValue  `xml:"ViewerProtocolPolicy"`
}

func (v *DefaultCacheBehavior) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DefaultCacheBehavior) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ForwardedValues"); err != nil {
		errors["ForwardedValues"] = append(errors["ForwardedValues"], err)
	}

	if err := model.ValidateRequired(v, "MinTTL"); err != nil {
		errors["MinTTL"] = append(errors["MinTTL"], err)
	}

	if err := model.ValidateRequired(v, "TargetOriginID"); err != nil {
		errors["TargetOriginID"] = append(errors["TargetOriginID"], err)
	}

	if err := model.ValidateRequired(v, "TrustedSigners"); err != nil {
		errors["TrustedSigners"] = append(errors["TrustedSigners"], err)
	}

	if err := model.ValidateRequired(v, "ViewerProtocolPolicy"); err != nil {
		errors["ViewerProtocolPolicy"] = append(errors["ViewerProtocolPolicy"], err)
	}

	ViewerProtocolPolicyEnum := []string{
		ViewerProtocolPolicyAllowAll,
		ViewerProtocolPolicyHTTPSOnly,
		ViewerProtocolPolicyRedirectToHTTPS,
	}
	if err := model.ValidateEnum(v, "ViewerProtocolPolicy", ViewerProtocolPolicyEnum); err != nil {
		errors["ViewerProtocolPolicy"] = append(errors["ViewerProtocolPolicy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteCloudFrontOriginAccessIdentityRequest is undocumented.
type DeleteCloudFrontOriginAccessIdentityRequest struct {
	XMLName xml.Name `xml:""`

	ID      aws.StringValue `xml:"-"`
	IfMatch aws.StringValue `xml:"-"`
}

func (v *DeleteCloudFrontOriginAccessIdentityRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DeleteCloudFrontOriginAccessIdentityRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteDistributionRequest is undocumented.
type DeleteDistributionRequest struct {
	XMLName xml.Name `xml:""`

	ID      aws.StringValue `xml:"-"`
	IfMatch aws.StringValue `xml:"-"`
}

func (v *DeleteDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DeleteDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteStreamingDistributionRequest is undocumented.
type DeleteStreamingDistributionRequest struct {
	XMLName xml.Name `xml:""`

	ID      aws.StringValue `xml:"-"`
	IfMatch aws.StringValue `xml:"-"`
}

func (v *DeleteStreamingDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DeleteStreamingDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Distribution is undocumented.
type Distribution struct {
	XMLName xml.Name `xml:"Distribution"`

	ActiveTrustedSigners          *ActiveTrustedSigners `xml:"ActiveTrustedSigners,omitempty"`
	DistributionConfig            *DistributionConfig   `xml:"DistributionConfig,omitempty"`
	DomainName                    aws.StringValue       `xml:"DomainName"`
	ID                            aws.StringValue       `xml:"Id"`
	InProgressInvalidationBatches aws.IntegerValue      `xml:"InProgressInvalidationBatches"`
	LastModifiedTime              time.Time             `xml:"LastModifiedTime"`
	Status                        aws.StringValue       `xml:"Status"`
}

func (v *Distribution) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Distribution) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActiveTrustedSigners"); err != nil {
		errors["ActiveTrustedSigners"] = append(errors["ActiveTrustedSigners"], err)
	}

	if err := model.ValidateRequired(v, "DistributionConfig"); err != nil {
		errors["DistributionConfig"] = append(errors["DistributionConfig"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "InProgressInvalidationBatches"); err != nil {
		errors["InProgressInvalidationBatches"] = append(errors["InProgressInvalidationBatches"], err)
	}

	if err := model.ValidateRequired(v, "LastModifiedTime"); err != nil {
		errors["LastModifiedTime"] = append(errors["LastModifiedTime"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DistributionConfig is undocumented.
type DistributionConfig struct {
	XMLName xml.Name `xml:"DistributionConfig"`

	Aliases              *Aliases              `xml:"Aliases,omitempty"`
	CacheBehaviors       *CacheBehaviors       `xml:"CacheBehaviors,omitempty"`
	CallerReference      aws.StringValue       `xml:"CallerReference"`
	Comment              aws.StringValue       `xml:"Comment"`
	CustomErrorResponses *CustomErrorResponses `xml:"CustomErrorResponses,omitempty"`
	DefaultCacheBehavior *DefaultCacheBehavior `xml:"DefaultCacheBehavior,omitempty"`
	DefaultRootObject    aws.StringValue       `xml:"DefaultRootObject"`
	Enabled              aws.BooleanValue      `xml:"Enabled"`
	Logging              *LoggingConfig        `xml:"Logging,omitempty"`
	Origins              *Origins              `xml:"Origins,omitempty"`
	PriceClass           aws.StringValue       `xml:"PriceClass"`
	Restrictions         *Restrictions         `xml:"Restrictions,omitempty"`
	ViewerCertificate    *ViewerCertificate    `xml:"ViewerCertificate,omitempty"`
}

func (v *DistributionConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DistributionConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Aliases"); err != nil {
		errors["Aliases"] = append(errors["Aliases"], err)
	}

	if err := model.ValidateRequired(v, "CacheBehaviors"); err != nil {
		errors["CacheBehaviors"] = append(errors["CacheBehaviors"], err)
	}

	if err := model.ValidateRequired(v, "CallerReference"); err != nil {
		errors["CallerReference"] = append(errors["CallerReference"], err)
	}

	if err := model.ValidateRequired(v, "Comment"); err != nil {
		errors["Comment"] = append(errors["Comment"], err)
	}

	if err := model.ValidateRequired(v, "DefaultCacheBehavior"); err != nil {
		errors["DefaultCacheBehavior"] = append(errors["DefaultCacheBehavior"], err)
	}

	if err := model.ValidateRequired(v, "DefaultRootObject"); err != nil {
		errors["DefaultRootObject"] = append(errors["DefaultRootObject"], err)
	}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "Logging"); err != nil {
		errors["Logging"] = append(errors["Logging"], err)
	}

	if err := model.ValidateRequired(v, "Origins"); err != nil {
		errors["Origins"] = append(errors["Origins"], err)
	}

	if err := model.ValidateRequired(v, "PriceClass"); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	PriceClassEnum := []string{
		PriceClassPriceClass100,
		PriceClassPriceClass200,
		PriceClassPriceClassAll,
	}
	if err := model.ValidateEnum(v, "PriceClass", PriceClassEnum); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DistributionList is undocumented.
type DistributionList struct {
	XMLName xml.Name `xml:"DistributionList"`

	IsTruncated aws.BooleanValue      `xml:"IsTruncated"`
	Items       []DistributionSummary `xml:"Items>DistributionSummary,omitempty"`
	Marker      aws.StringValue       `xml:"Marker"`
	MaxItems    aws.IntegerValue      `xml:"MaxItems"`
	NextMarker  aws.StringValue       `xml:"NextMarker"`
	Quantity    aws.IntegerValue      `xml:"Quantity"`
}

func (v *DistributionList) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DistributionList) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IsTruncated"); err != nil {
		errors["IsTruncated"] = append(errors["IsTruncated"], err)
	}

	if err := model.ValidateRequired(v, "Marker"); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "MaxItems"); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DistributionSummary is undocumented.
type DistributionSummary struct {
	XMLName xml.Name `xml:"DistributionSummary"`

	Aliases              *Aliases              `xml:"Aliases,omitempty"`
	CacheBehaviors       *CacheBehaviors       `xml:"CacheBehaviors,omitempty"`
	Comment              aws.StringValue       `xml:"Comment"`
	CustomErrorResponses *CustomErrorResponses `xml:"CustomErrorResponses,omitempty"`
	DefaultCacheBehavior *DefaultCacheBehavior `xml:"DefaultCacheBehavior,omitempty"`
	DomainName           aws.StringValue       `xml:"DomainName"`
	Enabled              aws.BooleanValue      `xml:"Enabled"`
	ID                   aws.StringValue       `xml:"Id"`
	LastModifiedTime     time.Time             `xml:"LastModifiedTime"`
	Origins              *Origins              `xml:"Origins,omitempty"`
	PriceClass           aws.StringValue       `xml:"PriceClass"`
	Restrictions         *Restrictions         `xml:"Restrictions,omitempty"`
	Status               aws.StringValue       `xml:"Status"`
	ViewerCertificate    *ViewerCertificate    `xml:"ViewerCertificate,omitempty"`
}

func (v *DistributionSummary) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *DistributionSummary) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Aliases"); err != nil {
		errors["Aliases"] = append(errors["Aliases"], err)
	}

	if err := model.ValidateRequired(v, "CacheBehaviors"); err != nil {
		errors["CacheBehaviors"] = append(errors["CacheBehaviors"], err)
	}

	if err := model.ValidateRequired(v, "Comment"); err != nil {
		errors["Comment"] = append(errors["Comment"], err)
	}

	if err := model.ValidateRequired(v, "CustomErrorResponses"); err != nil {
		errors["CustomErrorResponses"] = append(errors["CustomErrorResponses"], err)
	}

	if err := model.ValidateRequired(v, "DefaultCacheBehavior"); err != nil {
		errors["DefaultCacheBehavior"] = append(errors["DefaultCacheBehavior"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "LastModifiedTime"); err != nil {
		errors["LastModifiedTime"] = append(errors["LastModifiedTime"], err)
	}

	if err := model.ValidateRequired(v, "Origins"); err != nil {
		errors["Origins"] = append(errors["Origins"], err)
	}

	if err := model.ValidateRequired(v, "PriceClass"); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	PriceClassEnum := []string{
		PriceClassPriceClass100,
		PriceClassPriceClass200,
		PriceClassPriceClassAll,
	}
	if err := model.ValidateEnum(v, "PriceClass", PriceClassEnum); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	if err := model.ValidateRequired(v, "Restrictions"); err != nil {
		errors["Restrictions"] = append(errors["Restrictions"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "ViewerCertificate"); err != nil {
		errors["ViewerCertificate"] = append(errors["ViewerCertificate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ForwardedValues is undocumented.
type ForwardedValues struct {
	XMLName xml.Name `xml:"ForwardedValues"`

	Cookies     *CookiePreference `xml:"Cookies,omitempty"`
	Headers     *Headers          `xml:"Headers,omitempty"`
	QueryString aws.BooleanValue  `xml:"QueryString"`
}

func (v *ForwardedValues) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ForwardedValues) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cookies"); err != nil {
		errors["Cookies"] = append(errors["Cookies"], err)
	}

	if err := model.ValidateRequired(v, "QueryString"); err != nil {
		errors["QueryString"] = append(errors["QueryString"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GeoRestriction is undocumented.
type GeoRestriction struct {
	XMLName xml.Name `xml:"GeoRestriction"`

	Items           []string         `xml:"Items>Location,omitempty"`
	Quantity        aws.IntegerValue `xml:"Quantity"`
	RestrictionType aws.StringValue  `xml:"RestrictionType"`
}

func (v *GeoRestriction) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GeoRestriction) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if err := model.ValidateRequired(v, "RestrictionType"); err != nil {
		errors["RestrictionType"] = append(errors["RestrictionType"], err)
	}

	RestrictionTypeEnum := []string{
		GeoRestrictionTypeBlacklist,
		GeoRestrictionTypeNone,
		GeoRestrictionTypeWhitelist,
	}
	if err := model.ValidateEnum(v, "RestrictionType", RestrictionTypeEnum); err != nil {
		errors["RestrictionType"] = append(errors["RestrictionType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	GeoRestrictionTypeBlacklist = "blacklist"
	GeoRestrictionTypeNone      = "none"
	GeoRestrictionTypeWhitelist = "whitelist"
)

// GetCloudFrontOriginAccessIdentityConfigRequest is undocumented.
type GetCloudFrontOriginAccessIdentityConfigRequest struct {
	XMLName xml.Name `xml:""`

	ID aws.StringValue `xml:"-"`
}

func (v *GetCloudFrontOriginAccessIdentityConfigRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetCloudFrontOriginAccessIdentityConfigRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetCloudFrontOriginAccessIdentityConfigResult is undocumented.
type GetCloudFrontOriginAccessIdentityConfigResult struct {
	XMLName xml.Name `xml:"GetCloudFrontOriginAccessIdentityConfigResult"`

	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig,omitempty"`
	ETag                                 aws.StringValue                       `xml:"-"`
}

func (v *GetCloudFrontOriginAccessIdentityConfigResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetCloudFrontOriginAccessIdentityConfigResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetCloudFrontOriginAccessIdentityRequest is undocumented.
type GetCloudFrontOriginAccessIdentityRequest struct {
	XMLName xml.Name `xml:""`

	ID aws.StringValue `xml:"-"`
}

func (v *GetCloudFrontOriginAccessIdentityRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetCloudFrontOriginAccessIdentityRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetCloudFrontOriginAccessIdentityResult is undocumented.
type GetCloudFrontOriginAccessIdentityResult struct {
	XMLName xml.Name `xml:"GetCloudFrontOriginAccessIdentityResult"`

	CloudFrontOriginAccessIdentity *CloudFrontOriginAccessIdentity `xml:"CloudFrontOriginAccessIdentity,omitempty"`
	ETag                           aws.StringValue                 `xml:"-"`
}

func (v *GetCloudFrontOriginAccessIdentityResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetCloudFrontOriginAccessIdentityResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetDistributionConfigRequest is undocumented.
type GetDistributionConfigRequest struct {
	XMLName xml.Name `xml:""`

	ID aws.StringValue `xml:"-"`
}

func (v *GetDistributionConfigRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetDistributionConfigRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetDistributionConfigResult is undocumented.
type GetDistributionConfigResult struct {
	XMLName xml.Name `xml:"GetDistributionConfigResult"`

	DistributionConfig *DistributionConfig `xml:"DistributionConfig,omitempty"`
	ETag               aws.StringValue     `xml:"-"`
}

func (v *GetDistributionConfigResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetDistributionConfigResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetDistributionRequest is undocumented.
type GetDistributionRequest struct {
	XMLName xml.Name `xml:""`

	ID aws.StringValue `xml:"-"`
}

func (v *GetDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetDistributionResult is undocumented.
type GetDistributionResult struct {
	XMLName xml.Name `xml:"GetDistributionResult"`

	Distribution *Distribution   `xml:"Distribution,omitempty"`
	ETag         aws.StringValue `xml:"-"`
}

func (v *GetDistributionResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetDistributionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetInvalidationRequest is undocumented.
type GetInvalidationRequest struct {
	XMLName xml.Name `xml:""`

	DistributionID aws.StringValue `xml:"-"`
	ID             aws.StringValue `xml:"-"`
}

func (v *GetInvalidationRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetInvalidationRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DistributionID"); err != nil {
		errors["DistributionID"] = append(errors["DistributionID"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetInvalidationResult is undocumented.
type GetInvalidationResult struct {
	XMLName xml.Name `xml:"GetInvalidationResult"`

	Invalidation *Invalidation `xml:"Invalidation,omitempty"`
}

func (v *GetInvalidationResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetInvalidationResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetStreamingDistributionConfigRequest is undocumented.
type GetStreamingDistributionConfigRequest struct {
	XMLName xml.Name `xml:""`

	ID aws.StringValue `xml:"-"`
}

func (v *GetStreamingDistributionConfigRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetStreamingDistributionConfigRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetStreamingDistributionConfigResult is undocumented.
type GetStreamingDistributionConfigResult struct {
	XMLName xml.Name `xml:"GetStreamingDistributionConfigResult"`

	ETag                        aws.StringValue              `xml:"-"`
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig,omitempty"`
}

func (v *GetStreamingDistributionConfigResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetStreamingDistributionConfigResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetStreamingDistributionRequest is undocumented.
type GetStreamingDistributionRequest struct {
	XMLName xml.Name `xml:""`

	ID aws.StringValue `xml:"-"`
}

func (v *GetStreamingDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetStreamingDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetStreamingDistributionResult is undocumented.
type GetStreamingDistributionResult struct {
	XMLName xml.Name `xml:"GetStreamingDistributionResult"`

	ETag                  aws.StringValue        `xml:"-"`
	StreamingDistribution *StreamingDistribution `xml:"StreamingDistribution,omitempty"`
}

func (v *GetStreamingDistributionResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *GetStreamingDistributionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Headers is undocumented.
type Headers struct {
	XMLName xml.Name `xml:"Headers"`

	Items    []string         `xml:"Items>Name,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *Headers) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Headers) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Invalidation is undocumented.
type Invalidation struct {
	XMLName xml.Name `xml:"Invalidation"`

	CreateTime        time.Time          `xml:"CreateTime"`
	ID                aws.StringValue    `xml:"Id"`
	InvalidationBatch *InvalidationBatch `xml:"InvalidationBatch,omitempty"`
	Status            aws.StringValue    `xml:"Status"`
}

func (v *Invalidation) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Invalidation) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CreateTime"); err != nil {
		errors["CreateTime"] = append(errors["CreateTime"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "InvalidationBatch"); err != nil {
		errors["InvalidationBatch"] = append(errors["InvalidationBatch"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InvalidationBatch is undocumented.
type InvalidationBatch struct {
	XMLName xml.Name `xml:"InvalidationBatch"`

	CallerReference aws.StringValue `xml:"CallerReference"`
	Paths           *Paths          `xml:"Paths,omitempty"`
}

func (v *InvalidationBatch) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *InvalidationBatch) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CallerReference"); err != nil {
		errors["CallerReference"] = append(errors["CallerReference"], err)
	}

	if err := model.ValidateRequired(v, "Paths"); err != nil {
		errors["Paths"] = append(errors["Paths"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InvalidationList is undocumented.
type InvalidationList struct {
	XMLName xml.Name `xml:"InvalidationList"`

	IsTruncated aws.BooleanValue      `xml:"IsTruncated"`
	Items       []InvalidationSummary `xml:"Items>InvalidationSummary,omitempty"`
	Marker      aws.StringValue       `xml:"Marker"`
	MaxItems    aws.IntegerValue      `xml:"MaxItems"`
	NextMarker  aws.StringValue       `xml:"NextMarker"`
	Quantity    aws.IntegerValue      `xml:"Quantity"`
}

func (v *InvalidationList) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *InvalidationList) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IsTruncated"); err != nil {
		errors["IsTruncated"] = append(errors["IsTruncated"], err)
	}

	if err := model.ValidateRequired(v, "Marker"); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "MaxItems"); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InvalidationSummary is undocumented.
type InvalidationSummary struct {
	XMLName xml.Name `xml:"InvalidationSummary"`

	CreateTime time.Time       `xml:"CreateTime"`
	ID         aws.StringValue `xml:"Id"`
	Status     aws.StringValue `xml:"Status"`
}

func (v *InvalidationSummary) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *InvalidationSummary) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CreateTime"); err != nil {
		errors["CreateTime"] = append(errors["CreateTime"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	ItemSelectionAll       = "all"
	ItemSelectionNone      = "none"
	ItemSelectionWhitelist = "whitelist"
)

// KeyPairIDs is undocumented.
type KeyPairIDs struct {
	XMLName xml.Name `xml:"KeyPairIds"`

	Items    []string         `xml:"Items>KeyPairId,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *KeyPairIDs) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *KeyPairIDs) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListCloudFrontOriginAccessIdentitiesRequest is undocumented.
type ListCloudFrontOriginAccessIdentitiesRequest struct {
	XMLName xml.Name `xml:""`

	Marker   aws.StringValue `xml:"-"`
	MaxItems aws.StringValue `xml:"-"`
}

func (v *ListCloudFrontOriginAccessIdentitiesRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListCloudFrontOriginAccessIdentitiesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListCloudFrontOriginAccessIdentitiesResult is undocumented.
type ListCloudFrontOriginAccessIdentitiesResult struct {
	XMLName xml.Name `xml:"ListCloudFrontOriginAccessIdentitiesResult"`

	CloudFrontOriginAccessIdentityList *CloudFrontOriginAccessIdentityList `xml:"CloudFrontOriginAccessIdentityList,omitempty"`
}

func (v *ListCloudFrontOriginAccessIdentitiesResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListCloudFrontOriginAccessIdentitiesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListDistributionsRequest is undocumented.
type ListDistributionsRequest struct {
	XMLName xml.Name `xml:""`

	Marker   aws.StringValue `xml:"-"`
	MaxItems aws.StringValue `xml:"-"`
}

func (v *ListDistributionsRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListDistributionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListDistributionsResult is undocumented.
type ListDistributionsResult struct {
	XMLName xml.Name `xml:"ListDistributionsResult"`

	DistributionList *DistributionList `xml:"DistributionList,omitempty"`
}

func (v *ListDistributionsResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListDistributionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListInvalidationsRequest is undocumented.
type ListInvalidationsRequest struct {
	XMLName xml.Name `xml:""`

	DistributionID aws.StringValue `xml:"-"`
	Marker         aws.StringValue `xml:"-"`
	MaxItems       aws.StringValue `xml:"-"`
}

func (v *ListInvalidationsRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListInvalidationsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DistributionID"); err != nil {
		errors["DistributionID"] = append(errors["DistributionID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListInvalidationsResult is undocumented.
type ListInvalidationsResult struct {
	XMLName xml.Name `xml:"ListInvalidationsResult"`

	InvalidationList *InvalidationList `xml:"InvalidationList,omitempty"`
}

func (v *ListInvalidationsResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListInvalidationsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListStreamingDistributionsRequest is undocumented.
type ListStreamingDistributionsRequest struct {
	XMLName xml.Name `xml:""`

	Marker   aws.StringValue `xml:"-"`
	MaxItems aws.StringValue `xml:"-"`
}

func (v *ListStreamingDistributionsRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListStreamingDistributionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListStreamingDistributionsResult is undocumented.
type ListStreamingDistributionsResult struct {
	XMLName xml.Name `xml:"ListStreamingDistributionsResult"`

	StreamingDistributionList *StreamingDistributionList `xml:"StreamingDistributionList,omitempty"`
}

func (v *ListStreamingDistributionsResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ListStreamingDistributionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LoggingConfig is undocumented.
type LoggingConfig struct {
	XMLName xml.Name `xml:"LoggingConfig"`

	Bucket         aws.StringValue  `xml:"Bucket"`
	Enabled        aws.BooleanValue `xml:"Enabled"`
	IncludeCookies aws.BooleanValue `xml:"IncludeCookies"`
	Prefix         aws.StringValue  `xml:"Prefix"`
}

func (v *LoggingConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *LoggingConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Bucket"); err != nil {
		errors["Bucket"] = append(errors["Bucket"], err)
	}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "IncludeCookies"); err != nil {
		errors["IncludeCookies"] = append(errors["IncludeCookies"], err)
	}

	if err := model.ValidateRequired(v, "Prefix"); err != nil {
		errors["Prefix"] = append(errors["Prefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	MethodDelete  = "DELETE"
	MethodGet     = "GET"
	MethodHead    = "HEAD"
	MethodOptions = "OPTIONS"
	MethodPatch   = "PATCH"
	MethodPost    = "POST"
	MethodPut     = "PUT"
)

// Possible values for CloudFront.
const (
	MinimumProtocolVersionSSLv3 = "SSLv3"
	MinimumProtocolVersionTLSv1 = "TLSv1"
)

// Origin is undocumented.
type Origin struct {
	XMLName xml.Name `xml:"Origin"`

	CustomOriginConfig *CustomOriginConfig `xml:"CustomOriginConfig,omitempty"`
	DomainName         aws.StringValue     `xml:"DomainName"`
	ID                 aws.StringValue     `xml:"Id"`
	S3OriginConfig     *S3OriginConfig     `xml:"S3OriginConfig,omitempty"`
}

func (v *Origin) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Origin) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	OriginProtocolPolicyHTTPOnly    = "http-only"
	OriginProtocolPolicyMatchViewer = "match-viewer"
)

// Origins is undocumented.
type Origins struct {
	XMLName xml.Name `xml:"Origins"`

	Items    []Origin         `xml:"Items>Origin,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *Origins) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Origins) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Items", 1); err != nil {
		errors["Items"] = append(errors["Items"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Paths is undocumented.
type Paths struct {
	XMLName xml.Name `xml:"Paths"`

	Items    []string         `xml:"Items>Path,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *Paths) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Paths) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	PriceClassPriceClass100 = "PriceClass_100"
	PriceClassPriceClass200 = "PriceClass_200"
	PriceClassPriceClassAll = "PriceClass_All"
)

// Restrictions is undocumented.
type Restrictions struct {
	XMLName xml.Name `xml:"Restrictions"`

	GeoRestriction *GeoRestriction `xml:"GeoRestriction,omitempty"`
}

func (v *Restrictions) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Restrictions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GeoRestriction"); err != nil {
		errors["GeoRestriction"] = append(errors["GeoRestriction"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// S3Origin is undocumented.
type S3Origin struct {
	XMLName xml.Name `xml:"S3Origin"`

	DomainName           aws.StringValue `xml:"DomainName"`
	OriginAccessIdentity aws.StringValue `xml:"OriginAccessIdentity"`
}

func (v *S3Origin) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *S3Origin) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "OriginAccessIdentity"); err != nil {
		errors["OriginAccessIdentity"] = append(errors["OriginAccessIdentity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// S3OriginConfig is undocumented.
type S3OriginConfig struct {
	XMLName xml.Name `xml:"S3OriginConfig"`

	OriginAccessIdentity aws.StringValue `xml:"OriginAccessIdentity"`
}

func (v *S3OriginConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *S3OriginConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "OriginAccessIdentity"); err != nil {
		errors["OriginAccessIdentity"] = append(errors["OriginAccessIdentity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	SSLSupportMethodSNIOnly = "sni-only"
	SSLSupportMethodVIP     = "vip"
)

// Signer is undocumented.
type Signer struct {
	XMLName xml.Name `xml:"Signer"`

	AWSAccountNumber aws.StringValue `xml:"AwsAccountNumber"`
	KeyPairIDs       *KeyPairIDs     `xml:"KeyPairIds,omitempty"`
}

func (v *Signer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *Signer) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StreamingDistribution is undocumented.
type StreamingDistribution struct {
	XMLName xml.Name `xml:"StreamingDistribution"`

	ActiveTrustedSigners        *ActiveTrustedSigners        `xml:"ActiveTrustedSigners,omitempty"`
	DomainName                  aws.StringValue              `xml:"DomainName"`
	ID                          aws.StringValue              `xml:"Id"`
	LastModifiedTime            time.Time                    `xml:"LastModifiedTime"`
	Status                      aws.StringValue              `xml:"Status"`
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig,omitempty"`
}

func (v *StreamingDistribution) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *StreamingDistribution) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActiveTrustedSigners"); err != nil {
		errors["ActiveTrustedSigners"] = append(errors["ActiveTrustedSigners"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "StreamingDistributionConfig"); err != nil {
		errors["StreamingDistributionConfig"] = append(errors["StreamingDistributionConfig"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StreamingDistributionConfig is undocumented.
type StreamingDistributionConfig struct {
	XMLName xml.Name `xml:"StreamingDistributionConfig"`

	Aliases         *Aliases                `xml:"Aliases,omitempty"`
	CallerReference aws.StringValue         `xml:"CallerReference"`
	Comment         aws.StringValue         `xml:"Comment"`
	Enabled         aws.BooleanValue        `xml:"Enabled"`
	Logging         *StreamingLoggingConfig `xml:"Logging,omitempty"`
	PriceClass      aws.StringValue         `xml:"PriceClass"`
	S3Origin        *S3Origin               `xml:"S3Origin,omitempty"`
	TrustedSigners  *TrustedSigners         `xml:"TrustedSigners,omitempty"`
}

func (v *StreamingDistributionConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *StreamingDistributionConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Aliases"); err != nil {
		errors["Aliases"] = append(errors["Aliases"], err)
	}

	if err := model.ValidateRequired(v, "CallerReference"); err != nil {
		errors["CallerReference"] = append(errors["CallerReference"], err)
	}

	if err := model.ValidateRequired(v, "Comment"); err != nil {
		errors["Comment"] = append(errors["Comment"], err)
	}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "Logging"); err != nil {
		errors["Logging"] = append(errors["Logging"], err)
	}

	if err := model.ValidateRequired(v, "PriceClass"); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	PriceClassEnum := []string{
		PriceClassPriceClass100,
		PriceClassPriceClass200,
		PriceClassPriceClassAll,
	}
	if err := model.ValidateEnum(v, "PriceClass", PriceClassEnum); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	if err := model.ValidateRequired(v, "S3Origin"); err != nil {
		errors["S3Origin"] = append(errors["S3Origin"], err)
	}

	if err := model.ValidateRequired(v, "TrustedSigners"); err != nil {
		errors["TrustedSigners"] = append(errors["TrustedSigners"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StreamingDistributionList is undocumented.
type StreamingDistributionList struct {
	XMLName xml.Name `xml:"StreamingDistributionList"`

	IsTruncated aws.BooleanValue               `xml:"IsTruncated"`
	Items       []StreamingDistributionSummary `xml:"Items>StreamingDistributionSummary,omitempty"`
	Marker      aws.StringValue                `xml:"Marker"`
	MaxItems    aws.IntegerValue               `xml:"MaxItems"`
	NextMarker  aws.StringValue                `xml:"NextMarker"`
	Quantity    aws.IntegerValue               `xml:"Quantity"`
}

func (v *StreamingDistributionList) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *StreamingDistributionList) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IsTruncated"); err != nil {
		errors["IsTruncated"] = append(errors["IsTruncated"], err)
	}

	if err := model.ValidateRequired(v, "Marker"); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "MaxItems"); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StreamingDistributionSummary is undocumented.
type StreamingDistributionSummary struct {
	XMLName xml.Name `xml:"StreamingDistributionSummary"`

	Aliases          *Aliases         `xml:"Aliases,omitempty"`
	Comment          aws.StringValue  `xml:"Comment"`
	DomainName       aws.StringValue  `xml:"DomainName"`
	Enabled          aws.BooleanValue `xml:"Enabled"`
	ID               aws.StringValue  `xml:"Id"`
	LastModifiedTime time.Time        `xml:"LastModifiedTime"`
	PriceClass       aws.StringValue  `xml:"PriceClass"`
	S3Origin         *S3Origin        `xml:"S3Origin,omitempty"`
	Status           aws.StringValue  `xml:"Status"`
	TrustedSigners   *TrustedSigners  `xml:"TrustedSigners,omitempty"`
}

func (v *StreamingDistributionSummary) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *StreamingDistributionSummary) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Aliases"); err != nil {
		errors["Aliases"] = append(errors["Aliases"], err)
	}

	if err := model.ValidateRequired(v, "Comment"); err != nil {
		errors["Comment"] = append(errors["Comment"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "LastModifiedTime"); err != nil {
		errors["LastModifiedTime"] = append(errors["LastModifiedTime"], err)
	}

	if err := model.ValidateRequired(v, "PriceClass"); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	PriceClassEnum := []string{
		PriceClassPriceClass100,
		PriceClassPriceClass200,
		PriceClassPriceClassAll,
	}
	if err := model.ValidateEnum(v, "PriceClass", PriceClassEnum); err != nil {
		errors["PriceClass"] = append(errors["PriceClass"], err)
	}

	if err := model.ValidateRequired(v, "S3Origin"); err != nil {
		errors["S3Origin"] = append(errors["S3Origin"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "TrustedSigners"); err != nil {
		errors["TrustedSigners"] = append(errors["TrustedSigners"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StreamingLoggingConfig is undocumented.
type StreamingLoggingConfig struct {
	XMLName xml.Name `xml:"StreamingLoggingConfig"`

	Bucket  aws.StringValue  `xml:"Bucket"`
	Enabled aws.BooleanValue `xml:"Enabled"`
	Prefix  aws.StringValue  `xml:"Prefix"`
}

func (v *StreamingLoggingConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *StreamingLoggingConfig) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Bucket"); err != nil {
		errors["Bucket"] = append(errors["Bucket"], err)
	}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "Prefix"); err != nil {
		errors["Prefix"] = append(errors["Prefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TrustedSigners is undocumented.
type TrustedSigners struct {
	XMLName xml.Name `xml:"TrustedSigners"`

	Enabled  aws.BooleanValue `xml:"Enabled"`
	Items    []string         `xml:"Items>AwsAccountNumber,omitempty"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

func (v *TrustedSigners) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *TrustedSigners) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if err := model.ValidateRequired(v, "Quantity"); err != nil {
		errors["Quantity"] = append(errors["Quantity"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateCloudFrontOriginAccessIdentityRequest is undocumented.
type UpdateCloudFrontOriginAccessIdentityRequest struct {
	XMLName xml.Name `xml:""`

	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig,omitempty"`
	ID                                   aws.StringValue                       `xml:"-"`
	IfMatch                              aws.StringValue                       `xml:"-"`
}

func (v *UpdateCloudFrontOriginAccessIdentityRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *UpdateCloudFrontOriginAccessIdentityRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CloudFrontOriginAccessIdentityConfig"); err != nil {
		errors["CloudFrontOriginAccessIdentityConfig"] = append(errors["CloudFrontOriginAccessIdentityConfig"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateCloudFrontOriginAccessIdentityResult is undocumented.
type UpdateCloudFrontOriginAccessIdentityResult struct {
	XMLName xml.Name `xml:"UpdateCloudFrontOriginAccessIdentityResult"`

	CloudFrontOriginAccessIdentity *CloudFrontOriginAccessIdentity `xml:"CloudFrontOriginAccessIdentity,omitempty"`
	ETag                           aws.StringValue                 `xml:"-"`
}

func (v *UpdateCloudFrontOriginAccessIdentityResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *UpdateCloudFrontOriginAccessIdentityResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateDistributionRequest is undocumented.
type UpdateDistributionRequest struct {
	XMLName xml.Name `xml:""`

	DistributionConfig *DistributionConfig `xml:"DistributionConfig,omitempty"`
	ID                 aws.StringValue     `xml:"-"`
	IfMatch            aws.StringValue     `xml:"-"`
}

func (v *UpdateDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *UpdateDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DistributionConfig"); err != nil {
		errors["DistributionConfig"] = append(errors["DistributionConfig"], err)
	}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateDistributionResult is undocumented.
type UpdateDistributionResult struct {
	XMLName xml.Name `xml:"UpdateDistributionResult"`

	Distribution *Distribution   `xml:"Distribution,omitempty"`
	ETag         aws.StringValue `xml:"-"`
}

func (v *UpdateDistributionResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *UpdateDistributionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateStreamingDistributionRequest is undocumented.
type UpdateStreamingDistributionRequest struct {
	XMLName xml.Name `xml:""`

	ID                          aws.StringValue              `xml:"-"`
	IfMatch                     aws.StringValue              `xml:"-"`
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig,omitempty"`
}

func (v *UpdateStreamingDistributionRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *UpdateStreamingDistributionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if err := model.ValidateRequired(v, "StreamingDistributionConfig"); err != nil {
		errors["StreamingDistributionConfig"] = append(errors["StreamingDistributionConfig"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateStreamingDistributionResult is undocumented.
type UpdateStreamingDistributionResult struct {
	XMLName xml.Name `xml:"UpdateStreamingDistributionResult"`

	ETag                  aws.StringValue        `xml:"-"`
	StreamingDistribution *StreamingDistribution `xml:"StreamingDistribution,omitempty"`
}

func (v *UpdateStreamingDistributionResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *UpdateStreamingDistributionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ViewerCertificate is undocumented.
type ViewerCertificate struct {
	XMLName xml.Name `xml:"ViewerCertificate"`

	CloudFrontDefaultCertificate aws.BooleanValue `xml:"CloudFrontDefaultCertificate"`
	IAMCertificateID             aws.StringValue  `xml:"IAMCertificateId"`
	MinimumProtocolVersion       aws.StringValue  `xml:"MinimumProtocolVersion"`
	SSLSupportMethod             aws.StringValue  `xml:"SSLSupportMethod"`
}

func (v *ViewerCertificate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return aws.MarshalXML(v, e, start)
}

func (v *ViewerCertificate) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	MinimumProtocolVersionEnum := []string{
		MinimumProtocolVersionSSLv3,
		MinimumProtocolVersionTLSv1,
	}
	if err := model.ValidateEnum(v, "MinimumProtocolVersion", MinimumProtocolVersionEnum); err != nil {
		errors["MinimumProtocolVersion"] = append(errors["MinimumProtocolVersion"], err)
	}

	SSLSupportMethodEnum := []string{
		SSLSupportMethodSNIOnly,
		SSLSupportMethodVIP,
	}
	if err := model.ValidateEnum(v, "SSLSupportMethod", SSLSupportMethodEnum); err != nil {
		errors["SSLSupportMethod"] = append(errors["SSLSupportMethod"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudFront.
const (
	ViewerProtocolPolicyAllowAll        = "allow-all"
	ViewerProtocolPolicyHTTPSOnly       = "https-only"
	ViewerProtocolPolicyRedirectToHTTPS = "redirect-to-https"
)

// avoid errors if the packages aren't referenced
var _ time.Time

var _ bytes.Reader
var _ url.URL
var _ fmt.Stringer
var _ strings.Reader
var _ strconv.NumError
var _ = ioutil.Discard
