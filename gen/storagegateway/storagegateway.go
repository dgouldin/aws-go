// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package storagegateway provides a client for AWS Storage Gateway.
package storagegateway

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

// StorageGateway is a client for AWS Storage Gateway.
type StorageGateway struct {
	client *aws.JSONClient
}

// New returns a new StorageGateway client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *StorageGateway {
	if client == nil {
		client = http.DefaultClient
	}

	service := "storagegateway"
	endpoint, service, region := endpoints.Lookup("storagegateway", region)

	return &StorageGateway{
		client: &aws.JSONClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			}, Client: client,
			Endpoint:     endpoint,
			JSONVersion:  "1.1",
			TargetPrefix: "StorageGateway_20130630",
		},
	}
}

// ActivateGateway this operation activates the gateway you previously
// deployed on your host. For more information, see Activate the AWS
// Storage Gateway . In the activation process, you specify information
// such as the region you want to use for storing snapshots, the time zone
// for scheduled snapshots the gateway snapshot schedule window, an
// activation key, and a name for your gateway. The activation process also
// associates your gateway with your account; for more information, see
// UpdateGatewayInformation
func (c *StorageGateway) ActivateGateway(req *ActivateGatewayInput) (resp *ActivateGatewayOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ActivateGatewayOutput{}
	err = c.client.Do("ActivateGateway", "POST", "/", req, resp)
	return
}

// AddCache this operation configures one or more gateway local disks as
// cache for a cached-volume gateway. This operation is supported only for
// the gateway-cached volume architecture (see Storage Gateway Concepts In
// the request, you specify the gateway Amazon Resource Name to which you
// want to add cache, and one or more disk IDs that you want to configure
// as cache.
func (c *StorageGateway) AddCache(req *AddCacheInput) (resp *AddCacheOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AddCacheOutput{}
	err = c.client.Do("AddCache", "POST", "/", req, resp)
	return
}

// AddUploadBuffer this operation configures one or more gateway local
// disks as upload buffer for a specified gateway. This operation is
// supported for both the gateway-stored and gateway-cached volume
// architectures. In the request, you specify the gateway Amazon Resource
// Name to which you want to add upload buffer, and one or more disk IDs
// that you want to configure as upload buffer.
func (c *StorageGateway) AddUploadBuffer(req *AddUploadBufferInput) (resp *AddUploadBufferOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AddUploadBufferOutput{}
	err = c.client.Do("AddUploadBuffer", "POST", "/", req, resp)
	return
}

// AddWorkingStorage this operation configures one or more gateway local
// disks as working storage for a gateway. This operation is supported only
// for the gateway-stored volume architecture. This operation is deprecated
// method in cached-volumes API version (20120630). Use AddUploadBuffer
// instead. In the request, you specify the gateway Amazon Resource Name to
// which you want to add working storage, and one or more disk IDs that you
// want to configure as working storage.
func (c *StorageGateway) AddWorkingStorage(req *AddWorkingStorageInput) (resp *AddWorkingStorageOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AddWorkingStorageOutput{}
	err = c.client.Do("AddWorkingStorage", "POST", "/", req, resp)
	return
}

// CancelArchival cancels archiving of a virtual tape to the virtual tape
// shelf after the archiving process is initiated.
func (c *StorageGateway) CancelArchival(req *CancelArchivalInput) (resp *CancelArchivalOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CancelArchivalOutput{}
	err = c.client.Do("CancelArchival", "POST", "/", req, resp)
	return
}

// CancelRetrieval cancels retrieval of a virtual tape from the virtual
// tape shelf to a gateway after the retrieval process is initiated. The
// virtual tape is returned to the
func (c *StorageGateway) CancelRetrieval(req *CancelRetrievalInput) (resp *CancelRetrievalOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CancelRetrievalOutput{}
	err = c.client.Do("CancelRetrieval", "POST", "/", req, resp)
	return
}

// CreateCachediSCSIVolume this operation creates a cached volume on a
// specified cached gateway. This operation is supported only for the
// gateway-cached volume architecture. In the request, you must specify the
// gateway, size of the volume in bytes, the iSCSI target name, an IP
// address on which to expose the target, and a unique client token. In
// response, AWS Storage Gateway creates the volume and returns information
// about it such as the volume Amazon Resource Name its size, and the iSCSI
// target ARN that initiators can use to connect to the volume target.
func (c *StorageGateway) CreateCachediSCSIVolume(req *CreateCachediSCSIVolumeInput) (resp *CreateCachediSCSIVolumeOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateCachediSCSIVolumeOutput{}
	err = c.client.Do("CreateCachediSCSIVolume", "POST", "/", req, resp)
	return
}

// CreateSnapshot this operation initiates a snapshot of a volume. AWS
// Storage Gateway provides the ability to back up point-in-time snapshots
// of your data to Amazon Simple Storage (S3) for durable off-site
// recovery, as well as import the data to an Amazon Elastic Block Store
// volume in Amazon Elastic Compute Cloud (EC2). You can take snapshots of
// your gateway volume on a scheduled or ad-hoc basis. This API enables you
// to take ad-hoc snapshot. For more information, see Working With
// Snapshots in the AWS Storage Gateway Console In the CreateSnapshot
// request you identify the volume by providing its Amazon Resource Name
// You must also provide description for the snapshot. When AWS Storage
// Gateway takes the snapshot of specified volume, the snapshot and
// description appears in the AWS Storage Gateway Console. In response, AWS
// Storage Gateway returns you a snapshot ID. You can use this snapshot ID
// to check the snapshot progress or later use it when you want to create a
// volume from a snapshot.
func (c *StorageGateway) CreateSnapshot(req *CreateSnapshotInput) (resp *CreateSnapshotOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateSnapshotOutput{}
	err = c.client.Do("CreateSnapshot", "POST", "/", req, resp)
	return
}

// CreateSnapshotFromVolumeRecoveryPoint this operation initiates a
// snapshot of a gateway from a volume recovery point. This operation is
// supported only for the gateway-cached volume architecture (see A volume
// recovery point is a point in time at which all data of the volume is
// consistent and from which you can create a snapshot. To get a list of
// volume recovery point for gateway-cached volumes, use
// ListVolumeRecoveryPoints In the CreateSnapshotFromVolumeRecoveryPoint
// request, you identify the volume by providing its Amazon Resource Name
// You must also provide a description for the snapshot. When AWS Storage
// Gateway takes a snapshot of the specified volume, the snapshot and its
// description appear in the AWS Storage Gateway console. In response, AWS
// Storage Gateway returns you a snapshot ID. You can use this snapshot ID
// to check the snapshot progress or later use it when you want to create a
// volume from a snapshot.
func (c *StorageGateway) CreateSnapshotFromVolumeRecoveryPoint(req *CreateSnapshotFromVolumeRecoveryPointInput) (resp *CreateSnapshotFromVolumeRecoveryPointOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateSnapshotFromVolumeRecoveryPointOutput{}
	err = c.client.Do("CreateSnapshotFromVolumeRecoveryPoint", "POST", "/", req, resp)
	return
}

// CreateStorediSCSIVolume this operation creates a volume on a specified
// gateway. This operation is supported only for the gateway-stored volume
// architecture. The size of the volume to create is inferred from the disk
// size. You can choose to preserve existing data on the disk, create
// volume from an existing snapshot, or create an empty volume. If you
// choose to create an empty gateway volume, then any existing data on the
// disk is erased. In the request you must specify the gateway and the disk
// information on which you are creating the volume. In response, AWS
// Storage Gateway creates the volume and returns volume information such
// as the volume Amazon Resource Name its size, and the iSCSI target ARN
// that initiators can use to connect to the volume target.
func (c *StorageGateway) CreateStorediSCSIVolume(req *CreateStorediSCSIVolumeInput) (resp *CreateStorediSCSIVolumeOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateStorediSCSIVolumeOutput{}
	err = c.client.Do("CreateStorediSCSIVolume", "POST", "/", req, resp)
	return
}

// CreateTapes creates one or more virtual tapes. You write data to the
// virtual tapes and then archive the tapes.
func (c *StorageGateway) CreateTapes(req *CreateTapesInput) (resp *CreateTapesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateTapesOutput{}
	err = c.client.Do("CreateTapes", "POST", "/", req, resp)
	return
}

// DeleteBandwidthRateLimit this operation deletes the bandwidth rate
// limits of a gateway. You can delete either the upload and download
// bandwidth rate limit, or you can delete both. If you delete only one of
// the limits, the other limit remains unchanged. To specify which gateway
// to work with, use the Amazon Resource Name of the gateway in your
// request.
func (c *StorageGateway) DeleteBandwidthRateLimit(req *DeleteBandwidthRateLimitInput) (resp *DeleteBandwidthRateLimitOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteBandwidthRateLimitOutput{}
	err = c.client.Do("DeleteBandwidthRateLimit", "POST", "/", req, resp)
	return
}

// DeleteChapCredentials this operation deletes Challenge-Handshake
// Authentication Protocol credentials for a specified iSCSI target and
// initiator pair.
func (c *StorageGateway) DeleteChapCredentials(req *DeleteChapCredentialsInput) (resp *DeleteChapCredentialsOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteChapCredentialsOutput{}
	err = c.client.Do("DeleteChapCredentials", "POST", "/", req, resp)
	return
}

// DeleteGateway this operation deletes a gateway. To specify which gateway
// to delete, use the Amazon Resource Name of the gateway in your request.
// The operation deletes the gateway; however, it does not delete the
// gateway virtual machine from your host computer. After you delete a
// gateway, you cannot reactivate it. Completed snapshots of the gateway
// volumes are not deleted upon deleting the gateway, however, pending
// snapshots will not complete. After you delete a gateway, your next step
// is to remove it from your environment. You no longer pay software
// charges after the gateway is deleted; however, your existing Amazon EBS
// snapshots persist and you will continue to be billed for these
// snapshots. You can choose to remove all remaining Amazon EBS snapshots
// by canceling your Amazon EC2 subscription. If you prefer not to cancel
// your Amazon EC2 subscription, you can delete your snapshots using the
// Amazon EC2 console. For more information, see the AWS Storage Gateway
// Detail Page .
func (c *StorageGateway) DeleteGateway(req *DeleteGatewayInput) (resp *DeleteGatewayOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteGatewayOutput{}
	err = c.client.Do("DeleteGateway", "POST", "/", req, resp)
	return
}

// DeleteSnapshotSchedule this operation deletes a snapshot of a volume.
// You can take snapshots of your gateway volumes on a scheduled or ad-hoc
// basis. This API enables you to delete a snapshot schedule for a volume.
// For more information, see Working with Snapshots . In the
// DeleteSnapshotSchedule request, you identify the volume by providing its
// Amazon Resource Name
func (c *StorageGateway) DeleteSnapshotSchedule(req *DeleteSnapshotScheduleInput) (resp *DeleteSnapshotScheduleOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteSnapshotScheduleOutput{}
	err = c.client.Do("DeleteSnapshotSchedule", "POST", "/", req, resp)
	return
}

// DeleteTape is undocumented.
func (c *StorageGateway) DeleteTape(req *DeleteTapeInput) (resp *DeleteTapeOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteTapeOutput{}
	err = c.client.Do("DeleteTape", "POST", "/", req, resp)
	return
}

// DeleteTapeArchive deletes the specified virtual tape from the virtual
// tape shelf
func (c *StorageGateway) DeleteTapeArchive(req *DeleteTapeArchiveInput) (resp *DeleteTapeArchiveOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteTapeArchiveOutput{}
	err = c.client.Do("DeleteTapeArchive", "POST", "/", req, resp)
	return
}

// DeleteVolume this operation delete the specified gateway volume that you
// previously created using the CreateStorediSCSIVolume For gateway-stored
// volumes, the local disk that was configured as the storage volume is not
// deleted. You can reuse the local disk to create another storage volume.
// Before you delete a gateway volume, make sure there are no iSCSI
// connections to the volume you are deleting. You should also make sure
// there is no snapshot in progress. You can use the Amazon Elastic Compute
// Cloud (Amazon EC2) API to query snapshots on the volume you are deleting
// and check the snapshot status. For more information, go to
// DescribeSnapshots in the Amazon Elastic Compute Cloud API Reference In
// the request, you must provide the Amazon Resource Name of the storage
// volume you want to delete.
func (c *StorageGateway) DeleteVolume(req *DeleteVolumeInput) (resp *DeleteVolumeOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteVolumeOutput{}
	err = c.client.Do("DeleteVolume", "POST", "/", req, resp)
	return
}

// DescribeBandwidthRateLimit this operation returns the bandwidth rate
// limits of a gateway. By default, these limits are not set, which means
// no bandwidth rate limiting is in effect. This operation only returns a
// value for a bandwidth rate limit only if the limit is set. If no limits
// are set for the gateway, then this operation returns only the gateway
// ARN in the response body. To specify which gateway to describe, use the
// Amazon Resource Name of the gateway in your request.
func (c *StorageGateway) DescribeBandwidthRateLimit(req *DescribeBandwidthRateLimitInput) (resp *DescribeBandwidthRateLimitOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeBandwidthRateLimitOutput{}
	err = c.client.Do("DescribeBandwidthRateLimit", "POST", "/", req, resp)
	return
}

// DescribeCache this operation returns information about the cache of a
// gateway. This operation is supported only for the gateway-cached volume
// architecture. The response includes disk IDs that are configured as
// cache, and it includes the amount of cache allocated and used.
func (c *StorageGateway) DescribeCache(req *DescribeCacheInput) (resp *DescribeCacheOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeCacheOutput{}
	err = c.client.Do("DescribeCache", "POST", "/", req, resp)
	return
}

// DescribeCachediSCSIVolumes this operation returns a description of the
// gateway volumes specified in the request. This operation is supported
// only for the gateway-cached volume architecture. The list of gateway
// volumes in the request must be from one gateway. In the response Amazon
// Storage Gateway returns volume information sorted by volume Amazon
// Resource Name
func (c *StorageGateway) DescribeCachediSCSIVolumes(req *DescribeCachediSCSIVolumesInput) (resp *DescribeCachediSCSIVolumesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeCachediSCSIVolumesOutput{}
	err = c.client.Do("DescribeCachediSCSIVolumes", "POST", "/", req, resp)
	return
}

// DescribeChapCredentials this operation returns an array of
// Challenge-Handshake Authentication Protocol credentials information for
// a specified iSCSI target, one for each target-initiator pair.
func (c *StorageGateway) DescribeChapCredentials(req *DescribeChapCredentialsInput) (resp *DescribeChapCredentialsOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeChapCredentialsOutput{}
	err = c.client.Do("DescribeChapCredentials", "POST", "/", req, resp)
	return
}

// DescribeGatewayInformation this operation returns metadata about a
// gateway such as its name, network interfaces, configured time zone, and
// the state (whether the gateway is running or not). To specify which
// gateway to describe, use the Amazon Resource Name of the gateway in your
// request.
func (c *StorageGateway) DescribeGatewayInformation(req *DescribeGatewayInformationInput) (resp *DescribeGatewayInformationOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeGatewayInformationOutput{}
	err = c.client.Do("DescribeGatewayInformation", "POST", "/", req, resp)
	return
}

// DescribeMaintenanceStartTime this operation returns your gateway's
// weekly maintenance start time including the day and time of the week.
// Note that values are in terms of the gateway's time zone.
func (c *StorageGateway) DescribeMaintenanceStartTime(req *DescribeMaintenanceStartTimeInput) (resp *DescribeMaintenanceStartTimeOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeMaintenanceStartTimeOutput{}
	err = c.client.Do("DescribeMaintenanceStartTime", "POST", "/", req, resp)
	return
}

// DescribeSnapshotSchedule this operation describes the snapshot schedule
// for the specified gateway volume. The snapshot schedule information
// includes intervals at which snapshots are automatically initiated on the
// volume.
func (c *StorageGateway) DescribeSnapshotSchedule(req *DescribeSnapshotScheduleInput) (resp *DescribeSnapshotScheduleOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSnapshotScheduleOutput{}
	err = c.client.Do("DescribeSnapshotSchedule", "POST", "/", req, resp)
	return
}

// DescribeStorediSCSIVolumes this operation returns description of the
// gateway volumes specified in the request. The list of gateway volumes in
// the request must be from one gateway. In the response Amazon Storage
// Gateway returns volume information sorted by volume ARNs.
func (c *StorageGateway) DescribeStorediSCSIVolumes(req *DescribeStorediSCSIVolumesInput) (resp *DescribeStorediSCSIVolumesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeStorediSCSIVolumesOutput{}
	err = c.client.Do("DescribeStorediSCSIVolumes", "POST", "/", req, resp)
	return
}

// DescribeTapeArchives returns a description of specified virtual tapes in
// the virtual tape shelf If a specific TapeARN is not specified, AWS
// Storage Gateway returns a description of all virtual tapes found in the
// VTS associated with your account.
func (c *StorageGateway) DescribeTapeArchives(req *DescribeTapeArchivesInput) (resp *DescribeTapeArchivesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeTapeArchivesOutput{}
	err = c.client.Do("DescribeTapeArchives", "POST", "/", req, resp)
	return
}

// DescribeTapeRecoveryPoints returns a list of virtual tape recovery
// points that are available for the specified gateway-VTL. A recovery
// point is a point in time view of a virtual tape at which all the data on
// the virtual tape is consistent. If your gateway crashes, virtual tapes
// that have recovery points can be recovered to a new gateway.
func (c *StorageGateway) DescribeTapeRecoveryPoints(req *DescribeTapeRecoveryPointsInput) (resp *DescribeTapeRecoveryPointsOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeTapeRecoveryPointsOutput{}
	err = c.client.Do("DescribeTapeRecoveryPoints", "POST", "/", req, resp)
	return
}

// DescribeTapes returns a description of the specified Amazon Resource
// Name of virtual tapes. If a TapeARN is not specified, returns a
// description of all virtual tapes associated with the specified gateway.
func (c *StorageGateway) DescribeTapes(req *DescribeTapesInput) (resp *DescribeTapesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeTapesOutput{}
	err = c.client.Do("DescribeTapes", "POST", "/", req, resp)
	return
}

// DescribeUploadBuffer this operation returns information about the upload
// buffer of a gateway. This operation is supported for both the
// gateway-stored and gateway-cached volume architectures. The response
// includes disk IDs that are configured as upload buffer space, and it
// includes the amount of upload buffer space allocated and used.
func (c *StorageGateway) DescribeUploadBuffer(req *DescribeUploadBufferInput) (resp *DescribeUploadBufferOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeUploadBufferOutput{}
	err = c.client.Do("DescribeUploadBuffer", "POST", "/", req, resp)
	return
}

// DescribeVTLDevices returns a description of virtual tape library devices
// for the specified gateway. In the response, AWS Storage Gateway returns
// VTL device information. The list of VTL devices must be from one
// gateway.
func (c *StorageGateway) DescribeVTLDevices(req *DescribeVTLDevicesInput) (resp *DescribeVTLDevicesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVTLDevicesOutput{}
	err = c.client.Do("DescribeVTLDevices", "POST", "/", req, resp)
	return
}

// DescribeWorkingStorage this operation returns information about the
// working storage of a gateway. This operation is supported only for the
// gateway-stored volume architecture. This operation is deprecated in
// cached-volumes API version (20120630). Use DescribeUploadBuffer instead.
// The response includes disk IDs that are configured as working storage,
// and it includes the amount of working storage allocated and used.
func (c *StorageGateway) DescribeWorkingStorage(req *DescribeWorkingStorageInput) (resp *DescribeWorkingStorageOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeWorkingStorageOutput{}
	err = c.client.Do("DescribeWorkingStorage", "POST", "/", req, resp)
	return
}

// DisableGateway disables a gateway when the gateway is no longer
// functioning. For example, if your gateway VM is damaged, you can disable
// the gateway so you can recover virtual tapes. Use this operation for a
// gateway-VTL that is not reachable or not functioning. Once a gateway is
// disabled it cannot be enabled.
func (c *StorageGateway) DisableGateway(req *DisableGatewayInput) (resp *DisableGatewayOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DisableGatewayOutput{}
	err = c.client.Do("DisableGateway", "POST", "/", req, resp)
	return
}

// ListGateways this operation lists gateways owned by an AWS account in a
// region specified in the request. The returned list is ordered by gateway
// Amazon Resource Name By default, the operation returns a maximum of 100
// gateways. This operation supports pagination that allows you to
// optionally reduce the number of gateways returned in a response. If you
// have more gateways than are returned in a response-that is, the response
// returns only a truncated list of your gateways-the response contains a
// marker that you can specify in your next request to fetch the next page
// of gateways.
func (c *StorageGateway) ListGateways(req *ListGatewaysInput) (resp *ListGatewaysOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListGatewaysOutput{}
	err = c.client.Do("ListGateways", "POST", "/", req, resp)
	return
}

// ListLocalDisks this operation returns a list of the local disks of a
// gateway. To specify which gateway to describe you use the Amazon
// Resource Name of the gateway in the body of the request. The request
// returns all disks, specifying which are configured as working storage,
// stored volume or not configured at all.
func (c *StorageGateway) ListLocalDisks(req *ListLocalDisksInput) (resp *ListLocalDisksOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListLocalDisksOutput{}
	err = c.client.Do("ListLocalDisks", "POST", "/", req, resp)
	return
}

// ListVolumeRecoveryPoints this operation lists the recovery points for a
// specified gateway. This operation is supported only for the
// gateway-cached volume architecture. Each gateway-cached volume has one
// recovery point. A volume recovery point is a point in time at which all
// data of the volume is consistent and from which you can create a
// snapshot. To create a snapshot from a volume recovery point use the
// CreateSnapshotFromVolumeRecoveryPoint operation.
func (c *StorageGateway) ListVolumeRecoveryPoints(req *ListVolumeRecoveryPointsInput) (resp *ListVolumeRecoveryPointsOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListVolumeRecoveryPointsOutput{}
	err = c.client.Do("ListVolumeRecoveryPoints", "POST", "/", req, resp)
	return
}

// ListVolumes this operation lists the iSCSI stored volumes of a gateway.
// Results are sorted by volume The response includes only the volume ARNs.
// If you want additional volume information, use the
// DescribeStorediSCSIVolumes The operation supports pagination. By
// default, the operation returns a maximum of up to 100 volumes. You can
// optionally specify the Limit field in the body to limit the number of
// volumes in the response. If the number of volumes returned in the
// response is truncated, the response includes a Marker field. You can use
// this Marker value in your subsequent request to retrieve the next set of
// volumes.
func (c *StorageGateway) ListVolumes(req *ListVolumesInput) (resp *ListVolumesOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListVolumesOutput{}
	err = c.client.Do("ListVolumes", "POST", "/", req, resp)
	return
}

// RetrieveTapeArchive retrieves an archived virtual tape from the virtual
// tape shelf to a gateway-VTL. Virtual tapes archived in the VTS are not
// associated with any gateway. However after a tape is retrieved, it is
// associated with a gateway, even though it is also listed in the Once a
// tape is successfully retrieved to a gateway, it cannot be retrieved
// again to another gateway. You must archive the tape again before you can
// retrieve it to another gateway.
func (c *StorageGateway) RetrieveTapeArchive(req *RetrieveTapeArchiveInput) (resp *RetrieveTapeArchiveOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RetrieveTapeArchiveOutput{}
	err = c.client.Do("RetrieveTapeArchive", "POST", "/", req, resp)
	return
}

// RetrieveTapeRecoveryPoint retrieves the recovery point for the specified
// virtual tape. A recovery point is a point in time view of a virtual tape
// at which all the data on the tape is consistent. If your gateway
// crashes, virtual tapes that have recovery points can be recovered to a
// new gateway.
func (c *StorageGateway) RetrieveTapeRecoveryPoint(req *RetrieveTapeRecoveryPointInput) (resp *RetrieveTapeRecoveryPointOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RetrieveTapeRecoveryPointOutput{}
	err = c.client.Do("RetrieveTapeRecoveryPoint", "POST", "/", req, resp)
	return
}

// ShutdownGateway this operation shuts down a gateway. To specify which
// gateway to shut down, use the Amazon Resource Name of the gateway in the
// body of your request. The operation shuts down the gateway service
// component running in the storage gateway's virtual machine and not the
// After the gateway is shutdown, you cannot call any other API except
// StartGateway , DescribeGatewayInformation , and ListGateways . For more
// information, see ActivateGateway . Your applications cannot read from or
// write to the gateway's storage volumes, and there are no snapshots
// taken. If do not intend to use the gateway again, you must delete the
// gateway (using DeleteGateway ) to no longer pay software charges
// associated with the gateway.
func (c *StorageGateway) ShutdownGateway(req *ShutdownGatewayInput) (resp *ShutdownGatewayOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ShutdownGatewayOutput{}
	err = c.client.Do("ShutdownGateway", "POST", "/", req, resp)
	return
}

// StartGateway this operation starts a gateway that you previously shut
// down (see ShutdownGateway ). After the gateway starts, you can then make
// other API calls, your applications can read from or write to the
// gateway's storage volumes and you will be able to take snapshot backups.
// To specify which gateway to start, use the Amazon Resource Name of the
// gateway in your request.
func (c *StorageGateway) StartGateway(req *StartGatewayInput) (resp *StartGatewayOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &StartGatewayOutput{}
	err = c.client.Do("StartGateway", "POST", "/", req, resp)
	return
}

// UpdateBandwidthRateLimit this operation updates the bandwidth rate
// limits of a gateway. You can update both the upload and download
// bandwidth rate limit or specify only one of the two. If you don't set a
// bandwidth rate limit, the existing rate limit remains. By default, a
// gateway's bandwidth rate limits are not set. If you don't set any limit,
// the gateway does not have any limitations on its bandwidth usage and
// could potentially use the maximum available bandwidth. To specify which
// gateway to update, use the Amazon Resource Name of the gateway in your
// request.
func (c *StorageGateway) UpdateBandwidthRateLimit(req *UpdateBandwidthRateLimitInput) (resp *UpdateBandwidthRateLimitOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateBandwidthRateLimitOutput{}
	err = c.client.Do("UpdateBandwidthRateLimit", "POST", "/", req, resp)
	return
}

// UpdateChapCredentials this operation updates the Challenge-Handshake
// Authentication Protocol credentials for a specified iSCSI target. By
// default, a gateway does not have enabled; however, for added security,
// you might use it. When you update credentials, all existing connections
// on the target are closed and initiators must reconnect with the new
// credentials.
func (c *StorageGateway) UpdateChapCredentials(req *UpdateChapCredentialsInput) (resp *UpdateChapCredentialsOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateChapCredentialsOutput{}
	err = c.client.Do("UpdateChapCredentials", "POST", "/", req, resp)
	return
}

// UpdateGatewayInformation this operation updates a gateway's metadata,
// which includes the gateway's name and time zone. To specify which
// gateway to update, use the Amazon Resource Name of the gateway in your
// request.
func (c *StorageGateway) UpdateGatewayInformation(req *UpdateGatewayInformationInput) (resp *UpdateGatewayInformationOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateGatewayInformationOutput{}
	err = c.client.Do("UpdateGatewayInformation", "POST", "/", req, resp)
	return
}

// UpdateGatewaySoftwareNow this operation updates the gateway virtual
// machine software. The request immediately triggers the software update.
// A software update forces a system restart of your gateway. You can
// minimize the chance of any disruption to your applications by increasing
// your iSCSI Initiators' timeouts. For more information about increasing
// iSCSI Initiator timeouts for Windows and Linux, see Customizing Your
// Windows iSCSI Settings and Customizing Your Linux iSCSI Settings ,
// respectively.
func (c *StorageGateway) UpdateGatewaySoftwareNow(req *UpdateGatewaySoftwareNowInput) (resp *UpdateGatewaySoftwareNowOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateGatewaySoftwareNowOutput{}
	err = c.client.Do("UpdateGatewaySoftwareNow", "POST", "/", req, resp)
	return
}

// UpdateMaintenanceStartTime this operation updates a gateway's weekly
// maintenance start time information, including day and time of the week.
// The maintenance time is the time in your gateway's time zone.
func (c *StorageGateway) UpdateMaintenanceStartTime(req *UpdateMaintenanceStartTimeInput) (resp *UpdateMaintenanceStartTimeOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateMaintenanceStartTimeOutput{}
	err = c.client.Do("UpdateMaintenanceStartTime", "POST", "/", req, resp)
	return
}

// UpdateSnapshotSchedule this operation updates a snapshot schedule
// configured for a gateway volume. The default snapshot schedule for
// volume is once every 24 hours, starting at the creation time of the
// volume. You can use this API to change the snapshot schedule configured
// for the volume. In the request you must identify the gateway volume
// whose snapshot schedule you want to update, and the schedule
// information, including when you want the snapshot to begin on a day and
// the frequency (in hours) of snapshots.
func (c *StorageGateway) UpdateSnapshotSchedule(req *UpdateSnapshotScheduleInput) (resp *UpdateSnapshotScheduleOutput, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateSnapshotScheduleOutput{}
	err = c.client.Do("UpdateSnapshotSchedule", "POST", "/", req, resp)
	return
}

// ActivateGatewayInput is undocumented.
type ActivateGatewayInput struct {
	ActivationKey     aws.StringValue `json:"ActivationKey"`
	GatewayName       aws.StringValue `json:"GatewayName"`
	GatewayRegion     aws.StringValue `json:"GatewayRegion"`
	GatewayTimezone   aws.StringValue `json:"GatewayTimezone"`
	GatewayType       aws.StringValue `json:"GatewayType,omitempty"`
	MediumChangerType aws.StringValue `json:"MediumChangerType,omitempty"`
	TapeDriveType     aws.StringValue `json:"TapeDriveType,omitempty"`
}

func (v *ActivateGatewayInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivationKey"); err != nil {
		errors["ActivationKey"] = append(errors["ActivationKey"], err)
	}

	if err := model.ValidateMin(v, "ActivationKey", 1); err != nil {
		errors["ActivationKey"] = append(errors["ActivationKey"], err)
	}

	if err := model.ValidateMax(v, "ActivationKey", 50); err != nil {
		errors["ActivationKey"] = append(errors["ActivationKey"], err)
	}

	if err := model.ValidateRequired(v, "GatewayName"); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidateMin(v, "GatewayName", 2); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidateMax(v, "GatewayName", 255); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidatePattern(v, "GatewayName", `^[ -\.0-\[\]-~]*[!-\.0-\[\]-~][ -\.0-\[\]-~]*$`); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidateRequired(v, "GatewayRegion"); err != nil {
		errors["GatewayRegion"] = append(errors["GatewayRegion"], err)
	}

	if err := model.ValidateMin(v, "GatewayRegion", 1); err != nil {
		errors["GatewayRegion"] = append(errors["GatewayRegion"], err)
	}

	if err := model.ValidateMax(v, "GatewayRegion", 25); err != nil {
		errors["GatewayRegion"] = append(errors["GatewayRegion"], err)
	}

	if err := model.ValidateRequired(v, "GatewayTimezone"); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if err := model.ValidateMin(v, "GatewayTimezone", 3); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if err := model.ValidateMax(v, "GatewayTimezone", 10); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if err := model.ValidateMin(v, "GatewayType", 2); err != nil {
		errors["GatewayType"] = append(errors["GatewayType"], err)
	}

	if err := model.ValidateMax(v, "GatewayType", 20); err != nil {
		errors["GatewayType"] = append(errors["GatewayType"], err)
	}

	if err := model.ValidateMin(v, "MediumChangerType", 2); err != nil {
		errors["MediumChangerType"] = append(errors["MediumChangerType"], err)
	}

	if err := model.ValidateMax(v, "MediumChangerType", 50); err != nil {
		errors["MediumChangerType"] = append(errors["MediumChangerType"], err)
	}

	if err := model.ValidateMin(v, "TapeDriveType", 2); err != nil {
		errors["TapeDriveType"] = append(errors["TapeDriveType"], err)
	}

	if err := model.ValidateMax(v, "TapeDriveType", 50); err != nil {
		errors["TapeDriveType"] = append(errors["TapeDriveType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivateGatewayOutput is undocumented.
type ActivateGatewayOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *ActivateGatewayOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddCacheInput is undocumented.
type AddCacheInput struct {
	DiskIDs    []string        `json:"DiskIds"`
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *AddCacheInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DiskIDs"); err != nil {
		errors["DiskIDs"] = append(errors["DiskIDs"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddCacheOutput is undocumented.
type AddCacheOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *AddCacheOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddUploadBufferInput is undocumented.
type AddUploadBufferInput struct {
	DiskIDs    []string        `json:"DiskIds"`
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *AddUploadBufferInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DiskIDs"); err != nil {
		errors["DiskIDs"] = append(errors["DiskIDs"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddUploadBufferOutput is undocumented.
type AddUploadBufferOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *AddUploadBufferOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddWorkingStorageInput is undocumented.
type AddWorkingStorageInput struct {
	DiskIDs    []string        `json:"DiskIds"`
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *AddWorkingStorageInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DiskIDs"); err != nil {
		errors["DiskIDs"] = append(errors["DiskIDs"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddWorkingStorageOutput is undocumented.
type AddWorkingStorageOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *AddWorkingStorageOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CachediSCSIVolume is undocumented.
type CachediSCSIVolume struct {
	SourceSnapshotID      aws.StringValue        `json:"SourceSnapshotId,omitempty"`
	VolumeARN             aws.StringValue        `json:"VolumeARN,omitempty"`
	VolumeID              aws.StringValue        `json:"VolumeId,omitempty"`
	VolumeProgress        aws.DoubleValue        `json:"VolumeProgress,omitempty"`
	VolumeSizeInBytes     aws.LongValue          `json:"VolumeSizeInBytes,omitempty"`
	VolumeStatus          aws.StringValue        `json:"VolumeStatus,omitempty"`
	VolumeType            aws.StringValue        `json:"VolumeType,omitempty"`
	VolumeiSCSIAttributes *VolumeiSCSIAttributes `json:"VolumeiSCSIAttributes,omitempty"`
}

func (v *CachediSCSIVolume) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "SourceSnapshotID", `\Asnap-[0-9a-fA-F]{8}\z`); err != nil {
		errors["SourceSnapshotID"] = append(errors["SourceSnapshotID"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeID", 12); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if err := model.ValidateMax(v, "VolumeID", 30); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if err := model.ValidateMin(v, "VolumeStatus", 3); err != nil {
		errors["VolumeStatus"] = append(errors["VolumeStatus"], err)
	}

	if err := model.ValidateMax(v, "VolumeStatus", 50); err != nil {
		errors["VolumeStatus"] = append(errors["VolumeStatus"], err)
	}

	if err := model.ValidateMin(v, "VolumeType", 3); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if err := model.ValidateMax(v, "VolumeType", 100); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelArchivalInput is undocumented.
type CancelArchivalInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
	TapeARN    aws.StringValue `json:"TapeARN"`
}

func (v *CancelArchivalInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "TapeARN"); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelArchivalOutput is undocumented.
type CancelArchivalOutput struct {
	TapeARN aws.StringValue `json:"TapeARN,omitempty"`
}

func (v *CancelArchivalOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelRetrievalInput is undocumented.
type CancelRetrievalInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
	TapeARN    aws.StringValue `json:"TapeARN"`
}

func (v *CancelRetrievalInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "TapeARN"); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelRetrievalOutput is undocumented.
type CancelRetrievalOutput struct {
	TapeARN aws.StringValue `json:"TapeARN,omitempty"`
}

func (v *CancelRetrievalOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChapInfo is undocumented.
type ChapInfo struct {
	InitiatorName                 aws.StringValue `json:"InitiatorName,omitempty"`
	SecretToAuthenticateInitiator aws.StringValue `json:"SecretToAuthenticateInitiator,omitempty"`
	SecretToAuthenticateTarget    aws.StringValue `json:"SecretToAuthenticateTarget,omitempty"`
	TargetARN                     aws.StringValue `json:"TargetARN,omitempty"`
}

func (v *ChapInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "InitiatorName", 1); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMax(v, "InitiatorName", 255); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidatePattern(v, "InitiatorName", `[0-9a-z:.-]+`); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMin(v, "SecretToAuthenticateInitiator", 12); err != nil {
		errors["SecretToAuthenticateInitiator"] = append(errors["SecretToAuthenticateInitiator"], err)
	}

	if err := model.ValidateMax(v, "SecretToAuthenticateInitiator", 16); err != nil {
		errors["SecretToAuthenticateInitiator"] = append(errors["SecretToAuthenticateInitiator"], err)
	}

	if err := model.ValidateMin(v, "SecretToAuthenticateTarget", 12); err != nil {
		errors["SecretToAuthenticateTarget"] = append(errors["SecretToAuthenticateTarget"], err)
	}

	if err := model.ValidateMax(v, "SecretToAuthenticateTarget", 16); err != nil {
		errors["SecretToAuthenticateTarget"] = append(errors["SecretToAuthenticateTarget"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateCachediSCSIVolumeInput is undocumented.
type CreateCachediSCSIVolumeInput struct {
	ClientToken        aws.StringValue `json:"ClientToken"`
	GatewayARN         aws.StringValue `json:"GatewayARN"`
	NetworkInterfaceID aws.StringValue `json:"NetworkInterfaceId"`
	SnapshotID         aws.StringValue `json:"SnapshotId,omitempty"`
	TargetName         aws.StringValue `json:"TargetName"`
	VolumeSizeInBytes  aws.LongValue   `json:"VolumeSizeInBytes"`
}

func (v *CreateCachediSCSIVolumeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClientToken"); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateMin(v, "ClientToken", 5); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateMax(v, "ClientToken", 100); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidatePattern(v, "NetworkInterfaceID", `\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z`); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidatePattern(v, "SnapshotID", `\Asnap-[0-9a-fA-F]{8}\z`); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if err := model.ValidateRequired(v, "TargetName"); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidateMin(v, "TargetName", 1); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidateMax(v, "TargetName", 200); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidatePattern(v, "TargetName", `^[-\.;a-z0-9]+$`); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidateRequired(v, "VolumeSizeInBytes"); err != nil {
		errors["VolumeSizeInBytes"] = append(errors["VolumeSizeInBytes"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateCachediSCSIVolumeOutput is undocumented.
type CreateCachediSCSIVolumeOutput struct {
	TargetARN aws.StringValue `json:"TargetARN,omitempty"`
	VolumeARN aws.StringValue `json:"VolumeARN,omitempty"`
}

func (v *CreateCachediSCSIVolumeOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSnapshotFromVolumeRecoveryPointInput is undocumented.
type CreateSnapshotFromVolumeRecoveryPointInput struct {
	SnapshotDescription aws.StringValue `json:"SnapshotDescription"`
	VolumeARN           aws.StringValue `json:"VolumeARN"`
}

func (v *CreateSnapshotFromVolumeRecoveryPointInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SnapshotDescription"); err != nil {
		errors["SnapshotDescription"] = append(errors["SnapshotDescription"], err)
	}

	if err := model.ValidateMin(v, "SnapshotDescription", 1); err != nil {
		errors["SnapshotDescription"] = append(errors["SnapshotDescription"], err)
	}

	if err := model.ValidateMax(v, "SnapshotDescription", 255); err != nil {
		errors["SnapshotDescription"] = append(errors["SnapshotDescription"], err)
	}

	if err := model.ValidateRequired(v, "VolumeARN"); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSnapshotFromVolumeRecoveryPointOutput is undocumented.
type CreateSnapshotFromVolumeRecoveryPointOutput struct {
	SnapshotID              aws.StringValue `json:"SnapshotId,omitempty"`
	VolumeARN               aws.StringValue `json:"VolumeARN,omitempty"`
	VolumeRecoveryPointTime aws.StringValue `json:"VolumeRecoveryPointTime,omitempty"`
}

func (v *CreateSnapshotFromVolumeRecoveryPointOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "SnapshotID", `\Asnap-[0-9a-fA-F]{8}\z`); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSnapshotInput is undocumented.
type CreateSnapshotInput struct {
	SnapshotDescription aws.StringValue `json:"SnapshotDescription"`
	VolumeARN           aws.StringValue `json:"VolumeARN"`
}

func (v *CreateSnapshotInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SnapshotDescription"); err != nil {
		errors["SnapshotDescription"] = append(errors["SnapshotDescription"], err)
	}

	if err := model.ValidateMin(v, "SnapshotDescription", 1); err != nil {
		errors["SnapshotDescription"] = append(errors["SnapshotDescription"], err)
	}

	if err := model.ValidateMax(v, "SnapshotDescription", 255); err != nil {
		errors["SnapshotDescription"] = append(errors["SnapshotDescription"], err)
	}

	if err := model.ValidateRequired(v, "VolumeARN"); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSnapshotOutput is undocumented.
type CreateSnapshotOutput struct {
	SnapshotID aws.StringValue `json:"SnapshotId,omitempty"`
	VolumeARN  aws.StringValue `json:"VolumeARN,omitempty"`
}

func (v *CreateSnapshotOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "SnapshotID", `\Asnap-[0-9a-fA-F]{8}\z`); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateStorediSCSIVolumeInput is undocumented.
type CreateStorediSCSIVolumeInput struct {
	DiskID               aws.StringValue  `json:"DiskId"`
	GatewayARN           aws.StringValue  `json:"GatewayARN"`
	NetworkInterfaceID   aws.StringValue  `json:"NetworkInterfaceId"`
	PreserveExistingData aws.BooleanValue `json:"PreserveExistingData"`
	SnapshotID           aws.StringValue  `json:"SnapshotId,omitempty"`
	TargetName           aws.StringValue  `json:"TargetName"`
}

func (v *CreateStorediSCSIVolumeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DiskID"); err != nil {
		errors["DiskID"] = append(errors["DiskID"], err)
	}

	if err := model.ValidateMin(v, "DiskID", 1); err != nil {
		errors["DiskID"] = append(errors["DiskID"], err)
	}

	if err := model.ValidateMax(v, "DiskID", 300); err != nil {
		errors["DiskID"] = append(errors["DiskID"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidatePattern(v, "NetworkInterfaceID", `\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z`); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidateRequired(v, "PreserveExistingData"); err != nil {
		errors["PreserveExistingData"] = append(errors["PreserveExistingData"], err)
	}

	if err := model.ValidatePattern(v, "SnapshotID", `\Asnap-[0-9a-fA-F]{8}\z`); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if err := model.ValidateRequired(v, "TargetName"); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidateMin(v, "TargetName", 1); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidateMax(v, "TargetName", 200); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if err := model.ValidatePattern(v, "TargetName", `^[-\.;a-z0-9]+$`); err != nil {
		errors["TargetName"] = append(errors["TargetName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateStorediSCSIVolumeOutput is undocumented.
type CreateStorediSCSIVolumeOutput struct {
	TargetARN         aws.StringValue `json:"TargetARN,omitempty"`
	VolumeARN         aws.StringValue `json:"VolumeARN,omitempty"`
	VolumeSizeInBytes aws.LongValue   `json:"VolumeSizeInBytes,omitempty"`
}

func (v *CreateStorediSCSIVolumeOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateTapesInput is undocumented.
type CreateTapesInput struct {
	ClientToken       aws.StringValue  `json:"ClientToken"`
	GatewayARN        aws.StringValue  `json:"GatewayARN"`
	NumTapesToCreate  aws.IntegerValue `json:"NumTapesToCreate"`
	TapeBarcodePrefix aws.StringValue  `json:"TapeBarcodePrefix"`
	TapeSizeInBytes   aws.LongValue    `json:"TapeSizeInBytes"`
}

func (v *CreateTapesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClientToken"); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateMin(v, "ClientToken", 5); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateMax(v, "ClientToken", 100); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "NumTapesToCreate"); err != nil {
		errors["NumTapesToCreate"] = append(errors["NumTapesToCreate"], err)
	}

	if err := model.ValidateMin(v, "NumTapesToCreate", 1); err != nil {
		errors["NumTapesToCreate"] = append(errors["NumTapesToCreate"], err)
	}

	if err := model.ValidateMax(v, "NumTapesToCreate", 10); err != nil {
		errors["NumTapesToCreate"] = append(errors["NumTapesToCreate"], err)
	}

	if err := model.ValidateRequired(v, "TapeBarcodePrefix"); err != nil {
		errors["TapeBarcodePrefix"] = append(errors["TapeBarcodePrefix"], err)
	}

	if err := model.ValidateMin(v, "TapeBarcodePrefix", 1); err != nil {
		errors["TapeBarcodePrefix"] = append(errors["TapeBarcodePrefix"], err)
	}

	if err := model.ValidateMax(v, "TapeBarcodePrefix", 4); err != nil {
		errors["TapeBarcodePrefix"] = append(errors["TapeBarcodePrefix"], err)
	}

	if err := model.ValidatePattern(v, "TapeBarcodePrefix", `^[A-Z]*$`); err != nil {
		errors["TapeBarcodePrefix"] = append(errors["TapeBarcodePrefix"], err)
	}

	if err := model.ValidateRequired(v, "TapeSizeInBytes"); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if err := model.ValidateMin(v, "TapeSizeInBytes", 107374182400); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if err := model.ValidateMax(v, "TapeSizeInBytes", 2748779069440); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateTapesOutput is undocumented.
type CreateTapesOutput struct {
	TapeARNs []string `json:"TapeARNs,omitempty"`
}

func (v *CreateTapesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteBandwidthRateLimitInput is undocumented.
type DeleteBandwidthRateLimitInput struct {
	BandwidthType aws.StringValue `json:"BandwidthType"`
	GatewayARN    aws.StringValue `json:"GatewayARN"`
}

func (v *DeleteBandwidthRateLimitInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "BandwidthType"); err != nil {
		errors["BandwidthType"] = append(errors["BandwidthType"], err)
	}

	if err := model.ValidateMin(v, "BandwidthType", 3); err != nil {
		errors["BandwidthType"] = append(errors["BandwidthType"], err)
	}

	if err := model.ValidateMax(v, "BandwidthType", 25); err != nil {
		errors["BandwidthType"] = append(errors["BandwidthType"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteBandwidthRateLimitOutput is undocumented.
type DeleteBandwidthRateLimitOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *DeleteBandwidthRateLimitOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteChapCredentialsInput is undocumented.
type DeleteChapCredentialsInput struct {
	InitiatorName aws.StringValue `json:"InitiatorName"`
	TargetARN     aws.StringValue `json:"TargetARN"`
}

func (v *DeleteChapCredentialsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatorName"); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMin(v, "InitiatorName", 1); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMax(v, "InitiatorName", 255); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidatePattern(v, "InitiatorName", `[0-9a-z:.-]+`); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateRequired(v, "TargetARN"); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteChapCredentialsOutput is undocumented.
type DeleteChapCredentialsOutput struct {
	InitiatorName aws.StringValue `json:"InitiatorName,omitempty"`
	TargetARN     aws.StringValue `json:"TargetARN,omitempty"`
}

func (v *DeleteChapCredentialsOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "InitiatorName", 1); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMax(v, "InitiatorName", 255); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidatePattern(v, "InitiatorName", `[0-9a-z:.-]+`); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteGatewayInput is undocumented.
type DeleteGatewayInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DeleteGatewayInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteGatewayOutput is undocumented.
type DeleteGatewayOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *DeleteGatewayOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSnapshotScheduleInput is undocumented.
type DeleteSnapshotScheduleInput struct {
	VolumeARN aws.StringValue `json:"VolumeARN"`
}

func (v *DeleteSnapshotScheduleInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeARN"); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSnapshotScheduleOutput is undocumented.
type DeleteSnapshotScheduleOutput struct {
	VolumeARN aws.StringValue `json:"VolumeARN,omitempty"`
}

func (v *DeleteSnapshotScheduleOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteTapeArchiveInput is undocumented.
type DeleteTapeArchiveInput struct {
	TapeARN aws.StringValue `json:"TapeARN"`
}

func (v *DeleteTapeArchiveInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "TapeARN"); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteTapeArchiveOutput is undocumented.
type DeleteTapeArchiveOutput struct {
	TapeARN aws.StringValue `json:"TapeARN,omitempty"`
}

func (v *DeleteTapeArchiveOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteTapeInput is undocumented.
type DeleteTapeInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
	TapeARN    aws.StringValue `json:"TapeARN"`
}

func (v *DeleteTapeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "TapeARN"); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteTapeOutput is undocumented.
type DeleteTapeOutput struct {
	TapeARN aws.StringValue `json:"TapeARN,omitempty"`
}

func (v *DeleteTapeOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVolumeInput is undocumented.
type DeleteVolumeInput struct {
	VolumeARN aws.StringValue `json:"VolumeARN"`
}

func (v *DeleteVolumeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeARN"); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVolumeOutput is undocumented.
type DeleteVolumeOutput struct {
	VolumeARN aws.StringValue `json:"VolumeARN,omitempty"`
}

func (v *DeleteVolumeOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeBandwidthRateLimitInput is undocumented.
type DescribeBandwidthRateLimitInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DescribeBandwidthRateLimitInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeBandwidthRateLimitOutput is undocumented.
type DescribeBandwidthRateLimitOutput struct {
	AverageDownloadRateLimitInBitsPerSec aws.LongValue   `json:"AverageDownloadRateLimitInBitsPerSec,omitempty"`
	AverageUploadRateLimitInBitsPerSec   aws.LongValue   `json:"AverageUploadRateLimitInBitsPerSec,omitempty"`
	GatewayARN                           aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *DescribeBandwidthRateLimitOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "AverageDownloadRateLimitInBitsPerSec", 102400); err != nil {
		errors["AverageDownloadRateLimitInBitsPerSec"] = append(errors["AverageDownloadRateLimitInBitsPerSec"], err)
	}

	if err := model.ValidateMin(v, "AverageUploadRateLimitInBitsPerSec", 51200); err != nil {
		errors["AverageUploadRateLimitInBitsPerSec"] = append(errors["AverageUploadRateLimitInBitsPerSec"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeCacheInput is undocumented.
type DescribeCacheInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DescribeCacheInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeCacheOutput is undocumented.
type DescribeCacheOutput struct {
	CacheAllocatedInBytes aws.LongValue   `json:"CacheAllocatedInBytes,omitempty"`
	CacheDirtyPercentage  aws.DoubleValue `json:"CacheDirtyPercentage,omitempty"`
	CacheHitPercentage    aws.DoubleValue `json:"CacheHitPercentage,omitempty"`
	CacheMissPercentage   aws.DoubleValue `json:"CacheMissPercentage,omitempty"`
	CacheUsedPercentage   aws.DoubleValue `json:"CacheUsedPercentage,omitempty"`
	DiskIDs               []string        `json:"DiskIds,omitempty"`
	GatewayARN            aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *DescribeCacheOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeCachediSCSIVolumesInput is undocumented.
type DescribeCachediSCSIVolumesInput struct {
	VolumeARNs []string `json:"VolumeARNs"`
}

func (v *DescribeCachediSCSIVolumesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeARNs"); err != nil {
		errors["VolumeARNs"] = append(errors["VolumeARNs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeCachediSCSIVolumesOutput is undocumented.
type DescribeCachediSCSIVolumesOutput struct {
	CachediSCSIVolumes []CachediSCSIVolume `json:"CachediSCSIVolumes,omitempty"`
}

func (v *DescribeCachediSCSIVolumesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeChapCredentialsInput is undocumented.
type DescribeChapCredentialsInput struct {
	TargetARN aws.StringValue `json:"TargetARN"`
}

func (v *DescribeChapCredentialsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "TargetARN"); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeChapCredentialsOutput is undocumented.
type DescribeChapCredentialsOutput struct {
	ChapCredentials []ChapInfo `json:"ChapCredentials,omitempty"`
}

func (v *DescribeChapCredentialsOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeGatewayInformationInput is undocumented.
type DescribeGatewayInformationInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DescribeGatewayInformationInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeGatewayInformationOutput is undocumented.
type DescribeGatewayInformationOutput struct {
	GatewayARN                 aws.StringValue    `json:"GatewayARN,omitempty"`
	GatewayID                  aws.StringValue    `json:"GatewayId,omitempty"`
	GatewayNetworkInterfaces   []NetworkInterface `json:"GatewayNetworkInterfaces,omitempty"`
	GatewayState               aws.StringValue    `json:"GatewayState,omitempty"`
	GatewayTimezone            aws.StringValue    `json:"GatewayTimezone,omitempty"`
	GatewayType                aws.StringValue    `json:"GatewayType,omitempty"`
	NextUpdateAvailabilityDate aws.StringValue    `json:"NextUpdateAvailabilityDate,omitempty"`
}

func (v *DescribeGatewayInformationOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayID", 12); err != nil {
		errors["GatewayID"] = append(errors["GatewayID"], err)
	}

	if err := model.ValidateMax(v, "GatewayID", 30); err != nil {
		errors["GatewayID"] = append(errors["GatewayID"], err)
	}

	if err := model.ValidateMin(v, "GatewayState", 2); err != nil {
		errors["GatewayState"] = append(errors["GatewayState"], err)
	}

	if err := model.ValidateMax(v, "GatewayState", 25); err != nil {
		errors["GatewayState"] = append(errors["GatewayState"], err)
	}

	if err := model.ValidateMin(v, "GatewayTimezone", 3); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if err := model.ValidateMax(v, "GatewayTimezone", 10); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if err := model.ValidateMin(v, "GatewayType", 2); err != nil {
		errors["GatewayType"] = append(errors["GatewayType"], err)
	}

	if err := model.ValidateMax(v, "GatewayType", 20); err != nil {
		errors["GatewayType"] = append(errors["GatewayType"], err)
	}

	if err := model.ValidateMin(v, "NextUpdateAvailabilityDate", 1); err != nil {
		errors["NextUpdateAvailabilityDate"] = append(errors["NextUpdateAvailabilityDate"], err)
	}

	if err := model.ValidateMax(v, "NextUpdateAvailabilityDate", 25); err != nil {
		errors["NextUpdateAvailabilityDate"] = append(errors["NextUpdateAvailabilityDate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeMaintenanceStartTimeInput is undocumented.
type DescribeMaintenanceStartTimeInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DescribeMaintenanceStartTimeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeMaintenanceStartTimeOutput is undocumented.
type DescribeMaintenanceStartTimeOutput struct {
	DayOfWeek    aws.IntegerValue `json:"DayOfWeek,omitempty"`
	GatewayARN   aws.StringValue  `json:"GatewayARN,omitempty"`
	HourOfDay    aws.IntegerValue `json:"HourOfDay,omitempty"`
	MinuteOfHour aws.IntegerValue `json:"MinuteOfHour,omitempty"`
	Timezone     aws.StringValue  `json:"Timezone,omitempty"`
}

func (v *DescribeMaintenanceStartTimeOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DayOfWeek", 6); err != nil {
		errors["DayOfWeek"] = append(errors["DayOfWeek"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "HourOfDay", 23); err != nil {
		errors["HourOfDay"] = append(errors["HourOfDay"], err)
	}

	if err := model.ValidateMax(v, "MinuteOfHour", 59); err != nil {
		errors["MinuteOfHour"] = append(errors["MinuteOfHour"], err)
	}

	if err := model.ValidateMin(v, "Timezone", 3); err != nil {
		errors["Timezone"] = append(errors["Timezone"], err)
	}

	if err := model.ValidateMax(v, "Timezone", 10); err != nil {
		errors["Timezone"] = append(errors["Timezone"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSnapshotScheduleInput is undocumented.
type DescribeSnapshotScheduleInput struct {
	VolumeARN aws.StringValue `json:"VolumeARN"`
}

func (v *DescribeSnapshotScheduleInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeARN"); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSnapshotScheduleOutput is undocumented.
type DescribeSnapshotScheduleOutput struct {
	Description       aws.StringValue  `json:"Description,omitempty"`
	RecurrenceInHours aws.IntegerValue `json:"RecurrenceInHours,omitempty"`
	StartAt           aws.IntegerValue `json:"StartAt,omitempty"`
	Timezone          aws.StringValue  `json:"Timezone,omitempty"`
	VolumeARN         aws.StringValue  `json:"VolumeARN,omitempty"`
}

func (v *DescribeSnapshotScheduleOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Description", 1); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateMax(v, "Description", 255); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateMin(v, "RecurrenceInHours", 1); err != nil {
		errors["RecurrenceInHours"] = append(errors["RecurrenceInHours"], err)
	}

	if err := model.ValidateMax(v, "RecurrenceInHours", 24); err != nil {
		errors["RecurrenceInHours"] = append(errors["RecurrenceInHours"], err)
	}

	if err := model.ValidateMax(v, "StartAt", 23); err != nil {
		errors["StartAt"] = append(errors["StartAt"], err)
	}

	if err := model.ValidateMin(v, "Timezone", 3); err != nil {
		errors["Timezone"] = append(errors["Timezone"], err)
	}

	if err := model.ValidateMax(v, "Timezone", 10); err != nil {
		errors["Timezone"] = append(errors["Timezone"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeStorediSCSIVolumesInput is undocumented.
type DescribeStorediSCSIVolumesInput struct {
	VolumeARNs []string `json:"VolumeARNs"`
}

func (v *DescribeStorediSCSIVolumesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeARNs"); err != nil {
		errors["VolumeARNs"] = append(errors["VolumeARNs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeStorediSCSIVolumesOutput is undocumented.
type DescribeStorediSCSIVolumesOutput struct {
	StorediSCSIVolumes []StorediSCSIVolume `json:"StorediSCSIVolumes,omitempty"`
}

func (v *DescribeStorediSCSIVolumesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTapeArchivesInput is undocumented.
type DescribeTapeArchivesInput struct {
	Limit    aws.IntegerValue `json:"Limit,omitempty"`
	Marker   aws.StringValue  `json:"Marker,omitempty"`
	TapeARNs []string         `json:"TapeARNs,omitempty"`
}

func (v *DescribeTapeArchivesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Limit", 1); err != nil {
		errors["Limit"] = append(errors["Limit"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTapeArchivesOutput is undocumented.
type DescribeTapeArchivesOutput struct {
	Marker       aws.StringValue `json:"Marker,omitempty"`
	TapeArchives []TapeArchive   `json:"TapeArchives,omitempty"`
}

func (v *DescribeTapeArchivesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTapeRecoveryPointsInput is undocumented.
type DescribeTapeRecoveryPointsInput struct {
	GatewayARN aws.StringValue  `json:"GatewayARN"`
	Limit      aws.IntegerValue `json:"Limit,omitempty"`
	Marker     aws.StringValue  `json:"Marker,omitempty"`
}

func (v *DescribeTapeRecoveryPointsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Limit", 1); err != nil {
		errors["Limit"] = append(errors["Limit"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTapeRecoveryPointsOutput is undocumented.
type DescribeTapeRecoveryPointsOutput struct {
	GatewayARN             aws.StringValue         `json:"GatewayARN,omitempty"`
	Marker                 aws.StringValue         `json:"Marker,omitempty"`
	TapeRecoveryPointInfos []TapeRecoveryPointInfo `json:"TapeRecoveryPointInfos,omitempty"`
}

func (v *DescribeTapeRecoveryPointsOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTapesInput is undocumented.
type DescribeTapesInput struct {
	GatewayARN aws.StringValue  `json:"GatewayARN"`
	Limit      aws.IntegerValue `json:"Limit,omitempty"`
	Marker     aws.StringValue  `json:"Marker,omitempty"`
	TapeARNs   []string         `json:"TapeARNs,omitempty"`
}

func (v *DescribeTapesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Limit", 1); err != nil {
		errors["Limit"] = append(errors["Limit"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTapesOutput is undocumented.
type DescribeTapesOutput struct {
	Marker aws.StringValue `json:"Marker,omitempty"`
	Tapes  []Tape          `json:"Tapes,omitempty"`
}

func (v *DescribeTapesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeUploadBufferInput is undocumented.
type DescribeUploadBufferInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DescribeUploadBufferInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeUploadBufferOutput is undocumented.
type DescribeUploadBufferOutput struct {
	DiskIDs                      []string        `json:"DiskIds,omitempty"`
	GatewayARN                   aws.StringValue `json:"GatewayARN,omitempty"`
	UploadBufferAllocatedInBytes aws.LongValue   `json:"UploadBufferAllocatedInBytes,omitempty"`
	UploadBufferUsedInBytes      aws.LongValue   `json:"UploadBufferUsedInBytes,omitempty"`
}

func (v *DescribeUploadBufferOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVTLDevicesInput is undocumented.
type DescribeVTLDevicesInput struct {
	GatewayARN    aws.StringValue  `json:"GatewayARN"`
	Limit         aws.IntegerValue `json:"Limit,omitempty"`
	Marker        aws.StringValue  `json:"Marker,omitempty"`
	VTLDeviceARNs []string         `json:"VTLDeviceARNs,omitempty"`
}

func (v *DescribeVTLDevicesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Limit", 1); err != nil {
		errors["Limit"] = append(errors["Limit"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVTLDevicesOutput is undocumented.
type DescribeVTLDevicesOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
	Marker     aws.StringValue `json:"Marker,omitempty"`
	VTLDevices []VTLDevice     `json:"VTLDevices,omitempty"`
}

func (v *DescribeVTLDevicesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeWorkingStorageInput is undocumented.
type DescribeWorkingStorageInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DescribeWorkingStorageInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeWorkingStorageOutput is undocumented.
type DescribeWorkingStorageOutput struct {
	DiskIDs                        []string        `json:"DiskIds,omitempty"`
	GatewayARN                     aws.StringValue `json:"GatewayARN,omitempty"`
	WorkingStorageAllocatedInBytes aws.LongValue   `json:"WorkingStorageAllocatedInBytes,omitempty"`
	WorkingStorageUsedInBytes      aws.LongValue   `json:"WorkingStorageUsedInBytes,omitempty"`
}

func (v *DescribeWorkingStorageOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeviceiSCSIAttributes is undocumented.
type DeviceiSCSIAttributes struct {
	ChapEnabled          aws.BooleanValue `json:"ChapEnabled,omitempty"`
	NetworkInterfaceID   aws.StringValue  `json:"NetworkInterfaceId,omitempty"`
	NetworkInterfacePort aws.IntegerValue `json:"NetworkInterfacePort,omitempty"`
	TargetARN            aws.StringValue  `json:"TargetARN,omitempty"`
}

func (v *DeviceiSCSIAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "NetworkInterfaceID", `\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z`); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisableGatewayInput is undocumented.
type DisableGatewayInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *DisableGatewayInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisableGatewayOutput is undocumented.
type DisableGatewayOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *DisableGatewayOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Disk is undocumented.
type Disk struct {
	DiskAllocationResource aws.StringValue `json:"DiskAllocationResource,omitempty"`
	DiskAllocationType     aws.StringValue `json:"DiskAllocationType,omitempty"`
	DiskID                 aws.StringValue `json:"DiskId,omitempty"`
	DiskNode               aws.StringValue `json:"DiskNode,omitempty"`
	DiskPath               aws.StringValue `json:"DiskPath,omitempty"`
	DiskSizeInBytes        aws.LongValue   `json:"DiskSizeInBytes,omitempty"`
}

func (v *Disk) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "DiskAllocationType", 3); err != nil {
		errors["DiskAllocationType"] = append(errors["DiskAllocationType"], err)
	}

	if err := model.ValidateMax(v, "DiskAllocationType", 100); err != nil {
		errors["DiskAllocationType"] = append(errors["DiskAllocationType"], err)
	}

	if err := model.ValidateMin(v, "DiskID", 1); err != nil {
		errors["DiskID"] = append(errors["DiskID"], err)
	}

	if err := model.ValidateMax(v, "DiskID", 300); err != nil {
		errors["DiskID"] = append(errors["DiskID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for StorageGateway.
const (
	ErrorCodeActivationKeyExpired              = "ActivationKeyExpired"
	ErrorCodeActivationKeyInvalid              = "ActivationKeyInvalid"
	ErrorCodeActivationKeyNotFound             = "ActivationKeyNotFound"
	ErrorCodeAuthenticationFailure             = "AuthenticationFailure"
	ErrorCodeBandwidthThrottleScheduleNotFound = "BandwidthThrottleScheduleNotFound"
	ErrorCodeBlocked                           = "Blocked"
	ErrorCodeCannotExportSnapshot              = "CannotExportSnapshot"
	ErrorCodeChapCredentialNotFound            = "ChapCredentialNotFound"
	ErrorCodeDiskAlreadyAllocated              = "DiskAlreadyAllocated"
	ErrorCodeDiskDoesNotExist                  = "DiskDoesNotExist"
	ErrorCodeDiskSizeGreaterThanVolumeMaxSize  = "DiskSizeGreaterThanVolumeMaxSize"
	ErrorCodeDiskSizeLessThanVolumeSize        = "DiskSizeLessThanVolumeSize"
	ErrorCodeDiskSizeNotGigAligned             = "DiskSizeNotGigAligned"
	ErrorCodeDuplicateCertificateInfo          = "DuplicateCertificateInfo"
	ErrorCodeDuplicateSchedule                 = "DuplicateSchedule"
	ErrorCodeEndpointNotFound                  = "EndpointNotFound"
	ErrorCodeGatewayInternalError              = "GatewayInternalError"
	ErrorCodeGatewayNotConnected               = "GatewayNotConnected"
	ErrorCodeGatewayNotFound                   = "GatewayNotFound"
	ErrorCodeGatewayProxyNetworkConnectionBusy = "GatewayProxyNetworkConnectionBusy"
	ErrorCodeIAMnotSupported                   = "IAMNotSupported"
	ErrorCodeInitiatorInvalid                  = "InitiatorInvalid"
	ErrorCodeInitiatorNotFound                 = "InitiatorNotFound"
	ErrorCodeInternalError                     = "InternalError"
	ErrorCodeInvalidEndpoint                   = "InvalidEndpoint"
	ErrorCodeInvalidGateway                    = "InvalidGateway"
	ErrorCodeInvalidParameters                 = "InvalidParameters"
	ErrorCodeInvalidSchedule                   = "InvalidSchedule"
	ErrorCodeLocalStorageLimitExceeded         = "LocalStorageLimitExceeded"
	ErrorCodeLunAlreadyAllocated               = "LunAlreadyAllocated "
	ErrorCodeLunInvalid                        = "LunInvalid"
	ErrorCodeMaximumContentLengthExceeded      = "MaximumContentLengthExceeded"
	ErrorCodeMaximumTapeCartridgeCountExceeded = "MaximumTapeCartridgeCountExceeded"
	ErrorCodeMaximumVolumeCountExceeded        = "MaximumVolumeCountExceeded"
	ErrorCodeNetworkConfigurationChanged       = "NetworkConfigurationChanged"
	ErrorCodeNoDisksAvailable                  = "NoDisksAvailable"
	ErrorCodeNotImplemented                    = "NotImplemented"
	ErrorCodeNotSupported                      = "NotSupported"
	ErrorCodeOperationAborted                  = "OperationAborted"
	ErrorCodeOutdatedGateway                   = "OutdatedGateway"
	ErrorCodeParametersNotImplemented          = "ParametersNotImplemented"
	ErrorCodeRegionInvalid                     = "RegionInvalid"
	ErrorCodeRequestTimeout                    = "RequestTimeout"
	ErrorCodeServiceUnavailable                = "ServiceUnavailable"
	ErrorCodeSnapshotDeleted                   = "SnapshotDeleted"
	ErrorCodeSnapshotIDInvalid                 = "SnapshotIdInvalid"
	ErrorCodeSnapshotInProgress                = "SnapshotInProgress"
	ErrorCodeSnapshotNotFound                  = "SnapshotNotFound"
	ErrorCodeSnapshotScheduleNotFound          = "SnapshotScheduleNotFound"
	ErrorCodeStagingAreaFull                   = "StagingAreaFull"
	ErrorCodeStorageFailure                    = "StorageFailure"
	ErrorCodeTapeCartridgeNotFound             = "TapeCartridgeNotFound"
	ErrorCodeTargetAlreadyExists               = "TargetAlreadyExists"
	ErrorCodeTargetInvalid                     = "TargetInvalid"
	ErrorCodeTargetNotFound                    = "TargetNotFound"
	ErrorCodeUnauthorizedOperation             = "UnauthorizedOperation"
	ErrorCodeVolumeAlreadyExists               = "VolumeAlreadyExists"
	ErrorCodeVolumeIDInvalid                   = "VolumeIdInvalid"
	ErrorCodeVolumeInUse                       = "VolumeInUse"
	ErrorCodeVolumeNotFound                    = "VolumeNotFound"
	ErrorCodeVolumeNotReady                    = "VolumeNotReady"
)

// GatewayInfo is undocumented.
type GatewayInfo struct {
	GatewayARN              aws.StringValue `json:"GatewayARN,omitempty"`
	GatewayOperationalState aws.StringValue `json:"GatewayOperationalState,omitempty"`
	GatewayType             aws.StringValue `json:"GatewayType,omitempty"`
}

func (v *GatewayInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayOperationalState", 2); err != nil {
		errors["GatewayOperationalState"] = append(errors["GatewayOperationalState"], err)
	}

	if err := model.ValidateMax(v, "GatewayOperationalState", 25); err != nil {
		errors["GatewayOperationalState"] = append(errors["GatewayOperationalState"], err)
	}

	if err := model.ValidateMin(v, "GatewayType", 2); err != nil {
		errors["GatewayType"] = append(errors["GatewayType"], err)
	}

	if err := model.ValidateMax(v, "GatewayType", 20); err != nil {
		errors["GatewayType"] = append(errors["GatewayType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGatewaysInput is undocumented.
type ListGatewaysInput struct {
	Limit  aws.IntegerValue `json:"Limit,omitempty"`
	Marker aws.StringValue  `json:"Marker,omitempty"`
}

func (v *ListGatewaysInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Limit", 1); err != nil {
		errors["Limit"] = append(errors["Limit"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGatewaysOutput is undocumented.
type ListGatewaysOutput struct {
	Gateways []GatewayInfo   `json:"Gateways,omitempty"`
	Marker   aws.StringValue `json:"Marker,omitempty"`
}

func (v *ListGatewaysOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListLocalDisksInput is undocumented.
type ListLocalDisksInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *ListLocalDisksInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListLocalDisksOutput is undocumented.
type ListLocalDisksOutput struct {
	Disks      []Disk          `json:"Disks,omitempty"`
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *ListLocalDisksOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListVolumeRecoveryPointsInput is undocumented.
type ListVolumeRecoveryPointsInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *ListVolumeRecoveryPointsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListVolumeRecoveryPointsOutput is undocumented.
type ListVolumeRecoveryPointsOutput struct {
	GatewayARN               aws.StringValue           `json:"GatewayARN,omitempty"`
	VolumeRecoveryPointInfos []VolumeRecoveryPointInfo `json:"VolumeRecoveryPointInfos,omitempty"`
}

func (v *ListVolumeRecoveryPointsOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListVolumesInput is undocumented.
type ListVolumesInput struct {
	GatewayARN aws.StringValue  `json:"GatewayARN"`
	Limit      aws.IntegerValue `json:"Limit,omitempty"`
	Marker     aws.StringValue  `json:"Marker,omitempty"`
}

func (v *ListVolumesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Limit", 1); err != nil {
		errors["Limit"] = append(errors["Limit"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListVolumesOutput is undocumented.
type ListVolumesOutput struct {
	GatewayARN  aws.StringValue `json:"GatewayARN,omitempty"`
	Marker      aws.StringValue `json:"Marker,omitempty"`
	VolumeInfos []VolumeInfo    `json:"VolumeInfos,omitempty"`
}

func (v *ListVolumesOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 1000); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkInterface is undocumented.
type NetworkInterface struct {
	IPv4Address aws.StringValue `json:"Ipv4Address,omitempty"`
	IPv6Address aws.StringValue `json:"Ipv6Address,omitempty"`
	MACAddress  aws.StringValue `json:"MacAddress,omitempty"`
}

func (v *NetworkInterface) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RetrieveTapeArchiveInput is undocumented.
type RetrieveTapeArchiveInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
	TapeARN    aws.StringValue `json:"TapeARN"`
}

func (v *RetrieveTapeArchiveInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "TapeARN"); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RetrieveTapeArchiveOutput is undocumented.
type RetrieveTapeArchiveOutput struct {
	TapeARN aws.StringValue `json:"TapeARN,omitempty"`
}

func (v *RetrieveTapeArchiveOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RetrieveTapeRecoveryPointInput is undocumented.
type RetrieveTapeRecoveryPointInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
	TapeARN    aws.StringValue `json:"TapeARN"`
}

func (v *RetrieveTapeRecoveryPointInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "TapeARN"); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RetrieveTapeRecoveryPointOutput is undocumented.
type RetrieveTapeRecoveryPointOutput struct {
	TapeARN aws.StringValue `json:"TapeARN,omitempty"`
}

func (v *RetrieveTapeRecoveryPointOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ShutdownGatewayInput is undocumented.
type ShutdownGatewayInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *ShutdownGatewayInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ShutdownGatewayOutput is undocumented.
type ShutdownGatewayOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *ShutdownGatewayOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartGatewayInput is undocumented.
type StartGatewayInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *StartGatewayInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartGatewayOutput is undocumented.
type StartGatewayOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *StartGatewayOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StorageGatewayError is undocumented.
type StorageGatewayError struct {
	ErrorCode    aws.StringValue   `json:"errorCode,omitempty"`
	ErrorDetails map[string]string `json:"errorDetails,omitempty"`
}

func (v *StorageGatewayError) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	errorCodeEnum := []string{
		ErrorCodeActivationKeyExpired,
		ErrorCodeActivationKeyInvalid,
		ErrorCodeActivationKeyNotFound,
		ErrorCodeAuthenticationFailure,
		ErrorCodeBandwidthThrottleScheduleNotFound,
		ErrorCodeBlocked,
		ErrorCodeCannotExportSnapshot,
		ErrorCodeChapCredentialNotFound,
		ErrorCodeDiskAlreadyAllocated,
		ErrorCodeDiskDoesNotExist,
		ErrorCodeDiskSizeGreaterThanVolumeMaxSize,
		ErrorCodeDiskSizeLessThanVolumeSize,
		ErrorCodeDiskSizeNotGigAligned,
		ErrorCodeDuplicateCertificateInfo,
		ErrorCodeDuplicateSchedule,
		ErrorCodeEndpointNotFound,
		ErrorCodeGatewayInternalError,
		ErrorCodeGatewayNotConnected,
		ErrorCodeGatewayNotFound,
		ErrorCodeGatewayProxyNetworkConnectionBusy,
		ErrorCodeIAMnotSupported,
		ErrorCodeInitiatorInvalid,
		ErrorCodeInitiatorNotFound,
		ErrorCodeInternalError,
		ErrorCodeInvalidEndpoint,
		ErrorCodeInvalidGateway,
		ErrorCodeInvalidParameters,
		ErrorCodeInvalidSchedule,
		ErrorCodeLocalStorageLimitExceeded,
		ErrorCodeLunAlreadyAllocated,
		ErrorCodeLunInvalid,
		ErrorCodeMaximumContentLengthExceeded,
		ErrorCodeMaximumTapeCartridgeCountExceeded,
		ErrorCodeMaximumVolumeCountExceeded,
		ErrorCodeNetworkConfigurationChanged,
		ErrorCodeNoDisksAvailable,
		ErrorCodeNotImplemented,
		ErrorCodeNotSupported,
		ErrorCodeOperationAborted,
		ErrorCodeOutdatedGateway,
		ErrorCodeParametersNotImplemented,
		ErrorCodeRegionInvalid,
		ErrorCodeRequestTimeout,
		ErrorCodeServiceUnavailable,
		ErrorCodeSnapshotDeleted,
		ErrorCodeSnapshotIDInvalid,
		ErrorCodeSnapshotInProgress,
		ErrorCodeSnapshotNotFound,
		ErrorCodeSnapshotScheduleNotFound,
		ErrorCodeStagingAreaFull,
		ErrorCodeStorageFailure,
		ErrorCodeTapeCartridgeNotFound,
		ErrorCodeTargetAlreadyExists,
		ErrorCodeTargetInvalid,
		ErrorCodeTargetNotFound,
		ErrorCodeUnauthorizedOperation,
		ErrorCodeVolumeAlreadyExists,
		ErrorCodeVolumeIDInvalid,
		ErrorCodeVolumeInUse,
		ErrorCodeVolumeNotFound,
		ErrorCodeVolumeNotReady,
	}
	if err := model.ValidateEnum(v, "ErrorCode", errorCodeEnum); err != nil {
		errors["ErrorCode"] = append(errors["ErrorCode"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StorediSCSIVolume is undocumented.
type StorediSCSIVolume struct {
	PreservedExistingData aws.BooleanValue       `json:"PreservedExistingData,omitempty"`
	SourceSnapshotID      aws.StringValue        `json:"SourceSnapshotId,omitempty"`
	VolumeARN             aws.StringValue        `json:"VolumeARN,omitempty"`
	VolumeDiskID          aws.StringValue        `json:"VolumeDiskId,omitempty"`
	VolumeID              aws.StringValue        `json:"VolumeId,omitempty"`
	VolumeProgress        aws.DoubleValue        `json:"VolumeProgress,omitempty"`
	VolumeSizeInBytes     aws.LongValue          `json:"VolumeSizeInBytes,omitempty"`
	VolumeStatus          aws.StringValue        `json:"VolumeStatus,omitempty"`
	VolumeType            aws.StringValue        `json:"VolumeType,omitempty"`
	VolumeiSCSIAttributes *VolumeiSCSIAttributes `json:"VolumeiSCSIAttributes,omitempty"`
}

func (v *StorediSCSIVolume) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "SourceSnapshotID", `\Asnap-[0-9a-fA-F]{8}\z`); err != nil {
		errors["SourceSnapshotID"] = append(errors["SourceSnapshotID"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeDiskID", 1); err != nil {
		errors["VolumeDiskID"] = append(errors["VolumeDiskID"], err)
	}

	if err := model.ValidateMax(v, "VolumeDiskID", 300); err != nil {
		errors["VolumeDiskID"] = append(errors["VolumeDiskID"], err)
	}

	if err := model.ValidateMin(v, "VolumeID", 12); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if err := model.ValidateMax(v, "VolumeID", 30); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if err := model.ValidateMin(v, "VolumeStatus", 3); err != nil {
		errors["VolumeStatus"] = append(errors["VolumeStatus"], err)
	}

	if err := model.ValidateMax(v, "VolumeStatus", 50); err != nil {
		errors["VolumeStatus"] = append(errors["VolumeStatus"], err)
	}

	if err := model.ValidateMin(v, "VolumeType", 3); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if err := model.ValidateMax(v, "VolumeType", 100); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Tape is undocumented.
type Tape struct {
	Progress        aws.DoubleValue `json:"Progress,omitempty"`
	TapeARN         aws.StringValue `json:"TapeARN,omitempty"`
	TapeBarcode     aws.StringValue `json:"TapeBarcode,omitempty"`
	TapeSizeInBytes aws.LongValue   `json:"TapeSizeInBytes,omitempty"`
	TapeStatus      aws.StringValue `json:"TapeStatus,omitempty"`
	VTLDevice       aws.StringValue `json:"VTLDevice,omitempty"`
}

func (v *Tape) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeBarcode", 8); err != nil {
		errors["TapeBarcode"] = append(errors["TapeBarcode"], err)
	}

	if err := model.ValidateMax(v, "TapeBarcode", 16); err != nil {
		errors["TapeBarcode"] = append(errors["TapeBarcode"], err)
	}

	if err := model.ValidatePattern(v, "TapeBarcode", `^[A-Z0-9]*$`); err != nil {
		errors["TapeBarcode"] = append(errors["TapeBarcode"], err)
	}

	if err := model.ValidateMin(v, "TapeSizeInBytes", 107374182400); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if err := model.ValidateMax(v, "TapeSizeInBytes", 2748779069440); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if err := model.ValidateMin(v, "VTLDevice", 50); err != nil {
		errors["VTLDevice"] = append(errors["VTLDevice"], err)
	}

	if err := model.ValidateMax(v, "VTLDevice", 500); err != nil {
		errors["VTLDevice"] = append(errors["VTLDevice"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TapeArchive is undocumented.
type TapeArchive struct {
	CompletionTime  time.Time       `json:"CompletionTime,omitempty"`
	RetrievedTo     aws.StringValue `json:"RetrievedTo,omitempty"`
	TapeARN         aws.StringValue `json:"TapeARN,omitempty"`
	TapeBarcode     aws.StringValue `json:"TapeBarcode,omitempty"`
	TapeSizeInBytes aws.LongValue   `json:"TapeSizeInBytes,omitempty"`
	TapeStatus      aws.StringValue `json:"TapeStatus,omitempty"`
}

func (v *TapeArchive) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "RetrievedTo", 50); err != nil {
		errors["RetrievedTo"] = append(errors["RetrievedTo"], err)
	}

	if err := model.ValidateMax(v, "RetrievedTo", 500); err != nil {
		errors["RetrievedTo"] = append(errors["RetrievedTo"], err)
	}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeBarcode", 8); err != nil {
		errors["TapeBarcode"] = append(errors["TapeBarcode"], err)
	}

	if err := model.ValidateMax(v, "TapeBarcode", 16); err != nil {
		errors["TapeBarcode"] = append(errors["TapeBarcode"], err)
	}

	if err := model.ValidatePattern(v, "TapeBarcode", `^[A-Z0-9]*$`); err != nil {
		errors["TapeBarcode"] = append(errors["TapeBarcode"], err)
	}

	if err := model.ValidateMin(v, "TapeSizeInBytes", 107374182400); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if err := model.ValidateMax(v, "TapeSizeInBytes", 2748779069440); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TapeRecoveryPointInfo is undocumented.
type TapeRecoveryPointInfo struct {
	TapeARN               aws.StringValue `json:"TapeARN,omitempty"`
	TapeRecoveryPointTime time.Time       `json:"TapeRecoveryPointTime,omitempty"`
	TapeSizeInBytes       aws.LongValue   `json:"TapeSizeInBytes,omitempty"`
	TapeStatus            aws.StringValue `json:"TapeStatus,omitempty"`
}

func (v *TapeRecoveryPointInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "TapeARN", 50); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMax(v, "TapeARN", 500); err != nil {
		errors["TapeARN"] = append(errors["TapeARN"], err)
	}

	if err := model.ValidateMin(v, "TapeSizeInBytes", 107374182400); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if err := model.ValidateMax(v, "TapeSizeInBytes", 2748779069440); err != nil {
		errors["TapeSizeInBytes"] = append(errors["TapeSizeInBytes"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateBandwidthRateLimitInput is undocumented.
type UpdateBandwidthRateLimitInput struct {
	AverageDownloadRateLimitInBitsPerSec aws.LongValue   `json:"AverageDownloadRateLimitInBitsPerSec,omitempty"`
	AverageUploadRateLimitInBitsPerSec   aws.LongValue   `json:"AverageUploadRateLimitInBitsPerSec,omitempty"`
	GatewayARN                           aws.StringValue `json:"GatewayARN"`
}

func (v *UpdateBandwidthRateLimitInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "AverageDownloadRateLimitInBitsPerSec", 102400); err != nil {
		errors["AverageDownloadRateLimitInBitsPerSec"] = append(errors["AverageDownloadRateLimitInBitsPerSec"], err)
	}

	if err := model.ValidateMin(v, "AverageUploadRateLimitInBitsPerSec", 51200); err != nil {
		errors["AverageUploadRateLimitInBitsPerSec"] = append(errors["AverageUploadRateLimitInBitsPerSec"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateBandwidthRateLimitOutput is undocumented.
type UpdateBandwidthRateLimitOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *UpdateBandwidthRateLimitOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateChapCredentialsInput is undocumented.
type UpdateChapCredentialsInput struct {
	InitiatorName                 aws.StringValue `json:"InitiatorName"`
	SecretToAuthenticateInitiator aws.StringValue `json:"SecretToAuthenticateInitiator"`
	SecretToAuthenticateTarget    aws.StringValue `json:"SecretToAuthenticateTarget,omitempty"`
	TargetARN                     aws.StringValue `json:"TargetARN"`
}

func (v *UpdateChapCredentialsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatorName"); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMin(v, "InitiatorName", 1); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMax(v, "InitiatorName", 255); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidatePattern(v, "InitiatorName", `[0-9a-z:.-]+`); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateRequired(v, "SecretToAuthenticateInitiator"); err != nil {
		errors["SecretToAuthenticateInitiator"] = append(errors["SecretToAuthenticateInitiator"], err)
	}

	if err := model.ValidateMin(v, "SecretToAuthenticateInitiator", 12); err != nil {
		errors["SecretToAuthenticateInitiator"] = append(errors["SecretToAuthenticateInitiator"], err)
	}

	if err := model.ValidateMax(v, "SecretToAuthenticateInitiator", 16); err != nil {
		errors["SecretToAuthenticateInitiator"] = append(errors["SecretToAuthenticateInitiator"], err)
	}

	if err := model.ValidateMin(v, "SecretToAuthenticateTarget", 12); err != nil {
		errors["SecretToAuthenticateTarget"] = append(errors["SecretToAuthenticateTarget"], err)
	}

	if err := model.ValidateMax(v, "SecretToAuthenticateTarget", 16); err != nil {
		errors["SecretToAuthenticateTarget"] = append(errors["SecretToAuthenticateTarget"], err)
	}

	if err := model.ValidateRequired(v, "TargetARN"); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateChapCredentialsOutput is undocumented.
type UpdateChapCredentialsOutput struct {
	InitiatorName aws.StringValue `json:"InitiatorName,omitempty"`
	TargetARN     aws.StringValue `json:"TargetARN,omitempty"`
}

func (v *UpdateChapCredentialsOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "InitiatorName", 1); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMax(v, "InitiatorName", 255); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidatePattern(v, "InitiatorName", `[0-9a-z:.-]+`); err != nil {
		errors["InitiatorName"] = append(errors["InitiatorName"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateGatewayInformationInput is undocumented.
type UpdateGatewayInformationInput struct {
	GatewayARN      aws.StringValue `json:"GatewayARN"`
	GatewayName     aws.StringValue `json:"GatewayName,omitempty"`
	GatewayTimezone aws.StringValue `json:"GatewayTimezone,omitempty"`
}

func (v *UpdateGatewayInformationInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayName", 2); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidateMax(v, "GatewayName", 255); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidatePattern(v, "GatewayName", `^[ -\.0-\[\]-~]*[!-\.0-\[\]-~][ -\.0-\[\]-~]*$`); err != nil {
		errors["GatewayName"] = append(errors["GatewayName"], err)
	}

	if err := model.ValidateMin(v, "GatewayTimezone", 3); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if err := model.ValidateMax(v, "GatewayTimezone", 10); err != nil {
		errors["GatewayTimezone"] = append(errors["GatewayTimezone"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateGatewayInformationOutput is undocumented.
type UpdateGatewayInformationOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *UpdateGatewayInformationOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateGatewaySoftwareNowInput is undocumented.
type UpdateGatewaySoftwareNowInput struct {
	GatewayARN aws.StringValue `json:"GatewayARN"`
}

func (v *UpdateGatewaySoftwareNowInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateGatewaySoftwareNowOutput is undocumented.
type UpdateGatewaySoftwareNowOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *UpdateGatewaySoftwareNowOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateMaintenanceStartTimeInput is undocumented.
type UpdateMaintenanceStartTimeInput struct {
	DayOfWeek    aws.IntegerValue `json:"DayOfWeek"`
	GatewayARN   aws.StringValue  `json:"GatewayARN"`
	HourOfDay    aws.IntegerValue `json:"HourOfDay"`
	MinuteOfHour aws.IntegerValue `json:"MinuteOfHour"`
}

func (v *UpdateMaintenanceStartTimeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DayOfWeek"); err != nil {
		errors["DayOfWeek"] = append(errors["DayOfWeek"], err)
	}

	if err := model.ValidateMax(v, "DayOfWeek", 6); err != nil {
		errors["DayOfWeek"] = append(errors["DayOfWeek"], err)
	}

	if err := model.ValidateRequired(v, "GatewayARN"); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateRequired(v, "HourOfDay"); err != nil {
		errors["HourOfDay"] = append(errors["HourOfDay"], err)
	}

	if err := model.ValidateMax(v, "HourOfDay", 23); err != nil {
		errors["HourOfDay"] = append(errors["HourOfDay"], err)
	}

	if err := model.ValidateRequired(v, "MinuteOfHour"); err != nil {
		errors["MinuteOfHour"] = append(errors["MinuteOfHour"], err)
	}

	if err := model.ValidateMax(v, "MinuteOfHour", 59); err != nil {
		errors["MinuteOfHour"] = append(errors["MinuteOfHour"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateMaintenanceStartTimeOutput is undocumented.
type UpdateMaintenanceStartTimeOutput struct {
	GatewayARN aws.StringValue `json:"GatewayARN,omitempty"`
}

func (v *UpdateMaintenanceStartTimeOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "GatewayARN", 50); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if err := model.ValidateMax(v, "GatewayARN", 500); err != nil {
		errors["GatewayARN"] = append(errors["GatewayARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateSnapshotScheduleInput is undocumented.
type UpdateSnapshotScheduleInput struct {
	Description       aws.StringValue  `json:"Description,omitempty"`
	RecurrenceInHours aws.IntegerValue `json:"RecurrenceInHours"`
	StartAt           aws.IntegerValue `json:"StartAt"`
	VolumeARN         aws.StringValue  `json:"VolumeARN"`
}

func (v *UpdateSnapshotScheduleInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Description", 1); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateMax(v, "Description", 255); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "RecurrenceInHours"); err != nil {
		errors["RecurrenceInHours"] = append(errors["RecurrenceInHours"], err)
	}

	if err := model.ValidateMin(v, "RecurrenceInHours", 1); err != nil {
		errors["RecurrenceInHours"] = append(errors["RecurrenceInHours"], err)
	}

	if err := model.ValidateMax(v, "RecurrenceInHours", 24); err != nil {
		errors["RecurrenceInHours"] = append(errors["RecurrenceInHours"], err)
	}

	if err := model.ValidateRequired(v, "StartAt"); err != nil {
		errors["StartAt"] = append(errors["StartAt"], err)
	}

	if err := model.ValidateMax(v, "StartAt", 23); err != nil {
		errors["StartAt"] = append(errors["StartAt"], err)
	}

	if err := model.ValidateRequired(v, "VolumeARN"); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateSnapshotScheduleOutput is undocumented.
type UpdateSnapshotScheduleOutput struct {
	VolumeARN aws.StringValue `json:"VolumeARN,omitempty"`
}

func (v *UpdateSnapshotScheduleOutput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VTLDevice is undocumented.
type VTLDevice struct {
	DeviceiSCSIAttributes      *DeviceiSCSIAttributes `json:"DeviceiSCSIAttributes,omitempty"`
	VTLDeviceARN               aws.StringValue        `json:"VTLDeviceARN,omitempty"`
	VTLDeviceProductIdentifier aws.StringValue        `json:"VTLDeviceProductIdentifier,omitempty"`
	VTLDeviceType              aws.StringValue        `json:"VTLDeviceType,omitempty"`
	VTLDeviceVendor            aws.StringValue        `json:"VTLDeviceVendor,omitempty"`
}

func (v *VTLDevice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "VTLDeviceARN", 50); err != nil {
		errors["VTLDeviceARN"] = append(errors["VTLDeviceARN"], err)
	}

	if err := model.ValidateMax(v, "VTLDeviceARN", 500); err != nil {
		errors["VTLDeviceARN"] = append(errors["VTLDeviceARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeInfo is undocumented.
type VolumeInfo struct {
	VolumeARN  aws.StringValue `json:"VolumeARN,omitempty"`
	VolumeType aws.StringValue `json:"VolumeType,omitempty"`
}

func (v *VolumeInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMin(v, "VolumeType", 3); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if err := model.ValidateMax(v, "VolumeType", 100); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeRecoveryPointInfo is undocumented.
type VolumeRecoveryPointInfo struct {
	VolumeARN               aws.StringValue `json:"VolumeARN,omitempty"`
	VolumeRecoveryPointTime aws.StringValue `json:"VolumeRecoveryPointTime,omitempty"`
	VolumeSizeInBytes       aws.LongValue   `json:"VolumeSizeInBytes,omitempty"`
	VolumeUsageInBytes      aws.LongValue   `json:"VolumeUsageInBytes,omitempty"`
}

func (v *VolumeRecoveryPointInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "VolumeARN", 50); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if err := model.ValidateMax(v, "VolumeARN", 500); err != nil {
		errors["VolumeARN"] = append(errors["VolumeARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeiSCSIAttributes is undocumented.
type VolumeiSCSIAttributes struct {
	ChapEnabled          aws.BooleanValue `json:"ChapEnabled,omitempty"`
	LunNumber            aws.IntegerValue `json:"LunNumber,omitempty"`
	NetworkInterfaceID   aws.StringValue  `json:"NetworkInterfaceId,omitempty"`
	NetworkInterfacePort aws.IntegerValue `json:"NetworkInterfacePort,omitempty"`
	TargetARN            aws.StringValue  `json:"TargetARN,omitempty"`
}

func (v *VolumeiSCSIAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "LunNumber", 1); err != nil {
		errors["LunNumber"] = append(errors["LunNumber"], err)
	}

	if err := model.ValidatePattern(v, "NetworkInterfaceID", `\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z`); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidateMin(v, "TargetARN", 50); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if err := model.ValidateMax(v, "TargetARN", 800); err != nil {
		errors["TargetARN"] = append(errors["TargetARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// avoid errors if the packages aren't referenced
var _ time.Time
