// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package ec2 provides a client for Amazon Elastic Compute Cloud.
package ec2

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

// EC2 is a client for Amazon Elastic Compute Cloud.
type EC2 struct {
	client *aws.EC2Client
}

// New returns a new EC2 client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *EC2 {
	if client == nil {
		client = http.DefaultClient
	}

	service := "ec2"
	endpoint, service, region := endpoints.Lookup("ec2", region)

	return &EC2{
		client: &aws.EC2Client{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2014-10-01",
		},
	}
}

// AcceptVPCPeeringConnection accept a VPC peering connection request. To
// accept a request, the VPC peering connection must be in the
// pending-acceptance state, and you must be the owner of the peer Use the
// DescribeVpcPeeringConnections request to view your outstanding VPC
// peering connection requests.
func (c *EC2) AcceptVPCPeeringConnection(req *AcceptVPCPeeringConnectionRequest) (resp *AcceptVPCPeeringConnectionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AcceptVPCPeeringConnectionResult{}
	err = c.client.Do("AcceptVpcPeeringConnection", "POST", "/", req, resp)
	return
}

// AllocateAddress acquires an Elastic IP address. An Elastic IP address is
// for use either in the EC2-Classic platform or in a For more information,
// see Elastic IP Addresses in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) AllocateAddress(req *AllocateAddressRequest) (resp *AllocateAddressResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AllocateAddressResult{}
	err = c.client.Do("AllocateAddress", "POST", "/", req, resp)
	return
}

// AssignPrivateIPAddresses assigns one or more secondary private IP
// addresses to the specified network interface. You can specify one or
// more specific secondary IP addresses, or you can specify the number of
// secondary IP addresses to be automatically assigned within the subnet's
// block range. The number of secondary IP addresses that you can assign to
// an instance varies by instance type. For information about instance
// types, see Instance Types in the Amazon Elastic Compute Cloud User Guide
// . For more information about Elastic IP addresses, see Elastic IP
// Addresses in the Amazon Elastic Compute Cloud User Guide
// AssignPrivateIpAddresses is available only in EC2-VPC.
func (c *EC2) AssignPrivateIPAddresses(req *AssignPrivateIPAddressesRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AssignPrivateIpAddresses", "POST", "/", req, nil)
	return
}

// AssociateAddress associates an Elastic IP address with an instance or a
// network interface. An Elastic IP address is for use in either the
// EC2-Classic platform or in a For more information, see Elastic IP
// Addresses in the Amazon Elastic Compute Cloud User Guide [EC2-Classic,
// VPC in an EC2-VPC-only account] If the Elastic IP address is already
// associated with a different instance, it is disassociated from that
// instance and associated with the specified instance. in an EC2-Classic
// account] If you don't specify a private IP address, the Elastic IP
// address is associated with the primary IP address. If the Elastic IP
// address is already associated with a different instance or a network
// interface, you get an error unless you allow reassociation. This is an
// idempotent operation. If you perform the operation more than once,
// Amazon EC2 doesn't return an error.
func (c *EC2) AssociateAddress(req *AssociateAddressRequest) (resp *AssociateAddressResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AssociateAddressResult{}
	err = c.client.Do("AssociateAddress", "POST", "/", req, resp)
	return
}

// AssociateDHCPOptions associates a set of options (that you've previously
// created) with the specified or associates no options with the After you
// associate the options with the any existing instances and all new
// instances that you launch in that VPC use the options. You don't need to
// restart or relaunch the instances. They automatically pick up the
// changes within a few hours, depending on how frequently the instance
// renews its lease. You can explicitly renew the lease using the operating
// system on the instance. For more information, see Options Sets in the
// Amazon Virtual Private Cloud User Guide
func (c *EC2) AssociateDHCPOptions(req *AssociateDHCPOptionsRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AssociateDhcpOptions", "POST", "/", req, nil)
	return
}

// AssociateRouteTable associates a subnet with a route table. The subnet
// and route table must be in the same This association causes traffic
// originating from the subnet to be routed according to the routes in the
// route table. The action returns an association ID, which you need in
// order to disassociate the route table from the subnet later. A route
// table can be associated with multiple subnets. For more information
// about route tables, see Route Tables in the Amazon Virtual Private Cloud
// User Guide
func (c *EC2) AssociateRouteTable(req *AssociateRouteTableRequest) (resp *AssociateRouteTableResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AssociateRouteTableResult{}
	err = c.client.Do("AssociateRouteTable", "POST", "/", req, resp)
	return
}

// AttachInternetGateway attaches an Internet gateway to a enabling
// connectivity between the Internet and the For more information about
// your VPC and Internet gateway, see the Amazon Virtual Private Cloud User
// Guide
func (c *EC2) AttachInternetGateway(req *AttachInternetGatewayRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AttachInternetGateway", "POST", "/", req, nil)
	return
}

// AttachNetworkInterface is undocumented.
func (c *EC2) AttachNetworkInterface(req *AttachNetworkInterfaceRequest) (resp *AttachNetworkInterfaceResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AttachNetworkInterfaceResult{}
	err = c.client.Do("AttachNetworkInterface", "POST", "/", req, resp)
	return
}

// AttachVolume attaches an Amazon EBS volume to a running or stopped
// instance and exposes it to the instance with the specified device name.
// Encrypted Amazon EBS volumes may only be attached to instances that
// support Amazon EBS encryption. For more information, see Amazon EBS
// Encryption in the Amazon Elastic Compute Cloud User Guide For a list of
// supported device names, see Attaching an Amazon EBS Volume to an
// Instance . Any device names that aren't reserved for instance store
// volumes can be used for Amazon EBS volumes. For more information, see
// Amazon EC2 Instance Store in the Amazon Elastic Compute Cloud User Guide
// If a volume has an AWS Marketplace product code: The volume can only be
// attached as the root device of a stopped instance. You must be
// subscribed to the AWS Marketplace code that is on the volume. The
// configuration (instance type, operating system) of the instance must
// support that specific AWS Marketplace code. For example, you cannot take
// a volume from a Windows instance and attach it to a Linux instance. AWS
// Marketplace product codes are copied from the volume to the instance.
// For an overview of the AWS Marketplace, see
// https://aws.amazon.com/marketplace/help/200900000 . For more information
// about how to use the AWS Marketplace, see AWS Marketplace For more
// information about Amazon EBS volumes, see Attaching Amazon EBS Volumes
// in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) AttachVolume(req *AttachVolumeRequest) (resp *VolumeAttachment, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &VolumeAttachment{}
	err = c.client.Do("AttachVolume", "POST", "/", req, resp)
	return
}

// AttachVPNGateway attaches a virtual private gateway to a For more
// information, see Adding a Hardware Virtual Private Gateway to Your in
// the Amazon Virtual Private Cloud User Guide
func (c *EC2) AttachVPNGateway(req *AttachVPNGatewayRequest) (resp *AttachVPNGatewayResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AttachVPNGatewayResult{}
	err = c.client.Do("AttachVpnGateway", "POST", "/", req, resp)
	return
}

// AuthorizeSecurityGroupEgress adds one or more egress rules to a security
// group for use with a Specifically, this action permits instances to send
// traffic to one or more destination IP address ranges, or to one or more
// destination security groups for the same You can have up to 50 rules per
// security group (covering both ingress and egress rules). A security
// group is for use with instances either in the EC2-Classic platform or in
// a specific This action doesn't apply to security groups for use in
// EC2-Classic. For more information, see Security Groups for Your in the
// Amazon Virtual Private Cloud User Guide Each rule consists of the
// protocol (for example, plus either a range or a source group. For the
// TCP and UDP protocols, you must also specify the destination port or
// port range. For the protocol, you must also specify the type and code.
// You can use -1 for the type or code to mean all types or all codes. Rule
// changes are propagated to affected instances as quickly as possible.
// However, a small delay might occur.
func (c *EC2) AuthorizeSecurityGroupEgress(req *AuthorizeSecurityGroupEgressRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AuthorizeSecurityGroupEgress", "POST", "/", req, nil)
	return
}

// AuthorizeSecurityGroupIngress adds one or more ingress rules to a
// security group. EC2-Classic: You can have up to 100 rules per group.
// EC2-VPC: You can have up to 50 rules per group (covering both ingress
// and egress rules). Rule changes are propagated to instances within the
// security group as quickly as possible. However, a small delay might
// occur. [EC2-Classic] This action gives one or more IP address ranges
// permission to access a security group in your account, or gives one or
// more security groups (called the source groups ) permission to access a
// security group for your account. A source group can be for your own AWS
// account, or another. [EC2-VPC] This action gives one or more IP address
// ranges permission to access a security group in your or gives one or
// more other security groups (called the source groups ) permission to
// access a security group for your The security groups must all be for the
// same
func (c *EC2) AuthorizeSecurityGroupIngress(req *AuthorizeSecurityGroupIngressRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AuthorizeSecurityGroupIngress", "POST", "/", req, nil)
	return
}

// BundleInstance bundles an Amazon instance store-backed Windows instance.
// During bundling, only the root device volume is bundled. Data on other
// instance store volumes is not preserved. This procedure is not
// applicable for Linux/Unix instances or Windows instances that are backed
// by Amazon For more information, see Creating an Instance Store-Backed
// Windows
func (c *EC2) BundleInstance(req *BundleInstanceRequest) (resp *BundleInstanceResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &BundleInstanceResult{}
	err = c.client.Do("BundleInstance", "POST", "/", req, resp)
	return
}

// CancelBundleTask cancels a bundling operation for an instance
// store-backed Windows instance.
func (c *EC2) CancelBundleTask(req *CancelBundleTaskRequest) (resp *CancelBundleTaskResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CancelBundleTaskResult{}
	err = c.client.Do("CancelBundleTask", "POST", "/", req, resp)
	return
}

// CancelConversionTask cancels an active conversion task. The task can be
// the import of an instance or volume. The action removes all artifacts of
// the conversion, including a partially uploaded volume or instance. If
// the conversion is complete or is in the process of transferring the
// final disk image, the command fails and returns an exception. For more
// information, see Using the Command Line Tools to Import Your Virtual
// Machine to Amazon EC2 in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CancelConversionTask(req *CancelConversionRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CancelConversionTask", "POST", "/", req, nil)
	return
}

// CancelExportTask cancels an active export task. The request removes all
// artifacts of the export, including any partially-created Amazon S3
// objects. If the export task is complete or is in the process of
// transferring the final disk image, the command fails and returns an
// error.
func (c *EC2) CancelExportTask(req *CancelExportTaskRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CancelExportTask", "POST", "/", req, nil)
	return
}

// CancelReservedInstancesListing cancels the specified Reserved Instance
// listing in the Reserved Instance Marketplace. For more information, see
// Reserved Instance Marketplace in the Amazon Elastic Compute Cloud User
// Guide
func (c *EC2) CancelReservedInstancesListing(req *CancelReservedInstancesListingRequest) (resp *CancelReservedInstancesListingResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CancelReservedInstancesListingResult{}
	err = c.client.Do("CancelReservedInstancesListing", "POST", "/", req, resp)
	return
}

// CancelSpotInstanceRequests cancels one or more Spot Instance requests.
// Spot Instances are instances that Amazon EC2 starts on your behalf when
// the maximum price that you specify exceeds the current Spot Price.
// Amazon EC2 periodically sets the Spot Price based on available Spot
// Instance capacity and current Spot Instance requests. For more
// information about Spot Instances, see Spot Instances in the Amazon
// Elastic Compute Cloud User Guide Canceling a Spot Instance request does
// not terminate running Spot Instances associated with the request.
func (c *EC2) CancelSpotInstanceRequests(req *CancelSpotInstanceRequestsRequest) (resp *CancelSpotInstanceRequestsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CancelSpotInstanceRequestsResult{}
	err = c.client.Do("CancelSpotInstanceRequests", "POST", "/", req, resp)
	return
}

// ConfirmProductInstance determines whether a product code is associated
// with an instance. This action can only be used by the owner of the
// product code. It is useful when a product code owner needs to verify
// whether another user's instance is eligible for support.
func (c *EC2) ConfirmProductInstance(req *ConfirmProductInstanceRequest) (resp *ConfirmProductInstanceResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ConfirmProductInstanceResult{}
	err = c.client.Do("ConfirmProductInstance", "POST", "/", req, resp)
	return
}

// CopyImage initiates the copy of an AMI from the specified source region
// to the region in which the request was made. You specify the destination
// region by using its endpoint when making the request. AMIs that use
// encrypted Amazon EBS snapshots cannot be copied with this method. For
// more information, see Copying AMIs in the Amazon Elastic Compute Cloud
// User Guide
func (c *EC2) CopyImage(req *CopyImageRequest) (resp *CopyImageResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CopyImageResult{}
	err = c.client.Do("CopyImage", "POST", "/", req, resp)
	return
}

// CopySnapshot copies a point-in-time snapshot of an Amazon EBS volume and
// stores it in Amazon S3. You can copy the snapshot within the same region
// or from one region to another. You can use the snapshot to create Amazon
// EBS volumes or Amazon Machine Images (AMIs). The snapshot is copied to
// the regional endpoint that you send the request to. Copies of encrypted
// Amazon EBS snapshots remain encrypted. Copies of unencrypted snapshots
// remain unencrypted. For more information, see Copying an Amazon EBS
// Snapshot in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CopySnapshot(req *CopySnapshotRequest) (resp *CopySnapshotResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CopySnapshotResult{}
	err = c.client.Do("CopySnapshot", "POST", "/", req, resp)
	return
}

// CreateCustomerGateway provides information to AWS about your VPN
// customer gateway device. The customer gateway is the appliance at your
// end of the VPN connection. (The device on the AWS side of the VPN
// connection is the virtual private gateway.) You must provide the
// Internet-routable IP address of the customer gateway's external
// interface. The IP address must be static and can't be behind a device
// performing network address translation For devices that use Border
// Gateway Protocol you can also provide the device's BGP Autonomous System
// Number You can use an existing ASN assigned to your network. If you
// don't have an ASN already, you can use a private ASN (in the 64512 -
// 65534 range). Amazon EC2 supports all 2-byte ASN numbers in the range of
// 1 - 65534, with the exception of 7224, which is reserved in the
// us-east-1 region, and 9059, which is reserved in the eu-west-1 region.
// For more information about VPN customer gateways, see Adding a Hardware
// Virtual Private Gateway to Your in the Amazon Virtual Private Cloud User
// Guide
func (c *EC2) CreateCustomerGateway(req *CreateCustomerGatewayRequest) (resp *CreateCustomerGatewayResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateCustomerGatewayResult{}
	err = c.client.Do("CreateCustomerGateway", "POST", "/", req, resp)
	return
}

// CreateDHCPOptions creates a set of options for your After creating the
// set, you must associate it with the causing all existing and new
// instances that you launch in the VPC to use this set of options. The
// following are the individual options you can specify. For more
// information about the options, see RFC 2132 domain-name-servers - The IP
// addresses of up to four domain name servers, or AmazonProvidedDNS . The
// default option set specifies AmazonProvidedDNS . If specifying more than
// one domain name server, specify the IP addresses in a single parameter,
// separated by commas. domain-name - If you're using AmazonProvidedDNS in
// us-east-1 , specify ec2.internal . If you're using AmazonProvidedDNS in
// another region, specify region.compute.internal (for example,
// ap-northeast-1.compute.internal ). Otherwise, specify a domain name (for
// example, MyCompany.com ). If specifying more than one domain name,
// separate them with spaces. ntp-servers - The IP addresses of up to four
// Network Time Protocol servers. netbios-name-servers - The IP addresses
// of up to four NetBIOS name servers. netbios-node-type - The NetBIOS node
// type (1, 2, 4, or 8). We recommend that you specify 2 (broadcast and
// multicast are not currently supported). For more information about these
// node types, see RFC 2132 . Your VPC automatically starts out with a set
// of options that includes only a DNS server that we provide
// (AmazonProvidedDNS). If you create a set of options, and if your VPC has
// an Internet gateway, make sure to set the domain-name-servers option
// either to AmazonProvidedDNS or to a domain name server of your choice.
// For more information about options, see Options Sets in the Amazon
// Virtual Private Cloud User Guide
func (c *EC2) CreateDHCPOptions(req *CreateDHCPOptionsRequest) (resp *CreateDHCPOptionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateDHCPOptionsResult{}
	err = c.client.Do("CreateDhcpOptions", "POST", "/", req, resp)
	return
}

// CreateImage creates an Amazon EBS-backed AMI from an Amazon EBS-backed
// instance that is either running or stopped. If you customized your
// instance with instance store volumes or EBS volumes in addition to the
// root device volume, the new AMI contains block device mapping
// information for those volumes. When you launch an instance from this new
// the instance automatically launches with those additional volumes. For
// more information, see Creating Amazon EBS-Backed Linux AMIs in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateImage(req *CreateImageRequest) (resp *CreateImageResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateImageResult{}
	err = c.client.Do("CreateImage", "POST", "/", req, resp)
	return
}

// CreateInstanceExportTask exports a running or stopped instance to an
// Amazon S3 bucket. For information about the supported operating systems,
// image formats, and known limitations for the types of instances you can
// export, see Exporting EC2 Instances in the Amazon Elastic Compute Cloud
// User Guide
func (c *EC2) CreateInstanceExportTask(req *CreateInstanceExportTaskRequest) (resp *CreateInstanceExportTaskResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateInstanceExportTaskResult{}
	err = c.client.Do("CreateInstanceExportTask", "POST", "/", req, resp)
	return
}

// CreateInternetGateway creates an Internet gateway for use with a After
// creating the Internet gateway, you attach it to a VPC using
// AttachInternetGateway For more information about your VPC and Internet
// gateway, see the Amazon Virtual Private Cloud User Guide
func (c *EC2) CreateInternetGateway(req *CreateInternetGatewayRequest) (resp *CreateInternetGatewayResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateInternetGatewayResult{}
	err = c.client.Do("CreateInternetGateway", "POST", "/", req, resp)
	return
}

// CreateKeyPair creates a 2048-bit RSA key pair with the specified name.
// Amazon EC2 stores the public key and displays the private key for you to
// save to a file. The private key is returned as an unencrypted PEM
// encoded PKCS#8 private key. If a key with the specified name already
// exists, Amazon EC2 returns an error. You can have up to five thousand
// key pairs per region. The key pair returned to you is available only in
// the region in which you create it. To create a key pair that is
// available in all regions, use ImportKeyPair For more information about
// key pairs, see Key Pairs in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateKeyPair(req *CreateKeyPairRequest) (resp *KeyPair, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &KeyPair{}
	err = c.client.Do("CreateKeyPair", "POST", "/", req, resp)
	return
}

// CreateNetworkACL creates a network ACL in a Network ACLs provide an
// optional layer of security (in addition to security groups) for the
// instances in your For more information about network ACLs, see Network
// ACLs in the Amazon Virtual Private Cloud User Guide
func (c *EC2) CreateNetworkACL(req *CreateNetworkACLRequest) (resp *CreateNetworkACLResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateNetworkACLResult{}
	err = c.client.Do("CreateNetworkAcl", "POST", "/", req, resp)
	return
}

// CreateNetworkACLEntry creates an entry (a rule) in a network ACL with
// the specified rule number. Each network ACL has a set of numbered
// ingress rules and a separate set of numbered egress rules. When
// determining whether a packet should be allowed in or out of a subnet
// associated with the we process the entries in the ACL according to the
// rule numbers, in ascending order. Each network ACL has a set of ingress
// rules and a separate set of egress rules. We recommend that you leave
// room between the rule numbers (for example, 100, 110, 120, and not
// number them one right after the other (for example, 101, 102, 103, This
// makes it easier to add a rule between existing ones without having to
// renumber the rules. After you add an entry, you can't modify it; you
// must either replace it, or create an entry and delete the old one. For
// more information about network ACLs, see Network ACLs in the Amazon
// Virtual Private Cloud User Guide
func (c *EC2) CreateNetworkACLEntry(req *CreateNetworkACLEntryRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreateNetworkAclEntry", "POST", "/", req, nil)
	return
}

// CreateNetworkInterface creates a network interface in the specified
// subnet. For more information about network interfaces, see Elastic
// Network Interfaces in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateNetworkInterface(req *CreateNetworkInterfaceRequest) (resp *CreateNetworkInterfaceResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateNetworkInterfaceResult{}
	err = c.client.Do("CreateNetworkInterface", "POST", "/", req, resp)
	return
}

// CreatePlacementGroup creates a placement group that you launch cluster
// instances into. You must give the group a name that's unique within the
// scope of your account. For more information about placement groups and
// cluster instances, see Cluster Instances in the Amazon Elastic Compute
// Cloud User Guide
func (c *EC2) CreatePlacementGroup(req *CreatePlacementGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreatePlacementGroup", "POST", "/", req, nil)
	return
}

// CreateReservedInstancesListing creates a listing for Amazon EC2 Reserved
// Instances to be sold in the Reserved Instance Marketplace. You can
// submit one Reserved Instance listing at a time. To get a list of your
// Reserved Instances, you can use the DescribeReservedInstances operation.
// The Reserved Instance Marketplace matches sellers who want to resell
// Reserved Instance capacity that they no longer need with buyers who want
// to purchase additional capacity. Reserved Instances bought and sold
// through the Reserved Instance Marketplace work like any other Reserved
// Instances. To sell your Reserved Instances, you must first register as a
// Seller in the Reserved Instance Marketplace. After completing the
// registration process, you can create a Reserved Instance Marketplace
// listing of some or all of your Reserved Instances, and specify the
// upfront price to receive for them. Your Reserved Instance listings then
// become available for purchase. To view the details of your Reserved
// Instance listing, you can use the DescribeReservedInstancesListings
// operation. For more information, see Reserved Instance Marketplace in
// the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateReservedInstancesListing(req *CreateReservedInstancesListingRequest) (resp *CreateReservedInstancesListingResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateReservedInstancesListingResult{}
	err = c.client.Do("CreateReservedInstancesListing", "POST", "/", req, resp)
	return
}

// CreateRoute creates a route in a route table within a You must specify
// one of the following targets: Internet gateway or virtual private
// gateway, NAT instance, VPC peering connection, or network interface.
// When determining how to route traffic, we use the route with the most
// specific match. For example, let's say the traffic is destined for
// 192.0.2.3 , and the route table includes the following two routes:
// 192.0.2.0/24 (goes to some target 192.0.2.0/28 (goes to some target Both
// routes apply to the traffic destined for 192.0.2.3 . However, the second
// route in the list covers a smaller number of IP addresses and is
// therefore more specific, so we use that route to determine where to
// target the traffic. For more information about route tables, see Route
// Tables in the Amazon Virtual Private Cloud User Guide
func (c *EC2) CreateRoute(req *CreateRouteRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreateRoute", "POST", "/", req, nil)
	return
}

// CreateRouteTable creates a route table for the specified After you
// create a route table, you can add routes and associate the table with a
// subnet. For more information about route tables, see Route Tables in the
// Amazon Virtual Private Cloud User Guide
func (c *EC2) CreateRouteTable(req *CreateRouteTableRequest) (resp *CreateRouteTableResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateRouteTableResult{}
	err = c.client.Do("CreateRouteTable", "POST", "/", req, resp)
	return
}

// CreateSecurityGroup creates a security group. A security group is for
// use with instances either in the EC2-Classic platform or in a specific
// For more information, see Amazon EC2 Security Groups in the Amazon
// Elastic Compute Cloud User Guide and Security Groups for Your in the
// Amazon Virtual Private Cloud User Guide EC2-Classic: You can have up to
// 500 security groups. EC2-VPC: You can create up to 100 security groups
// per When you create a security group, you specify a friendly name of
// your choice. You can have a security group for use in EC2-Classic with
// the same name as a security group for use in a However, you can't have
// two security groups for use in EC2-Classic with the same name or two
// security groups for use in a VPC with the same name. You have a default
// security group for use in EC2-Classic and a default security group for
// use in your If you don't specify a security group when you launch an
// instance, the instance is launched into the appropriate default security
// group. A default security group includes a default rule that grants
// instances unrestricted network access to each other. You can add or
// remove rules from your security groups using
// AuthorizeSecurityGroupIngress , AuthorizeSecurityGroupEgress ,
// RevokeSecurityGroupIngress , and RevokeSecurityGroupEgress
func (c *EC2) CreateSecurityGroup(req *CreateSecurityGroupRequest) (resp *CreateSecurityGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateSecurityGroupResult{}
	err = c.client.Do("CreateSecurityGroup", "POST", "/", req, resp)
	return
}

// CreateSnapshot creates a snapshot of an Amazon EBS volume and stores it
// in Amazon S3. You can use snapshots for backups, to make copies of
// Amazon EBS volumes, and to save data before shutting down an instance.
// When a snapshot is created, any AWS Marketplace product codes that are
// associated with the source volume are propagated to the snapshot. You
// can take a snapshot of an attached volume that is in use. However,
// snapshots only capture data that has been written to your Amazon EBS
// volume at the time the snapshot command is issued; this may exclude any
// data that has been cached by any applications or the operating system.
// If you can pause any file systems on the volume long enough to take a
// snapshot, your snapshot should be complete. However, if you cannot pause
// all file writes to the volume, you should unmount the volume from within
// the instance, issue the snapshot command, and then remount the volume to
// ensure a consistent and complete snapshot. You may remount and use your
// volume while the snapshot status is pending To create a snapshot for
// Amazon EBS volumes that serve as root devices, you should stop the
// instance before taking the snapshot. Snapshots that are taken from
// encrypted volumes are automatically encrypted. Volumes that are created
// from encrypted snapshots are also automatically encrypted. Your
// encrypted volumes and any associated snapshots always remain protected.
// For more information, see Amazon Elastic Block Store and Amazon EBS
// Encryption in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateSnapshot(req *CreateSnapshotRequest) (resp *Snapshot, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &Snapshot{}
	err = c.client.Do("CreateSnapshot", "POST", "/", req, resp)
	return
}

// CreateSpotDatafeedSubscription creates a datafeed for Spot Instances,
// enabling you to view Spot Instance usage logs. You can create one data
// feed per AWS account. For more information, see Spot Instances in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateSpotDatafeedSubscription(req *CreateSpotDatafeedSubscriptionRequest) (resp *CreateSpotDatafeedSubscriptionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateSpotDatafeedSubscriptionResult{}
	err = c.client.Do("CreateSpotDatafeedSubscription", "POST", "/", req, resp)
	return
}

// CreateSubnet creates a subnet in an existing When you create each
// subnet, you provide the VPC ID and the block you want for the subnet.
// After you create a subnet, you can't change its block. The subnet's
// block can be the same as the VPC's block (assuming you want only a
// single subnet in the or a subset of the VPC's block. If you create more
// than one subnet in a the subnets' blocks must not overlap. The smallest
// subnet (and you can create uses a /28 netmask (16 IP addresses), and the
// largest uses a /16 netmask (65,536 IP addresses). AWS reserves both the
// first four and the last IP address in each subnet's block. They're not
// available for use. If you add more than one subnet to a they're set up
// in a star topology with a logical router in the middle. If you launch an
// instance in a VPC using an Amazon EBS-backed the IP address doesn't
// change if you stop and restart the instance (unlike a similar instance
// launched outside a which gets a new IP address when restarted). It's
// therefore possible to have a subnet with no running instances (they're
// all stopped), but no remaining IP addresses available. For more
// information about subnets, see Your VPC and Subnets in the Amazon
// Virtual Private Cloud User Guide
func (c *EC2) CreateSubnet(req *CreateSubnetRequest) (resp *CreateSubnetResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateSubnetResult{}
	err = c.client.Do("CreateSubnet", "POST", "/", req, resp)
	return
}

// CreateTags adds or overwrites one or more tags for the specified EC2
// resource or resources. Each resource can have a maximum of 10 tags. Each
// tag consists of a key and optional value. Tag keys must be unique per
// resource. For more information about tags, see Tagging Your Resources in
// the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateTags(req *CreateTagsRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreateTags", "POST", "/", req, nil)
	return
}

// CreateVolume creates an Amazon EBS volume that can be attached to an
// instance in the same Availability Zone. The volume is created in the
// specified region. You can create a new empty volume or restore a volume
// from an Amazon EBS snapshot. Any AWS Marketplace product codes from the
// snapshot are propagated to the volume. You can create encrypted volumes
// with the Encrypted parameter. Encrypted volumes may only be attached to
// instances that support Amazon EBS encryption. Volumes that are created
// from encrypted snapshots are also automatically encrypted. For more
// information, see Amazon EBS Encryption in the Amazon Elastic Compute
// Cloud User Guide For more information, see Creating or Restoring an
// Amazon EBS Volume in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) CreateVolume(req *CreateVolumeRequest) (resp *Volume, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &Volume{}
	err = c.client.Do("CreateVolume", "POST", "/", req, resp)
	return
}

// CreateVPC creates a VPC with the specified block. The smallest VPC you
// can create uses a /28 netmask (16 IP addresses), and the largest uses a
// /16 netmask (65,536 IP addresses). To help you decide how big to make
// your see Your VPC and Subnets in the Amazon Virtual Private Cloud User
// Guide By default, each instance you launch in the VPC has the default
// options, which includes only a default DNS server that we provide
// (AmazonProvidedDNS). For more information about options, see Options
// Sets in the Amazon Virtual Private Cloud User Guide
func (c *EC2) CreateVPC(req *CreateVPCRequest) (resp *CreateVPCResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateVPCResult{}
	err = c.client.Do("CreateVpc", "POST", "/", req, resp)
	return
}

// CreateVPCPeeringConnection requests a VPC peering connection between two
// VPCs: a requester VPC that you own and a peer VPC with which to create
// the connection. The peer VPC can belong to another AWS account. The
// requester VPC and peer VPC cannot have overlapping blocks. The owner of
// the peer VPC must accept the peering request to activate the peering
// connection. The VPC peering connection request expires after 7 days,
// after which it cannot be accepted or rejected. A
// CreateVpcPeeringConnection request between VPCs with overlapping blocks
// results in the VPC peering connection having a status of failed
func (c *EC2) CreateVPCPeeringConnection(req *CreateVPCPeeringConnectionRequest) (resp *CreateVPCPeeringConnectionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateVPCPeeringConnectionResult{}
	err = c.client.Do("CreateVpcPeeringConnection", "POST", "/", req, resp)
	return
}

// CreateVPNConnection creates a VPN connection between an existing virtual
// private gateway and a VPN customer gateway. The only supported
// connection type is ipsec.1 The response includes information that you
// need to give to your network administrator to configure your customer
// gateway. We strongly recommend that you use when calling this operation
// because the response contains sensitive cryptographic information for
// configuring your customer gateway. If you decide to shut down your VPN
// connection for any reason and later create a new VPN connection, you
// must reconfigure your customer gateway with the new information returned
// from this call. For more information about VPN connections, see Adding a
// Hardware Virtual Private Gateway to Your in the Amazon Virtual Private
// Cloud User Guide
func (c *EC2) CreateVPNConnection(req *CreateVPNConnectionRequest) (resp *CreateVPNConnectionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateVPNConnectionResult{}
	err = c.client.Do("CreateVpnConnection", "POST", "/", req, resp)
	return
}

// CreateVPNConnectionRoute creates a static route associated with a VPN
// connection between an existing virtual private gateway and a VPN
// customer gateway. The static route allows traffic to be routed from the
// virtual private gateway to the VPN customer gateway. For more
// information about VPN connections, see Adding a Hardware Virtual Private
// Gateway to Your in the Amazon Virtual Private Cloud User Guide
func (c *EC2) CreateVPNConnectionRoute(req *CreateVPNConnectionRouteRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreateVpnConnectionRoute", "POST", "/", req, nil)
	return
}

// CreateVPNGateway creates a virtual private gateway. A virtual private
// gateway is the endpoint on the VPC side of your VPN connection. You can
// create a virtual private gateway before creating the VPC itself. For
// more information about virtual private gateways, see Adding a Hardware
// Virtual Private Gateway to Your in the Amazon Virtual Private Cloud User
// Guide
func (c *EC2) CreateVPNGateway(req *CreateVPNGatewayRequest) (resp *CreateVPNGatewayResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateVPNGatewayResult{}
	err = c.client.Do("CreateVpnGateway", "POST", "/", req, resp)
	return
}

// DeleteCustomerGateway deletes the specified customer gateway. You must
// delete the VPN connection before you can delete the customer gateway.
func (c *EC2) DeleteCustomerGateway(req *DeleteCustomerGatewayRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteCustomerGateway", "POST", "/", req, nil)
	return
}

// DeleteDHCPOptions deletes the specified set of options. You must
// disassociate the set of options before you can delete it. You can
// disassociate the set of options by associating either a new set of
// options or the default set of options with the
func (c *EC2) DeleteDHCPOptions(req *DeleteDHCPOptionsRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteDhcpOptions", "POST", "/", req, nil)
	return
}

// DeleteInternetGateway deletes the specified Internet gateway. You must
// detach the Internet gateway from the VPC before you can delete it.
func (c *EC2) DeleteInternetGateway(req *DeleteInternetGatewayRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteInternetGateway", "POST", "/", req, nil)
	return
}

// DeleteKeyPair deletes the specified key pair, by removing the public key
// from Amazon EC2.
func (c *EC2) DeleteKeyPair(req *DeleteKeyPairRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteKeyPair", "POST", "/", req, nil)
	return
}

// DeleteNetworkACL deletes the specified network You can't delete the ACL
// if it's associated with any subnets. You can't delete the default
// network
func (c *EC2) DeleteNetworkACL(req *DeleteNetworkACLRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteNetworkAcl", "POST", "/", req, nil)
	return
}

// DeleteNetworkACLEntry deletes the specified ingress or egress entry
// (rule) from the specified network
func (c *EC2) DeleteNetworkACLEntry(req *DeleteNetworkACLEntryRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteNetworkAclEntry", "POST", "/", req, nil)
	return
}

// DeleteNetworkInterface deletes the specified network interface. You must
// detach the network interface before you can delete it.
func (c *EC2) DeleteNetworkInterface(req *DeleteNetworkInterfaceRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteNetworkInterface", "POST", "/", req, nil)
	return
}

// DeletePlacementGroup deletes the specified placement group. You must
// terminate all instances in the placement group before you can delete the
// placement group. For more information about placement groups and cluster
// instances, see Cluster Instances in the Amazon Elastic Compute Cloud
// User Guide
func (c *EC2) DeletePlacementGroup(req *DeletePlacementGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeletePlacementGroup", "POST", "/", req, nil)
	return
}

// DeleteRoute deletes the specified route from the specified route table.
func (c *EC2) DeleteRoute(req *DeleteRouteRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteRoute", "POST", "/", req, nil)
	return
}

// DeleteRouteTable deletes the specified route table. You must
// disassociate the route table from any subnets before you can delete it.
// You can't delete the main route table.
func (c *EC2) DeleteRouteTable(req *DeleteRouteTableRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteRouteTable", "POST", "/", req, nil)
	return
}

// DeleteSecurityGroup deletes a security group. If you attempt to delete a
// security group that is associated with an instance, or is referenced by
// another security group, the operation fails with InvalidGroup.InUse in
// EC2-Classic or DependencyViolation in EC2-VPC.
func (c *EC2) DeleteSecurityGroup(req *DeleteSecurityGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteSecurityGroup", "POST", "/", req, nil)
	return
}

// DeleteSnapshot deletes the specified snapshot. When you make periodic
// snapshots of a volume, the snapshots are incremental, and only the
// blocks on the device that have changed since your last snapshot are
// saved in the new snapshot. When you delete a snapshot, only the data not
// needed for any other snapshot is removed. So regardless of which prior
// snapshots have been deleted, all active snapshots will have access to
// all the information needed to restore the volume. You cannot delete a
// snapshot of the root device of an Amazon EBS volume used by a registered
// You must first de-register the AMI before you can delete the snapshot.
// For more information, see Deleting an Amazon EBS Snapshot in the Amazon
// Elastic Compute Cloud User Guide
func (c *EC2) DeleteSnapshot(req *DeleteSnapshotRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteSnapshot", "POST", "/", req, nil)
	return
}

// DeleteSpotDatafeedSubscription deletes the datafeed for Spot Instances.
// For more information, see Spot Instances in the Amazon Elastic Compute
// Cloud User Guide
func (c *EC2) DeleteSpotDatafeedSubscription(req *DeleteSpotDatafeedSubscriptionRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteSpotDatafeedSubscription", "POST", "/", req, nil)
	return
}

// DeleteSubnet deletes the specified subnet. You must terminate all
// running instances in the subnet before you can delete the subnet.
func (c *EC2) DeleteSubnet(req *DeleteSubnetRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteSubnet", "POST", "/", req, nil)
	return
}

// DeleteTags deletes the specified set of tags from the specified set of
// resources. This call is designed to follow a DescribeTags request. For
// more information about tags, see Tagging Your Resources in the Amazon
// Elastic Compute Cloud User Guide
func (c *EC2) DeleteTags(req *DeleteTagsRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteTags", "POST", "/", req, nil)
	return
}

// DeleteVolume deletes the specified Amazon EBS volume. The volume must be
// in the available state (not attached to an instance). The volume may
// remain in the deleting state for several minutes. For more information,
// see Deleting an Amazon EBS Volume in the Amazon Elastic Compute Cloud
// User Guide
func (c *EC2) DeleteVolume(req *DeleteVolumeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteVolume", "POST", "/", req, nil)
	return
}

// DeleteVPC deletes the specified You must detach or delete all gateways
// and resources that are associated with the VPC before you can delete it.
// For example, you must terminate all instances running in the delete all
// security groups associated with the VPC (except the default one), delete
// all route tables associated with the VPC (except the default one), and
// so on.
func (c *EC2) DeleteVPC(req *DeleteVPCRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteVpc", "POST", "/", req, nil)
	return
}

// DeleteVPCPeeringConnection deletes a VPC peering connection. Either the
// owner of the requester VPC or the owner of the peer VPC can delete the
// VPC peering connection if it's in the active state. The owner of the
// requester VPC can delete a VPC peering connection in the
// pending-acceptance state.
func (c *EC2) DeleteVPCPeeringConnection(req *DeleteVPCPeeringConnectionRequest) (resp *DeleteVPCPeeringConnectionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteVPCPeeringConnectionResult{}
	err = c.client.Do("DeleteVpcPeeringConnection", "POST", "/", req, resp)
	return
}

// DeleteVPNConnection deletes the specified VPN connection. If you're
// deleting the VPC and its associated components, we recommend that you
// detach the virtual private gateway from the VPC and delete the VPC
// before deleting the VPN connection. If you believe that the tunnel
// credentials for your VPN connection have been compromised, you can
// delete the VPN connection and create a new one that has new keys,
// without needing to delete the VPC or virtual private gateway. If you
// create a new VPN connection, you must reconfigure the customer gateway
// using the new configuration information returned with the new VPN
// connection
func (c *EC2) DeleteVPNConnection(req *DeleteVPNConnectionRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteVpnConnection", "POST", "/", req, nil)
	return
}

// DeleteVPNConnectionRoute deletes the specified static route associated
// with a VPN connection between an existing virtual private gateway and a
// VPN customer gateway. The static route allows traffic to be routed from
// the virtual private gateway to the VPN customer gateway.
func (c *EC2) DeleteVPNConnectionRoute(req *DeleteVPNConnectionRouteRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteVpnConnectionRoute", "POST", "/", req, nil)
	return
}

// DeleteVPNGateway deletes the specified virtual private gateway. We
// recommend that before you delete a virtual private gateway, you detach
// it from the VPC and delete the VPN connection. Note that you don't need
// to delete the virtual private gateway if you plan to delete and recreate
// the VPN connection between your VPC and your network.
func (c *EC2) DeleteVPNGateway(req *DeleteVPNGatewayRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteVpnGateway", "POST", "/", req, nil)
	return
}

// DeregisterImage deregisters the specified After you deregister an it
// can't be used to launch new instances. This command does not delete the
func (c *EC2) DeregisterImage(req *DeregisterImageRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeregisterImage", "POST", "/", req, nil)
	return
}

// DescribeAccountAttributes describes the specified attribute of your AWS
// account.
func (c *EC2) DescribeAccountAttributes(req *DescribeAccountAttributesRequest) (resp *DescribeAccountAttributesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeAccountAttributesResult{}
	err = c.client.Do("DescribeAccountAttributes", "POST", "/", req, resp)
	return
}

// DescribeAddresses describes one or more of your Elastic IP addresses. An
// Elastic IP address is for use in either the EC2-Classic platform or in a
// For more information, see Elastic IP Addresses in the Amazon Elastic
// Compute Cloud User Guide
func (c *EC2) DescribeAddresses(req *DescribeAddressesRequest) (resp *DescribeAddressesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeAddressesResult{}
	err = c.client.Do("DescribeAddresses", "POST", "/", req, resp)
	return
}

// DescribeAvailabilityZones describes one or more of the Availability
// Zones that are available to you. The results include zones only for the
// region you're currently using. If there is an event impacting an
// Availability Zone, you can use this request to view the state and any
// provided message for that Availability Zone. For more information, see
// Regions and Availability Zones in the Amazon Elastic Compute Cloud User
// Guide
func (c *EC2) DescribeAvailabilityZones(req *DescribeAvailabilityZonesRequest) (resp *DescribeAvailabilityZonesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeAvailabilityZonesResult{}
	err = c.client.Do("DescribeAvailabilityZones", "POST", "/", req, resp)
	return
}

// DescribeBundleTasks describes one or more of your bundling tasks.
// Completed bundle tasks are listed for only a limited time. If your
// bundle task is no longer in the list, you can still register an AMI from
// it. Just use RegisterImage with the Amazon S3 bucket name and image
// manifest name you provided to the bundle task.
func (c *EC2) DescribeBundleTasks(req *DescribeBundleTasksRequest) (resp *DescribeBundleTasksResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeBundleTasksResult{}
	err = c.client.Do("DescribeBundleTasks", "POST", "/", req, resp)
	return
}

// DescribeConversionTasks describes one or more of your conversion tasks.
// For more information, see Using the Command Line Tools to Import Your
// Virtual Machine to Amazon EC2 in the Amazon Elastic Compute Cloud User
// Guide
func (c *EC2) DescribeConversionTasks(req *DescribeConversionTasksRequest) (resp *DescribeConversionTasksResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeConversionTasksResult{}
	err = c.client.Do("DescribeConversionTasks", "POST", "/", req, resp)
	return
}

// DescribeCustomerGateways describes one or more of your VPN customer
// gateways. For more information about VPN customer gateways, see Adding a
// Hardware Virtual Private Gateway to Your in the Amazon Virtual Private
// Cloud User Guide
func (c *EC2) DescribeCustomerGateways(req *DescribeCustomerGatewaysRequest) (resp *DescribeCustomerGatewaysResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeCustomerGatewaysResult{}
	err = c.client.Do("DescribeCustomerGateways", "POST", "/", req, resp)
	return
}

// DescribeDHCPOptions describes one or more of your options sets. For more
// information about options sets, see Options Sets in the Amazon Virtual
// Private Cloud User Guide
func (c *EC2) DescribeDHCPOptions(req *DescribeDHCPOptionsRequest) (resp *DescribeDHCPOptionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeDHCPOptionsResult{}
	err = c.client.Do("DescribeDhcpOptions", "POST", "/", req, resp)
	return
}

// DescribeExportTasks is undocumented.
func (c *EC2) DescribeExportTasks(req *DescribeExportTasksRequest) (resp *DescribeExportTasksResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeExportTasksResult{}
	err = c.client.Do("DescribeExportTasks", "POST", "/", req, resp)
	return
}

// DescribeImageAttribute describes the specified attribute of the
// specified You can specify only one attribute at a time.
func (c *EC2) DescribeImageAttribute(req *DescribeImageAttributeRequest) (resp *ImageAttribute, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ImageAttribute{}
	err = c.client.Do("DescribeImageAttribute", "POST", "/", req, resp)
	return
}

// DescribeImages describes one or more of the images (AMIs, AKIs, and
// ARIs) available to you. Images available to you include public images,
// private images that you own, and private images owned by other AWS
// accounts but for which you have explicit launch permissions.
// Deregistered images are included in the returned results for an
// unspecified interval after deregistration.
func (c *EC2) DescribeImages(req *DescribeImagesRequest) (resp *DescribeImagesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeImagesResult{}
	err = c.client.Do("DescribeImages", "POST", "/", req, resp)
	return
}

// DescribeInstanceAttribute describes the specified attribute of the
// specified instance. You can specify only one attribute at a time. Valid
// attribute values are: instanceType | kernel | ramdisk | userData |
// disableApiTermination | instanceInitiatedShutdownBehavior |
// rootDeviceName | blockDeviceMapping | productCodes | sourceDestCheck |
// groupSet | ebsOptimized | sriovNetSupport
func (c *EC2) DescribeInstanceAttribute(req *DescribeInstanceAttributeRequest) (resp *InstanceAttribute, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &InstanceAttribute{}
	err = c.client.Do("DescribeInstanceAttribute", "POST", "/", req, resp)
	return
}

// DescribeInstanceStatus describes the status of one or more instances,
// including any scheduled events. Instance status has two main components:
// System Status reports impaired functionality that stems from issues
// related to the systems that support an instance, such as such as
// hardware failures and network connectivity problems. This call reports
// such problems as impaired reachability. Instance Status reports impaired
// functionality that arises from problems internal to the instance. This
// call reports such problems as impaired reachability. Instance status
// provides information about four types of scheduled events for an
// instance that may require your attention: Scheduled Reboot: When Amazon
// EC2 determines that an instance must be rebooted, the instances status
// returns one of two event codes: system-reboot or instance-reboot .
// System reboot commonly occurs if certain maintenance or upgrade
// operations require a reboot of the underlying host that supports an
// instance. Instance reboot commonly occurs if the instance must be
// rebooted, rather than the underlying host. Rebooting events include a
// scheduled start and end time. System Maintenance: When Amazon EC2
// determines that an instance requires maintenance that requires power or
// network impact, the instance status is the event code system-maintenance
// . System maintenance is either power maintenance or network maintenance.
// For power maintenance, your instance will be unavailable for a brief
// period of time and then rebooted. For network maintenance, your instance
// will experience a brief loss of network connectivity. System maintenance
// events include a scheduled start and end time. You will also be notified
// by email if one of your instances is set for system maintenance. The
// email message indicates when your instance is scheduled for maintenance.
// Scheduled Retirement: When Amazon EC2 determines that an instance must
// be shut down, the instance status is the event code instance-retirement
// . Retirement commonly occurs when the underlying host is degraded and
// must be replaced. Retirement events include a scheduled start and end
// time. You will also be notified by email if one of your instances is set
// to retiring. The email message indicates when your instance will be
// permanently retired. Scheduled Stop: When Amazon EC2 determines that an
// instance must be shut down, the instances status returns an event code
// called instance-stop . Stop events include a scheduled start and end
// time. You will also be notified by email if one of your instances is set
// to stop. The email message indicates when your instance will be stopped.
// When your instance is retired, it will either be terminated (if its root
// device type is the instance-store) or stopped (if its root device type
// is an EBS volume). Instances stopped due to retirement will not be
// restarted, but you can do so manually. You can also avoid retirement of
// EBS-backed instances by manually restarting your instance when its event
// code is instance-retirement . This ensures that your instance is started
// on a different underlying host. For more information about failed status
// checks, see Troubleshooting Instances with Failed Status Checks in the
// Amazon Elastic Compute Cloud User Guide . For more information about
// working with scheduled events, see Working with an Instance That Has a
// Scheduled Event in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeInstanceStatus(req *DescribeInstanceStatusRequest) (resp *DescribeInstanceStatusResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeInstanceStatusResult{}
	err = c.client.Do("DescribeInstanceStatus", "POST", "/", req, resp)
	return
}

// DescribeInstances describes one or more of your instances. If you
// specify one or more instance IDs, Amazon EC2 returns information for
// those instances. If you do not specify instance IDs, Amazon EC2 returns
// information for all relevant instances. If you specify an instance ID
// that is not valid, an error is returned. If you specify an instance that
// you do not own, it is not included in the returned results. Recently
// terminated instances might appear in the returned results. This interval
// is usually less than one hour.
func (c *EC2) DescribeInstances(req *DescribeInstancesRequest) (resp *DescribeInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeInstancesResult{}
	err = c.client.Do("DescribeInstances", "POST", "/", req, resp)
	return
}

// DescribeInternetGateways is undocumented.
func (c *EC2) DescribeInternetGateways(req *DescribeInternetGatewaysRequest) (resp *DescribeInternetGatewaysResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeInternetGatewaysResult{}
	err = c.client.Do("DescribeInternetGateways", "POST", "/", req, resp)
	return
}

// DescribeKeyPairs describes one or more of your key pairs. For more
// information about key pairs, see Key Pairs in the Amazon Elastic Compute
// Cloud User Guide
func (c *EC2) DescribeKeyPairs(req *DescribeKeyPairsRequest) (resp *DescribeKeyPairsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeKeyPairsResult{}
	err = c.client.Do("DescribeKeyPairs", "POST", "/", req, resp)
	return
}

// DescribeNetworkACLs describes one or more of your network ACLs. For more
// information about network ACLs, see Network ACLs in the Amazon Virtual
// Private Cloud User Guide
func (c *EC2) DescribeNetworkACLs(req *DescribeNetworkACLsRequest) (resp *DescribeNetworkACLsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeNetworkACLsResult{}
	err = c.client.Do("DescribeNetworkAcls", "POST", "/", req, resp)
	return
}

// DescribeNetworkInterfaceAttribute describes a network interface
// attribute. You can specify only one attribute at a time.
func (c *EC2) DescribeNetworkInterfaceAttribute(req *DescribeNetworkInterfaceAttributeRequest) (resp *DescribeNetworkInterfaceAttributeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeNetworkInterfaceAttributeResult{}
	err = c.client.Do("DescribeNetworkInterfaceAttribute", "POST", "/", req, resp)
	return
}

// DescribeNetworkInterfaces is undocumented.
func (c *EC2) DescribeNetworkInterfaces(req *DescribeNetworkInterfacesRequest) (resp *DescribeNetworkInterfacesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeNetworkInterfacesResult{}
	err = c.client.Do("DescribeNetworkInterfaces", "POST", "/", req, resp)
	return
}

// DescribePlacementGroups describes one or more of your placement groups.
// For more information about placement groups and cluster instances, see
// Cluster Instances in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribePlacementGroups(req *DescribePlacementGroupsRequest) (resp *DescribePlacementGroupsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribePlacementGroupsResult{}
	err = c.client.Do("DescribePlacementGroups", "POST", "/", req, resp)
	return
}

// DescribeRegions describes one or more regions that are currently
// available to you. For a list of the regions supported by Amazon EC2, see
// Regions and Endpoints
func (c *EC2) DescribeRegions(req *DescribeRegionsRequest) (resp *DescribeRegionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeRegionsResult{}
	err = c.client.Do("DescribeRegions", "POST", "/", req, resp)
	return
}

// DescribeReservedInstances describes one or more of the Reserved
// Instances that you purchased. For more information about Reserved
// Instances, see Reserved Instances in the Amazon Elastic Compute Cloud
// User Guide
func (c *EC2) DescribeReservedInstances(req *DescribeReservedInstancesRequest) (resp *DescribeReservedInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeReservedInstancesResult{}
	err = c.client.Do("DescribeReservedInstances", "POST", "/", req, resp)
	return
}

// DescribeReservedInstancesListings describes your account's Reserved
// Instance listings in the Reserved Instance Marketplace. The Reserved
// Instance Marketplace matches sellers who want to resell Reserved
// Instance capacity that they no longer need with buyers who want to
// purchase additional capacity. Reserved Instances bought and sold through
// the Reserved Instance Marketplace work like any other Reserved
// Instances. As a seller, you choose to list some or all of your Reserved
// Instances, and you specify the upfront price to receive for them. Your
// Reserved Instances are then listed in the Reserved Instance Marketplace
// and are available for purchase. As a buyer, you specify the
// configuration of the Reserved Instance to purchase, and the Marketplace
// matches what you're searching for with what's available. The Marketplace
// first sells the lowest priced Reserved Instances to you, and continues
// to sell available Reserved Instance listings to you until your demand is
// met. You are charged based on the total price of all of the listings
// that you purchase. For more information, see Reserved Instance
// Marketplace in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeReservedInstancesListings(req *DescribeReservedInstancesListingsRequest) (resp *DescribeReservedInstancesListingsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeReservedInstancesListingsResult{}
	err = c.client.Do("DescribeReservedInstancesListings", "POST", "/", req, resp)
	return
}

// DescribeReservedInstancesModifications describes the modifications made
// to your Reserved Instances. If no parameter is specified, information
// about all your Reserved Instances modification requests is returned. If
// a modification ID is specified, only information about the specific
// modification is returned. For more information, see Modifying Reserved
// Instances in the Amazon Elastic Compute Cloud User Guide.
func (c *EC2) DescribeReservedInstancesModifications(req *DescribeReservedInstancesModificationsRequest) (resp *DescribeReservedInstancesModificationsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeReservedInstancesModificationsResult{}
	err = c.client.Do("DescribeReservedInstancesModifications", "POST", "/", req, resp)
	return
}

// DescribeReservedInstancesOfferings describes Reserved Instance offerings
// that are available for purchase. With Reserved Instances, you purchase
// the right to launch instances for a period of time. During that time
// period, you do not receive insufficient capacity errors, and you pay a
// lower usage rate than the rate charged for On-Demand instances for the
// actual time used. For more information, see Reserved Instance
// Marketplace in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeReservedInstancesOfferings(req *DescribeReservedInstancesOfferingsRequest) (resp *DescribeReservedInstancesOfferingsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeReservedInstancesOfferingsResult{}
	err = c.client.Do("DescribeReservedInstancesOfferings", "POST", "/", req, resp)
	return
}

// DescribeRouteTables describes one or more of your route tables. For more
// information about route tables, see Route Tables in the Amazon Virtual
// Private Cloud User Guide
func (c *EC2) DescribeRouteTables(req *DescribeRouteTablesRequest) (resp *DescribeRouteTablesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeRouteTablesResult{}
	err = c.client.Do("DescribeRouteTables", "POST", "/", req, resp)
	return
}

// DescribeSecurityGroups describes one or more of your security groups. A
// security group is for use with instances either in the EC2-Classic
// platform or in a specific For more information, see Amazon EC2 Security
// Groups in the Amazon Elastic Compute Cloud User Guide and Security
// Groups for Your in the Amazon Virtual Private Cloud User Guide
func (c *EC2) DescribeSecurityGroups(req *DescribeSecurityGroupsRequest) (resp *DescribeSecurityGroupsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSecurityGroupsResult{}
	err = c.client.Do("DescribeSecurityGroups", "POST", "/", req, resp)
	return
}

// DescribeSnapshotAttribute describes the specified attribute of the
// specified snapshot. You can specify only one attribute at a time. For
// more information about Amazon EBS snapshots, see Amazon EBS Snapshots in
// the Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeSnapshotAttribute(req *DescribeSnapshotAttributeRequest) (resp *DescribeSnapshotAttributeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSnapshotAttributeResult{}
	err = c.client.Do("DescribeSnapshotAttribute", "POST", "/", req, resp)
	return
}

// DescribeSnapshots describes one or more of the Amazon EBS snapshots
// available to you. Available snapshots include public snapshots available
// for any AWS account to launch, private snapshots that you own, and
// private snapshots owned by another AWS account but for which you've been
// given explicit create volume permissions. The create volume permissions
// fall into the following categories: public : The owner of the snapshot
// granted create volume permissions for the snapshot to the all group. All
// AWS accounts have create volume permissions for these snapshots.
// explicit : The owner of the snapshot granted create volume permissions
// to a specific AWS account. implicit : An AWS account has implicit create
// volume permissions for all snapshots it owns. The list of snapshots
// returned can be modified by specifying snapshot IDs, snapshot owners, or
// AWS accounts with create volume permissions. If no options are
// specified, Amazon EC2 returns all snapshots for which you have create
// volume permissions. If you specify one or more snapshot IDs, only
// snapshots that have the specified IDs are returned. If you specify an
// invalid snapshot ID, an error is returned. If you specify a snapshot ID
// for which you do not have access, it is not included in the returned
// results. If you specify one or more snapshot owners, only snapshots from
// the specified owners and for which you have access are returned. The
// results can include the AWS account IDs of the specified owners, amazon
// for snapshots owned by Amazon, or self for snapshots that you own. If
// you specify a list of restorable users, only snapshots with create
// snapshot permissions for those users are returned. You can specify AWS
// account IDs (if you own the snapshots), self for snapshots for which you
// own or have explicit permissions, or all for public snapshots. For more
// information about Amazon EBS snapshots, see Amazon EBS Snapshots in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeSnapshots(req *DescribeSnapshotsRequest) (resp *DescribeSnapshotsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSnapshotsResult{}
	err = c.client.Do("DescribeSnapshots", "POST", "/", req, resp)
	return
}

// DescribeSpotDatafeedSubscription describes the datafeed for Spot
// Instances. For more information, see Spot Instances in the Amazon
// Elastic Compute Cloud User Guide
func (c *EC2) DescribeSpotDatafeedSubscription(req *DescribeSpotDatafeedSubscriptionRequest) (resp *DescribeSpotDatafeedSubscriptionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSpotDatafeedSubscriptionResult{}
	err = c.client.Do("DescribeSpotDatafeedSubscription", "POST", "/", req, resp)
	return
}

// DescribeSpotInstanceRequests describes the Spot Instance requests that
// belong to your account. Spot Instances are instances that Amazon EC2
// starts on your behalf when the maximum price that you specify exceeds
// the current Spot Price. Amazon EC2 periodically sets the Spot Price
// based on available Spot Instance capacity and current Spot Instance
// requests. For more information about Spot Instances, see Spot Instances
// in the Amazon Elastic Compute Cloud User Guide You can use
// DescribeSpotInstanceRequests to find a running Spot Instance by
// examining the response. If the status of the Spot Instance is fulfilled
// , the instance ID appears in the response and contains the identifier of
// the instance. Alternatively, you can use DescribeInstances with a filter
// to look for instances where the instance lifecycle is spot
func (c *EC2) DescribeSpotInstanceRequests(req *DescribeSpotInstanceRequestsRequest) (resp *DescribeSpotInstanceRequestsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSpotInstanceRequestsResult{}
	err = c.client.Do("DescribeSpotInstanceRequests", "POST", "/", req, resp)
	return
}

// DescribeSpotPriceHistory describes the Spot Price history. Spot
// Instances are instances that Amazon EC2 starts on your behalf when the
// maximum price that you specify exceeds the current Spot Price. Amazon
// EC2 periodically sets the Spot Price based on available Spot Instance
// capacity and current Spot Instance requests. For more information about
// Spot Instances, see Spot Instances in the Amazon Elastic Compute Cloud
// User Guide When you specify an Availability Zone, this operation
// describes the price history for the specified Availability Zone with the
// most recent set of prices listed first. If you don't specify an
// Availability Zone, you get the prices across all Availability Zones,
// starting with the most recent set. However, if you're using an API
// version earlier than 2011-05-15, you get the lowest price across the
// region for the specified time period. The prices returned are listed in
// chronological order, from the oldest to the most recent. When you
// specify the start and end time options, this operation returns two
// pieces of data: the prices of the instance types within the time range
// that you specified and the time when the price changed. The price is
// valid within the time period that you specified; the response merely
// indicates the last time that the price changed.
func (c *EC2) DescribeSpotPriceHistory(req *DescribeSpotPriceHistoryRequest) (resp *DescribeSpotPriceHistoryResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSpotPriceHistoryResult{}
	err = c.client.Do("DescribeSpotPriceHistory", "POST", "/", req, resp)
	return
}

// DescribeSubnets describes one or more of your subnets. For more
// information about subnets, see Your VPC and Subnets in the Amazon
// Virtual Private Cloud User Guide
func (c *EC2) DescribeSubnets(req *DescribeSubnetsRequest) (resp *DescribeSubnetsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSubnetsResult{}
	err = c.client.Do("DescribeSubnets", "POST", "/", req, resp)
	return
}

// DescribeTags describes one or more of the tags for your EC2 resources.
// For more information about tags, see Tagging Your Resources in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeTags(req *DescribeTagsRequest) (resp *DescribeTagsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeTagsResult{}
	err = c.client.Do("DescribeTags", "POST", "/", req, resp)
	return
}

// DescribeVolumeAttribute describes the specified attribute of the
// specified volume. You can specify only one attribute at a time. For more
// information about Amazon EBS volumes, see Amazon EBS Volumes in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeVolumeAttribute(req *DescribeVolumeAttributeRequest) (resp *DescribeVolumeAttributeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVolumeAttributeResult{}
	err = c.client.Do("DescribeVolumeAttribute", "POST", "/", req, resp)
	return
}

// DescribeVolumeStatus describes the status of the specified volumes.
// Volume status provides the result of the checks performed on your
// volumes to determine events that can impair the performance of your
// volumes. The performance of a volume can be affected if an issue occurs
// on the volume's underlying host. If the volume's underlying host
// experiences a power outage or system issue, after the system is
// restored, there could be data inconsistencies on the volume. Volume
// events notify you if this occurs. Volume actions notify you if any
// action needs to be taken in response to the event. The
// DescribeVolumeStatus operation provides the following information about
// the specified volumes: Status : Reflects the current status of the
// volume. The possible values are ok , impaired , warning , or
// insufficient-data . If all checks pass, the overall status of the volume
// is ok . If the check fails, the overall status is impaired . If the
// status is insufficient-data , then the checks may still be taking place
// on your volume at the time. We recommend that you retry the request. For
// more information on volume status, see Monitoring the Status of Your
// Volumes Events : Reflect the cause of a volume status and may require
// you to take action. For example, if your volume returns an impaired
// status, then the volume event might be potential-data-inconsistency .
// This means that your volume has been affected by an issue with the
// underlying host, has all I/O operations disabled, and may have
// inconsistent data. Actions : Reflect the actions you may have to take in
// response to an event. For example, if the status of the volume is
// impaired and the volume event shows potential-data-inconsistency , then
// the action shows enable-volume-io . This means that you may want to
// enable the I/O operations for the volume by calling the EnableVolumeIO
// action and then check the volume for data consistency. Volume status is
// based on the volume status checks, and does not reflect the volume
// state. Therefore, volume status does not indicate volumes in the error
// state (for example, when a volume is incapable of accepting
func (c *EC2) DescribeVolumeStatus(req *DescribeVolumeStatusRequest) (resp *DescribeVolumeStatusResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVolumeStatusResult{}
	err = c.client.Do("DescribeVolumeStatus", "POST", "/", req, resp)
	return
}

// DescribeVolumes describes the specified Amazon EBS volumes. If you are
// describing a long list of volumes, you can paginate the output to make
// the list more manageable. The MaxResults parameter sets the maximum
// number of results returned in a single page. If the list of results
// exceeds your MaxResults value, then that number of results is returned
// along with a NextToken value that can be passed to a subsequent
// DescribeVolumes request to retrieve the remaining results. For more
// information about Amazon EBS volumes, see Amazon EBS Volumes in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) DescribeVolumes(req *DescribeVolumesRequest) (resp *DescribeVolumesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVolumesResult{}
	err = c.client.Do("DescribeVolumes", "POST", "/", req, resp)
	return
}

// DescribeVPCAttribute describes the specified attribute of the specified
// You can specify only one attribute at a time.
func (c *EC2) DescribeVPCAttribute(req *DescribeVPCAttributeRequest) (resp *DescribeVPCAttributeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVPCAttributeResult{}
	err = c.client.Do("DescribeVpcAttribute", "POST", "/", req, resp)
	return
}

// DescribeVPCPeeringConnections describes one or more of your VPC peering
// connections.
func (c *EC2) DescribeVPCPeeringConnections(req *DescribeVPCPeeringConnectionsRequest) (resp *DescribeVPCPeeringConnectionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVPCPeeringConnectionsResult{}
	err = c.client.Do("DescribeVpcPeeringConnections", "POST", "/", req, resp)
	return
}

// DescribeVPCs is undocumented.
func (c *EC2) DescribeVPCs(req *DescribeVPCsRequest) (resp *DescribeVPCsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVPCsResult{}
	err = c.client.Do("DescribeVpcs", "POST", "/", req, resp)
	return
}

// DescribeVPNConnections describes one or more of your VPN connections.
// For more information about VPN connections, see Adding a Hardware
// Virtual Private Gateway to Your in the Amazon Virtual Private Cloud User
// Guide
func (c *EC2) DescribeVPNConnections(req *DescribeVPNConnectionsRequest) (resp *DescribeVPNConnectionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVPNConnectionsResult{}
	err = c.client.Do("DescribeVpnConnections", "POST", "/", req, resp)
	return
}

// DescribeVPNGateways describes one or more of your virtual private
// gateways. For more information about virtual private gateways, see
// Adding an IPsec Hardware VPN to Your in the Amazon Virtual Private Cloud
// User Guide
func (c *EC2) DescribeVPNGateways(req *DescribeVPNGatewaysRequest) (resp *DescribeVPNGatewaysResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeVPNGatewaysResult{}
	err = c.client.Do("DescribeVpnGateways", "POST", "/", req, resp)
	return
}

// DetachInternetGateway detaches an Internet gateway from a disabling
// connectivity between the Internet and the The VPC must not contain any
// running instances with Elastic IP addresses.
func (c *EC2) DetachInternetGateway(req *DetachInternetGatewayRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DetachInternetGateway", "POST", "/", req, nil)
	return
}

// DetachNetworkInterface is undocumented.
func (c *EC2) DetachNetworkInterface(req *DetachNetworkInterfaceRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DetachNetworkInterface", "POST", "/", req, nil)
	return
}

// DetachVolume detaches an Amazon EBS volume from an instance. Make sure
// to unmount any file systems on the device within your operating system
// before detaching the volume. Failure to do so results in the volume
// being stuck in a busy state while detaching. If an Amazon EBS volume is
// the root device of an instance, it can't be detached while the instance
// is running. To detach the root volume, stop the instance first. If the
// root volume is detached from an instance with an AWS Marketplace product
// code, then the AWS Marketplace product codes from that volume are no
// longer associated with the instance. For more information, see Detaching
// an Amazon EBS Volume in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) DetachVolume(req *DetachVolumeRequest) (resp *VolumeAttachment, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &VolumeAttachment{}
	err = c.client.Do("DetachVolume", "POST", "/", req, resp)
	return
}

// DetachVPNGateway detaches a virtual private gateway from a You do this
// if you're planning to turn off the VPC and not use it anymore. You can
// confirm a virtual private gateway has been completely detached from a
// VPC by describing the virtual private gateway (any attachments to the
// virtual private gateway are also described). You must wait for the
// attachment's state to switch to detached before you can delete the VPC
// or attach a different VPC to the virtual private gateway.
func (c *EC2) DetachVPNGateway(req *DetachVPNGatewayRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DetachVpnGateway", "POST", "/", req, nil)
	return
}

// DisableVGWRoutePropagation disables a virtual private gateway from
// propagating routes to a specified route table of a
func (c *EC2) DisableVGWRoutePropagation(req *DisableVGWRoutePropagationRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DisableVgwRoutePropagation", "POST", "/", req, nil)
	return
}

// DisassociateAddress disassociates an Elastic IP address from the
// instance or network interface it's associated with. An Elastic IP
// address is for use in either the EC2-Classic platform or in a For more
// information, see Elastic IP Addresses in the Amazon Elastic Compute
// Cloud User Guide This is an idempotent operation. If you perform the
// operation more than once, Amazon EC2 doesn't return an error.
func (c *EC2) DisassociateAddress(req *DisassociateAddressRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DisassociateAddress", "POST", "/", req, nil)
	return
}

// DisassociateRouteTable disassociates a subnet from a route table. After
// you perform this action, the subnet no longer uses the routes in the
// route table. Instead, it uses the routes in the VPC's main route table.
// For more information about route tables, see Route Tables in the Amazon
// Virtual Private Cloud User Guide
func (c *EC2) DisassociateRouteTable(req *DisassociateRouteTableRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DisassociateRouteTable", "POST", "/", req, nil)
	return
}

// EnableVGWRoutePropagation enables a virtual private gateway to propagate
// routes to the specified route table of a
func (c *EC2) EnableVGWRoutePropagation(req *EnableVGWRoutePropagationRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("EnableVgwRoutePropagation", "POST", "/", req, nil)
	return
}

// EnableVolumeIO enables I/O operations for a volume that had I/O
// operations disabled because the data on the volume was potentially
// inconsistent.
func (c *EC2) EnableVolumeIO(req *EnableVolumeIORequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("EnableVolumeIO", "POST", "/", req, nil)
	return
}

// GetConsoleOutput gets the console output for the specified instance.
// Instances do not have a physical monitor through which you can view
// their console output. They also lack physical controls that allow you to
// power up, reboot, or shut them down. To allow these actions, we provide
// them through the Amazon EC2 API and command line interface. Instance
// console output is buffered and posted shortly after instance boot,
// reboot, and termination. Amazon EC2 preserves the most recent 64 KB
// output which is available for at least one hour after the most recent
// post. For Linux/Unix instances, the instance console output displays the
// exact console output that would normally be displayed on a physical
// monitor attached to a machine. This output is buffered because the
// instance produces it and then posts it to a store where the instance's
// owner can retrieve it. For Windows instances, the instance console
// output displays the last three system event log errors.
func (c *EC2) GetConsoleOutput(req *GetConsoleOutputRequest) (resp *GetConsoleOutputResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetConsoleOutputResult{}
	err = c.client.Do("GetConsoleOutput", "POST", "/", req, resp)
	return
}

// GetPasswordData retrieves the encrypted administrator password for an
// instance running Windows. The Windows password is generated at boot if
// the EC2Config service plugin, Ec2SetPassword , is enabled. This usually
// only happens the first time an AMI is launched, and then Ec2SetPassword
// is automatically disabled. The password is not generated for rebundled
// AMIs unless Ec2SetPassword is enabled before bundling. The password is
// encrypted using the key pair that you specified when you launched the
// instance. You must provide the corresponding key pair file. Password
// generation and encryption takes a few moments. We recommend that you
// wait up to 15 minutes after launching an instance before trying to
// retrieve the generated password.
func (c *EC2) GetPasswordData(req *GetPasswordDataRequest) (resp *GetPasswordDataResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetPasswordDataResult{}
	err = c.client.Do("GetPasswordData", "POST", "/", req, resp)
	return
}

// ImportInstance creates an import instance task using metadata from the
// specified disk image. After importing the image, you then upload it
// using the command in the EC2 command line tools. For more information,
// see Using the Command Line Tools to Import Your Virtual Machine to
// Amazon EC2
func (c *EC2) ImportInstance(req *ImportInstanceRequest) (resp *ImportInstanceResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ImportInstanceResult{}
	err = c.client.Do("ImportInstance", "POST", "/", req, resp)
	return
}

// ImportKeyPair imports the public key from an RSA key pair that you
// created with a third-party tool. Compare this with CreateKeyPair , in
// which AWS creates the key pair and gives the keys to you keeps a copy of
// the public key). With ImportKeyPair, you create the key pair and give
// AWS just the public key. The private key is never transferred between
// you and For more information about key pairs, see Key Pairs in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) ImportKeyPair(req *ImportKeyPairRequest) (resp *ImportKeyPairResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ImportKeyPairResult{}
	err = c.client.Do("ImportKeyPair", "POST", "/", req, resp)
	return
}

// ImportVolume creates an import volume task using metadata from the
// specified disk image. After importing the image, you then upload it
// using the command in the Amazon EC2 command-line interface tools. For
// more information, see Using the Command Line Tools to Import Your
// Virtual Machine to Amazon EC2 in the Amazon Elastic Compute Cloud User
// Guide
func (c *EC2) ImportVolume(req *ImportVolumeRequest) (resp *ImportVolumeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ImportVolumeResult{}
	err = c.client.Do("ImportVolume", "POST", "/", req, resp)
	return
}

// ModifyImageAttribute modifies the specified attribute of the specified
// You can specify only one attribute at a time. AWS Marketplace product
// codes cannot be modified. Images with an AWS Marketplace product code
// cannot be made public.
func (c *EC2) ModifyImageAttribute(req *ModifyImageAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifyImageAttribute", "POST", "/", req, nil)
	return
}

// ModifyInstanceAttribute modifies the specified attribute of the
// specified instance. You can specify only one attribute at a time. To
// modify some attributes, the instance must be stopped. For more
// information, see Modifying Attributes of a Stopped Instance in the
// Amazon Elastic Compute Cloud User Guide
func (c *EC2) ModifyInstanceAttribute(req *ModifyInstanceAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifyInstanceAttribute", "POST", "/", req, nil)
	return
}

// ModifyNetworkInterfaceAttribute modifies the specified network interface
// attribute. You can specify only one attribute at a time.
func (c *EC2) ModifyNetworkInterfaceAttribute(req *ModifyNetworkInterfaceAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifyNetworkInterfaceAttribute", "POST", "/", req, nil)
	return
}

// ModifyReservedInstances modifies the Availability Zone, instance count,
// instance type, or network platform (EC2-Classic or EC2-VPC) of your
// Reserved Instances. The Reserved Instances to be modified must be
// identical, except for Availability Zone, network platform, and instance
// type. For more information, see Modifying Reserved Instances in the
// Amazon Elastic Compute Cloud User Guide.
func (c *EC2) ModifyReservedInstances(req *ModifyReservedInstancesRequest) (resp *ModifyReservedInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ModifyReservedInstancesResult{}
	err = c.client.Do("ModifyReservedInstances", "POST", "/", req, resp)
	return
}

// ModifySnapshotAttribute adds or removes permission settings for the
// specified snapshot. You may add or remove specified AWS account IDs from
// a snapshot's list of create volume permissions, but you cannot do both
// in a single API call. If you need to both add and remove account IDs for
// a snapshot, you must use multiple API calls. For more information on
// modifying snapshot permissions, see Sharing Snapshots in the Amazon
// Elastic Compute Cloud User Guide Snapshots with AWS Marketplace product
// codes cannot be made public.
func (c *EC2) ModifySnapshotAttribute(req *ModifySnapshotAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifySnapshotAttribute", "POST", "/", req, nil)
	return
}

// ModifySubnetAttribute is undocumented.
func (c *EC2) ModifySubnetAttribute(req *ModifySubnetAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifySubnetAttribute", "POST", "/", req, nil)
	return
}

// ModifyVolumeAttribute modifies a volume attribute. By default, all I/O
// operations for the volume are suspended when the data on the volume is
// determined to be potentially inconsistent, to prevent undetectable,
// latent data corruption. The I/O access to the volume can be resumed by
// first enabling I/O access and then checking the data consistency on your
// volume. You can change the default behavior to resume I/O operations. We
// recommend that you change this only for boot volumes or for volumes that
// are stateless or disposable.
func (c *EC2) ModifyVolumeAttribute(req *ModifyVolumeAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifyVolumeAttribute", "POST", "/", req, nil)
	return
}

// ModifyVPCAttribute is undocumented.
func (c *EC2) ModifyVPCAttribute(req *ModifyVPCAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ModifyVpcAttribute", "POST", "/", req, nil)
	return
}

// MonitorInstances enables monitoring for a running instance. For more
// information about monitoring instances, see Monitoring Your Instances
// and Volumes in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) MonitorInstances(req *MonitorInstancesRequest) (resp *MonitorInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &MonitorInstancesResult{}
	err = c.client.Do("MonitorInstances", "POST", "/", req, resp)
	return
}

// PurchaseReservedInstancesOffering purchases a Reserved Instance for use
// with your account. With Amazon EC2 Reserved Instances, you obtain a
// capacity reservation for a certain instance configuration over a
// specified period of time. You pay a lower usage rate than with On-Demand
// instances for the time that you actually use the capacity reservation.
// Use DescribeReservedInstancesOfferings to get a list of Reserved
// Instance offerings that match your specifications. After you've
// purchased a Reserved Instance, you can check for your new Reserved
// Instance with DescribeReservedInstances For more information, see
// Reserved Instances and Reserved Instance Marketplace in the Amazon
// Elastic Compute Cloud User Guide
func (c *EC2) PurchaseReservedInstancesOffering(req *PurchaseReservedInstancesOfferingRequest) (resp *PurchaseReservedInstancesOfferingResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &PurchaseReservedInstancesOfferingResult{}
	err = c.client.Do("PurchaseReservedInstancesOffering", "POST", "/", req, resp)
	return
}

// RebootInstances requests a reboot of one or more instances. This
// operation is asynchronous; it only queues a request to reboot the
// specified instances. The operation succeeds if the instances are valid
// and belong to you. Requests to reboot terminated instances are ignored.
// If a Linux/Unix instance does not cleanly shut down within four minutes,
// Amazon EC2 performs a hard reboot. For more information about
// troubleshooting, see Getting Console Output and Rebooting Instances in
// the Amazon Elastic Compute Cloud User Guide
func (c *EC2) RebootInstances(req *RebootInstancesRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RebootInstances", "POST", "/", req, nil)
	return
}

// RegisterImage registers an When you're creating an this is the final
// step you must complete before you can launch an instance from the For
// more information about creating AMIs, see Creating Your Own AMIs in the
// Amazon Elastic Compute Cloud User Guide For Amazon EBS-backed instances,
// CreateImage creates and registers the AMI in a single request, so you
// don't have to register the AMI yourself. You can also use RegisterImage
// to create an Amazon EBS-backed AMI from a snapshot of a root device
// volume. For more information, see Launching an Instance from a Snapshot
// in the Amazon Elastic Compute Cloud User Guide If needed, you can
// deregister an AMI at any time. Any modifications you make to an AMI
// backed by an instance store volume invalidates its registration. If you
// make changes to an image, deregister the previous image and register the
// new image. You can't register an image where a secondary (non-root)
// snapshot has AWS Marketplace product codes.
func (c *EC2) RegisterImage(req *RegisterImageRequest) (resp *RegisterImageResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RegisterImageResult{}
	err = c.client.Do("RegisterImage", "POST", "/", req, resp)
	return
}

// RejectVPCPeeringConnection rejects a VPC peering connection request. The
// VPC peering connection must be in the pending-acceptance state. Use the
// DescribeVpcPeeringConnections request to view your outstanding VPC
// peering connection requests. To delete an active VPC peering connection,
// or to delete a VPC peering connection request that you initiated, use
// DeleteVpcPeeringConnection
func (c *EC2) RejectVPCPeeringConnection(req *RejectVPCPeeringConnectionRequest) (resp *RejectVPCPeeringConnectionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RejectVPCPeeringConnectionResult{}
	err = c.client.Do("RejectVpcPeeringConnection", "POST", "/", req, resp)
	return
}

// ReleaseAddress releases the specified Elastic IP address. After
// releasing an Elastic IP address, it is released to the IP address pool
// and might be unavailable to you. Be sure to update your DNS records and
// any servers or devices that communicate with the address. If you attempt
// to release an Elastic IP address that you already released, you'll get
// an AuthFailure error if the address is already allocated to another AWS
// account. [EC2-Classic, default Releasing an Elastic IP address
// automatically disassociates it from any instance that it's associated
// with. To disassociate an Elastic IP address without releasing it, use
// DisassociateAddress [Nondefault You must use DisassociateAddress to
// disassociate the Elastic IP address before you try to release it.
// Otherwise, Amazon EC2 returns an error InvalidIPAddress.InUse
func (c *EC2) ReleaseAddress(req *ReleaseAddressRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ReleaseAddress", "POST", "/", req, nil)
	return
}

// ReplaceNetworkACLAssociation changes which network ACL a subnet is
// associated with. By default when you create a subnet, it's automatically
// associated with the default network For more information about network
// ACLs, see Network ACLs in the Amazon Virtual Private Cloud User Guide
func (c *EC2) ReplaceNetworkACLAssociation(req *ReplaceNetworkACLAssociationRequest) (resp *ReplaceNetworkACLAssociationResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ReplaceNetworkACLAssociationResult{}
	err = c.client.Do("ReplaceNetworkAclAssociation", "POST", "/", req, resp)
	return
}

// ReplaceNetworkACLEntry replaces an entry (rule) in a network For more
// information about network ACLs, see Network ACLs in the Amazon Virtual
// Private Cloud User Guide
func (c *EC2) ReplaceNetworkACLEntry(req *ReplaceNetworkACLEntryRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ReplaceNetworkAclEntry", "POST", "/", req, nil)
	return
}

// ReplaceRoute replaces an existing route within a route table in a You
// must provide only one of the following: Internet gateway or virtual
// private gateway, NAT instance, VPC peering connection, or network
// interface. For more information about route tables, see Route Tables in
// the Amazon Virtual Private Cloud User Guide
func (c *EC2) ReplaceRoute(req *ReplaceRouteRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ReplaceRoute", "POST", "/", req, nil)
	return
}

// ReplaceRouteTableAssociation changes the route table associated with a
// given subnet in a After the operation completes, the subnet uses the
// routes in the new route table it's associated with. For more information
// about route tables, see Route Tables in the Amazon Virtual Private Cloud
// User Guide You can also use ReplaceRouteTableAssociation to change which
// table is the main route table in the You just specify the main route
// table's association ID and the route table to be the new main route
// table.
func (c *EC2) ReplaceRouteTableAssociation(req *ReplaceRouteTableAssociationRequest) (resp *ReplaceRouteTableAssociationResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ReplaceRouteTableAssociationResult{}
	err = c.client.Do("ReplaceRouteTableAssociation", "POST", "/", req, resp)
	return
}

// ReportInstanceStatus submits feedback about the status of an instance.
// The instance must be in the running state. If your experience with the
// instance differs from the instance status returned by
// DescribeInstanceStatus , use ReportInstanceStatus to report your
// experience with the instance. Amazon EC2 collects this information to
// improve the accuracy of status checks. Use of this action does not
// change the value returned by DescribeInstanceStatus
func (c *EC2) ReportInstanceStatus(req *ReportInstanceStatusRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ReportInstanceStatus", "POST", "/", req, nil)
	return
}

// RequestSpotInstances creates a Spot Instance request. Spot Instances are
// instances that Amazon EC2 starts on your behalf when the maximum price
// that you specify exceeds the current Spot Price. Amazon EC2 periodically
// sets the Spot Price based on available Spot Instance capacity and
// current Spot Instance requests. For more information about Spot
// Instances, see Spot Instances in the Amazon Elastic Compute Cloud User
// Guide Users must be subscribed to the required product to run an
// instance with AWS Marketplace product codes.
func (c *EC2) RequestSpotInstances(req *RequestSpotInstancesRequest) (resp *RequestSpotInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RequestSpotInstancesResult{}
	err = c.client.Do("RequestSpotInstances", "POST", "/", req, resp)
	return
}

// ResetImageAttribute resets an attribute of an AMI to its default value.
func (c *EC2) ResetImageAttribute(req *ResetImageAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ResetImageAttribute", "POST", "/", req, nil)
	return
}

// ResetInstanceAttribute resets an attribute of an instance to its default
// value. To reset the kernel or ramdisk , the instance must be in a
// stopped state. To reset the SourceDestCheck , the instance can be either
// running or stopped. The SourceDestCheck attribute controls whether
// source/destination checking is enabled. The default value is true ,
// which means checking is enabled. This value must be false for a NAT
// instance to perform For more information, see NAT Instances in the
// Amazon Virtual Private Cloud User Guide
func (c *EC2) ResetInstanceAttribute(req *ResetInstanceAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ResetInstanceAttribute", "POST", "/", req, nil)
	return
}

// ResetNetworkInterfaceAttribute resets a network interface attribute. You
// can specify only one attribute at a time.
func (c *EC2) ResetNetworkInterfaceAttribute(req *ResetNetworkInterfaceAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ResetNetworkInterfaceAttribute", "POST", "/", req, nil)
	return
}

// ResetSnapshotAttribute resets permission settings for the specified
// snapshot. For more information on modifying snapshot permissions, see
// Sharing Snapshots in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) ResetSnapshotAttribute(req *ResetSnapshotAttributeRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ResetSnapshotAttribute", "POST", "/", req, nil)
	return
}

// RevokeSecurityGroupEgress removes one or more egress rules from a
// security group for EC2-VPC. The values that you specify in the revoke
// request (for example, ports) must match the existing rule's values for
// the rule to be revoked. Each rule consists of the protocol and the range
// or source security group. For the TCP and UDP protocols, you must also
// specify the destination port or range of ports. For the protocol, you
// must also specify the type and code. Rule changes are propagated to
// instances within the security group as quickly as possible. However, a
// small delay might occur.
func (c *EC2) RevokeSecurityGroupEgress(req *RevokeSecurityGroupEgressRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RevokeSecurityGroupEgress", "POST", "/", req, nil)
	return
}

// RevokeSecurityGroupIngress removes one or more ingress rules from a
// security group. The values that you specify in the revoke request (for
// example, ports) must match the existing rule's values for the rule to be
// removed. Each rule consists of the protocol and the range or source
// security group. For the TCP and UDP protocols, you must also specify the
// destination port or range of ports. For the protocol, you must also
// specify the type and code. Rule changes are propagated to instances
// within the security group as quickly as possible. However, a small delay
// might occur.
func (c *EC2) RevokeSecurityGroupIngress(req *RevokeSecurityGroupIngressRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RevokeSecurityGroupIngress", "POST", "/", req, nil)
	return
}

// RunInstances launches the specified number of instances using an AMI for
// which you have permissions. When you launch an instance, it enters the
// pending state. After the instance is ready for you, it enters the
// running state. To check the state of your instance, call
// DescribeInstances If you don't specify a security group when launching
// an instance, Amazon EC2 uses the default security group. For more
// information, see Security Groups in the Amazon Elastic Compute Cloud
// User Guide Linux instances have access to the public key of the key pair
// at boot. You can use this key to provide secure access to the instance.
// Amazon EC2 public images use this feature to provide secure access
// without passwords. For more information, see Key Pairs in the Amazon
// Elastic Compute Cloud User Guide You can provide optional user data when
// launching an instance. For more information, see Instance Metadata in
// the Amazon Elastic Compute Cloud User Guide If any of the AMIs have a
// product code attached for which the user has not subscribed,
// RunInstances fails. T2 instance types can only be launched into a If you
// do not have a default or if you do not specify a subnet ID in the
// request, RunInstances fails. For more information about troubleshooting,
// see What To Do If An Instance Immediately Terminates , and
// Troubleshooting Connecting to Your Instance in the Amazon Elastic
// Compute Cloud User Guide
func (c *EC2) RunInstances(req *RunInstancesRequest) (resp *Reservation, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &Reservation{}
	err = c.client.Do("RunInstances", "POST", "/", req, resp)
	return
}

// StartInstances starts an Amazon EBS-backed AMI that you've previously
// stopped. Instances that use Amazon EBS volumes as their root devices can
// be quickly stopped and started. When an instance is stopped, the compute
// resources are released and you are not billed for hourly instance usage.
// However, your root partition Amazon EBS volume remains, continues to
// persist your data, and you are charged for Amazon EBS volume usage. You
// can restart your instance at any time. Each time you transition an
// instance from stopped to started, Amazon EC2 charges a full instance
// hour, even if transitions happen multiple times within a single hour.
// Before stopping an instance, make sure it is in a state from which it
// can be restarted. Stopping an instance does not preserve data stored in
// Performing this operation on an instance that uses an instance store as
// its root device returns an error. For more information, see Stopping
// Instances in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) StartInstances(req *StartInstancesRequest) (resp *StartInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &StartInstancesResult{}
	err = c.client.Do("StartInstances", "POST", "/", req, resp)
	return
}

// StopInstances stops an Amazon EBS-backed instance. Each time you
// transition an instance from stopped to started, Amazon EC2 charges a
// full instance hour, even if transitions happen multiple times within a
// single hour. You can't start or stop Spot Instances. Instances that use
// Amazon EBS volumes as their root devices can be quickly stopped and
// started. When an instance is stopped, the compute resources are released
// and you are not billed for hourly instance usage. However, your root
// partition Amazon EBS volume remains, continues to persist your data, and
// you are charged for Amazon EBS volume usage. You can restart your
// instance at any time. Before stopping an instance, make sure it is in a
// state from which it can be restarted. Stopping an instance does not
// preserve data stored in Performing this operation on an instance that
// uses an instance store as its root device returns an error. You can
// stop, start, and terminate EBS-backed instances. You can only terminate
// instance store-backed instances. What happens to an instance differs if
// you stop it or terminate it. For example, when you stop an instance, the
// root device and any other devices attached to the instance persist. When
// you terminate an instance, the root device and any other devices
// attached during the instance launch are automatically deleted. For more
// information about the differences between stopping and terminating
// instances, see Instance Lifecycle in the Amazon Elastic Compute Cloud
// User Guide For more information about troubleshooting, see
// Troubleshooting Stopping Your Instance in the Amazon Elastic Compute
// Cloud User Guide
func (c *EC2) StopInstances(req *StopInstancesRequest) (resp *StopInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &StopInstancesResult{}
	err = c.client.Do("StopInstances", "POST", "/", req, resp)
	return
}

// TerminateInstances shuts down one or more instances. This operation is
// idempotent; if you terminate an instance more than once, each call
// succeeds. Terminated instances remain visible after termination (for
// approximately one hour). By default, Amazon EC2 deletes all Amazon EBS
// volumes that were attached when the instance launched. Volumes attached
// after instance launch continue running. You can stop, start, and
// terminate EBS-backed instances. You can only terminate instance
// store-backed instances. What happens to an instance differs if you stop
// it or terminate it. For example, when you stop an instance, the root
// device and any other devices attached to the instance persist. When you
// terminate an instance, the root device and any other devices attached
// during the instance launch are automatically deleted. For more
// information about the differences between stopping and terminating
// instances, see Instance Lifecycle in the Amazon Elastic Compute Cloud
// User Guide For more information about troubleshooting, see
// Troubleshooting Terminating Your Instance in the Amazon Elastic Compute
// Cloud User Guide
func (c *EC2) TerminateInstances(req *TerminateInstancesRequest) (resp *TerminateInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &TerminateInstancesResult{}
	err = c.client.Do("TerminateInstances", "POST", "/", req, resp)
	return
}

// UnassignPrivateIPAddresses unassigns one or more secondary private IP
// addresses from a network interface.
func (c *EC2) UnassignPrivateIPAddresses(req *UnassignPrivateIPAddressesRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UnassignPrivateIpAddresses", "POST", "/", req, nil)
	return
}

// UnmonitorInstances disables monitoring for a running instance. For more
// information about monitoring instances, see Monitoring Your Instances
// and Volumes in the Amazon Elastic Compute Cloud User Guide
func (c *EC2) UnmonitorInstances(req *UnmonitorInstancesRequest) (resp *UnmonitorInstancesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UnmonitorInstancesResult{}
	err = c.client.Do("UnmonitorInstances", "POST", "/", req, resp)
	return
}

// AcceptVPCPeeringConnectionRequest is undocumented.
type AcceptVPCPeeringConnectionRequest struct {
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCPeeringConnectionID aws.StringValue  `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *AcceptVPCPeeringConnectionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AcceptVPCPeeringConnectionResult is undocumented.
type AcceptVPCPeeringConnectionResult struct {
	VPCPeeringConnection *VPCPeeringConnection `ec2:"VpcPeeringConnection" xml:"vpcPeeringConnection"`
}

func (v *AcceptVPCPeeringConnectionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AccountAttribute is undocumented.
type AccountAttribute struct {
	AttributeName   aws.StringValue         `ec2:"AttributeName" xml:"attributeName"`
	AttributeValues []AccountAttributeValue `ec2:"AttributeValues" xml:"attributeValueSet>item"`
}

func (v *AccountAttribute) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	AccountAttributeNameDefaultVPC         = "default-vpc"
	AccountAttributeNameSupportedPlatforms = "supported-platforms"
)

// AccountAttributeValue is undocumented.
type AccountAttributeValue struct {
	AttributeValue aws.StringValue `ec2:"AttributeValue" xml:"attributeValue"`
}

func (v *AccountAttributeValue) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Address is undocumented.
type Address struct {
	AllocationID            aws.StringValue `ec2:"AllocationId" xml:"allocationId"`
	AssociationID           aws.StringValue `ec2:"AssociationId" xml:"associationId"`
	Domain                  aws.StringValue `ec2:"Domain" xml:"domain"`
	InstanceID              aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	NetworkInterfaceID      aws.StringValue `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	NetworkInterfaceOwnerID aws.StringValue `ec2:"NetworkInterfaceOwnerId" xml:"networkInterfaceOwnerId"`
	PrivateIPAddress        aws.StringValue `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	PublicIP                aws.StringValue `ec2:"PublicIp" xml:"publicIp"`
}

func (v *Address) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	DomainEnum := []string{
		DomainTypeStandard,
		DomainTypeVPC,
	}
	if err := model.ValidateEnum(v, "Domain", DomainEnum); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AllocateAddressRequest is undocumented.
type AllocateAddressRequest struct {
	Domain aws.StringValue  `ec2:"Domain" xml:"Domain"`
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *AllocateAddressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	DomainEnum := []string{
		DomainTypeStandard,
		DomainTypeVPC,
	}
	if err := model.ValidateEnum(v, "Domain", DomainEnum); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AllocateAddressResult is undocumented.
type AllocateAddressResult struct {
	AllocationID aws.StringValue `ec2:"AllocationId" xml:"allocationId"`
	Domain       aws.StringValue `ec2:"Domain" xml:"domain"`
	PublicIP     aws.StringValue `ec2:"PublicIp" xml:"publicIp"`
}

func (v *AllocateAddressResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	DomainEnum := []string{
		DomainTypeStandard,
		DomainTypeVPC,
	}
	if err := model.ValidateEnum(v, "Domain", DomainEnum); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ArchitectureValuesI386  = "i386"
	ArchitectureValuesX8664 = "x86_64"
)

// AssignPrivateIPAddressesRequest is undocumented.
type AssignPrivateIPAddressesRequest struct {
	AllowReassignment              aws.BooleanValue `ec2:"AllowReassignment" xml:"allowReassignment"`
	NetworkInterfaceID             aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	PrivateIPAddresses             []string         `ec2:"PrivateIpAddresses" xml:"privateIpAddress>PrivateIpAddress"`
	SecondaryPrivateIPAddressCount aws.IntegerValue `ec2:"SecondaryPrivateIpAddressCount" xml:"secondaryPrivateIpAddressCount"`
}

func (v *AssignPrivateIPAddressesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AssociateAddressRequest is undocumented.
type AssociateAddressRequest struct {
	AllocationID       aws.StringValue  `ec2:"AllocationId" xml:"AllocationId"`
	AllowReassociation aws.BooleanValue `ec2:"AllowReassociation" xml:"allowReassociation"`
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID         aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
	NetworkInterfaceID aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	PrivateIPAddress   aws.StringValue  `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	PublicIP           aws.StringValue  `ec2:"PublicIp" xml:"PublicIp"`
}

func (v *AssociateAddressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AssociateAddressResult is undocumented.
type AssociateAddressResult struct {
	AssociationID aws.StringValue `ec2:"AssociationId" xml:"associationId"`
}

func (v *AssociateAddressResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AssociateDHCPOptionsRequest is undocumented.
type AssociateDHCPOptionsRequest struct {
	DHCPOptionsID aws.StringValue  `ec2:"DhcpOptionsId" xml:"DhcpOptionsId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID         aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
}

func (v *AssociateDHCPOptionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DHCPOptionsID"); err != nil {
		errors["DHCPOptionsID"] = append(errors["DHCPOptionsID"], err)
	}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AssociateRouteTableRequest is undocumented.
type AssociateRouteTableRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	RouteTableID aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
	SubnetID     aws.StringValue  `ec2:"SubnetId" xml:"subnetId"`
}

func (v *AssociateRouteTableRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if err := model.ValidateRequired(v, "SubnetID"); err != nil {
		errors["SubnetID"] = append(errors["SubnetID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AssociateRouteTableResult is undocumented.
type AssociateRouteTableResult struct {
	AssociationID aws.StringValue `ec2:"AssociationId" xml:"associationId"`
}

func (v *AssociateRouteTableResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttachInternetGatewayRequest is undocumented.
type AttachInternetGatewayRequest struct {
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InternetGatewayID aws.StringValue  `ec2:"InternetGatewayId" xml:"internetGatewayId"`
	VPCID             aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *AttachInternetGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InternetGatewayID"); err != nil {
		errors["InternetGatewayID"] = append(errors["InternetGatewayID"], err)
	}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttachNetworkInterfaceRequest is undocumented.
type AttachNetworkInterfaceRequest struct {
	DeviceIndex        aws.IntegerValue `ec2:"DeviceIndex" xml:"deviceIndex"`
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID         aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
	NetworkInterfaceID aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
}

func (v *AttachNetworkInterfaceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DeviceIndex"); err != nil {
		errors["DeviceIndex"] = append(errors["DeviceIndex"], err)
	}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttachNetworkInterfaceResult is undocumented.
type AttachNetworkInterfaceResult struct {
	AttachmentID aws.StringValue `ec2:"AttachmentId" xml:"attachmentId"`
}

func (v *AttachNetworkInterfaceResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttachVolumeRequest is undocumented.
type AttachVolumeRequest struct {
	Device     aws.StringValue  `ec2:"Device" xml:"Device"`
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
	VolumeID   aws.StringValue  `ec2:"VolumeId" xml:"VolumeId"`
}

func (v *AttachVolumeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Device"); err != nil {
		errors["Device"] = append(errors["Device"], err)
	}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttachVPNGatewayRequest is undocumented.
type AttachVPNGatewayRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID        aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
	VPNGatewayID aws.StringValue  `ec2:"VpnGatewayId" xml:"VpnGatewayId"`
}

func (v *AttachVPNGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if err := model.ValidateRequired(v, "VPNGatewayID"); err != nil {
		errors["VPNGatewayID"] = append(errors["VPNGatewayID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttachVPNGatewayResult is undocumented.
type AttachVPNGatewayResult struct {
	VPCAttachment *VPCAttachment `ec2:"VpcAttachment" xml:"attachment"`
}

func (v *AttachVPNGatewayResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	AttachmentStatusAttached  = "attached"
	AttachmentStatusAttaching = "attaching"
	AttachmentStatusDetached  = "detached"
	AttachmentStatusDetaching = "detaching"
)

// AttributeBooleanValue is undocumented.
type AttributeBooleanValue struct {
	Value aws.BooleanValue `ec2:"Value" xml:"value"`
}

func (v *AttributeBooleanValue) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AttributeValue is undocumented.
type AttributeValue struct {
	Value aws.StringValue `ec2:"Value" xml:"value"`
}

func (v *AttributeValue) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AuthorizeSecurityGroupEgressRequest is undocumented.
type AuthorizeSecurityGroupEgressRequest struct {
	CIDRIP                     aws.StringValue  `ec2:"CidrIp" xml:"cidrIp"`
	DryRun                     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	FromPort                   aws.IntegerValue `ec2:"FromPort" xml:"fromPort"`
	GroupID                    aws.StringValue  `ec2:"GroupId" xml:"groupId"`
	IPPermissions              []IPPermission   `ec2:"IpPermissions" xml:"ipPermissions>item"`
	IPProtocol                 aws.StringValue  `ec2:"IpProtocol" xml:"ipProtocol"`
	SourceSecurityGroupName    aws.StringValue  `ec2:"SourceSecurityGroupName" xml:"sourceSecurityGroupName"`
	SourceSecurityGroupOwnerID aws.StringValue  `ec2:"SourceSecurityGroupOwnerId" xml:"sourceSecurityGroupOwnerId"`
	ToPort                     aws.IntegerValue `ec2:"ToPort" xml:"toPort"`
}

func (v *AuthorizeSecurityGroupEgressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupID"); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AuthorizeSecurityGroupIngressRequest is undocumented.
type AuthorizeSecurityGroupIngressRequest struct {
	CIDRIP                     aws.StringValue  `ec2:"CidrIp" xml:"CidrIp"`
	DryRun                     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	FromPort                   aws.IntegerValue `ec2:"FromPort" xml:"FromPort"`
	GroupID                    aws.StringValue  `ec2:"GroupId" xml:"GroupId"`
	GroupName                  aws.StringValue  `ec2:"GroupName" xml:"GroupName"`
	IPPermissions              []IPPermission   `ec2:"IpPermissions" xml:"IpPermissions>item"`
	IPProtocol                 aws.StringValue  `ec2:"IpProtocol" xml:"IpProtocol"`
	SourceSecurityGroupName    aws.StringValue  `ec2:"SourceSecurityGroupName" xml:"SourceSecurityGroupName"`
	SourceSecurityGroupOwnerID aws.StringValue  `ec2:"SourceSecurityGroupOwnerId" xml:"SourceSecurityGroupOwnerId"`
	ToPort                     aws.IntegerValue `ec2:"ToPort" xml:"ToPort"`
}

func (v *AuthorizeSecurityGroupIngressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AvailabilityZone is undocumented.
type AvailabilityZone struct {
	Messages   []AvailabilityZoneMessage `ec2:"Messages" xml:"messageSet>item"`
	RegionName aws.StringValue           `ec2:"RegionName" xml:"regionName"`
	State      aws.StringValue           `ec2:"State" xml:"zoneState"`
	ZoneName   aws.StringValue           `ec2:"ZoneName" xml:"zoneName"`
}

func (v *AvailabilityZone) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		AvailabilityZoneStateAvailable,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AvailabilityZoneMessage is undocumented.
type AvailabilityZoneMessage struct {
	Message aws.StringValue `ec2:"Message" xml:"message"`
}

func (v *AvailabilityZoneMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	AvailabilityZoneStateAvailable = "available"
)

// BlobAttributeValue is undocumented.
type BlobAttributeValue struct {
	Value []byte `ec2:"Value" xml:"value"`
}

func (v *BlobAttributeValue) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BlockDeviceMapping is undocumented.
type BlockDeviceMapping struct {
	DeviceName  aws.StringValue `ec2:"DeviceName" xml:"deviceName"`
	EBS         *EBSBlockDevice `ec2:"Ebs" xml:"ebs"`
	NoDevice    aws.StringValue `ec2:"NoDevice" xml:"noDevice"`
	VirtualName aws.StringValue `ec2:"VirtualName" xml:"virtualName"`
}

func (v *BlockDeviceMapping) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BundleInstanceRequest is undocumented.
type BundleInstanceRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
	Storage    *Storage         `ec2:"Storage" xml:"Storage"`
}

func (v *BundleInstanceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if err := model.ValidateRequired(v, "Storage"); err != nil {
		errors["Storage"] = append(errors["Storage"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BundleInstanceResult is undocumented.
type BundleInstanceResult struct {
	BundleTask *BundleTask `ec2:"BundleTask" xml:"bundleInstanceTask"`
}

func (v *BundleInstanceResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BundleTask is undocumented.
type BundleTask struct {
	BundleID        aws.StringValue  `ec2:"BundleId" xml:"bundleId"`
	BundleTaskError *BundleTaskError `ec2:"BundleTaskError" xml:"error"`
	InstanceID      aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
	Progress        aws.StringValue  `ec2:"Progress" xml:"progress"`
	StartTime       time.Time        `ec2:"StartTime" xml:"startTime"`
	State           aws.StringValue  `ec2:"State" xml:"state"`
	Storage         *Storage         `ec2:"Storage" xml:"storage"`
	UpdateTime      time.Time        `ec2:"UpdateTime" xml:"updateTime"`
}

func (v *BundleTask) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		BundleTaskStateBundling,
		BundleTaskStateCancelling,
		BundleTaskStateComplete,
		BundleTaskStateFailed,
		BundleTaskStatePending,
		BundleTaskStateStoring,
		BundleTaskStateWaitingForShutdown,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BundleTaskError is undocumented.
type BundleTaskError struct {
	Code    aws.StringValue `ec2:"Code" xml:"code"`
	Message aws.StringValue `ec2:"Message" xml:"message"`
}

func (v *BundleTaskError) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	BundleTaskStateBundling           = "bundling"
	BundleTaskStateCancelling         = "cancelling"
	BundleTaskStateComplete           = "complete"
	BundleTaskStateFailed             = "failed"
	BundleTaskStatePending            = "pending"
	BundleTaskStateStoring            = "storing"
	BundleTaskStateWaitingForShutdown = "waiting-for-shutdown"
)

// CancelBundleTaskRequest is undocumented.
type CancelBundleTaskRequest struct {
	BundleID aws.StringValue  `ec2:"BundleId" xml:"BundleId"`
	DryRun   aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *CancelBundleTaskRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "BundleID"); err != nil {
		errors["BundleID"] = append(errors["BundleID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelBundleTaskResult is undocumented.
type CancelBundleTaskResult struct {
	BundleTask *BundleTask `ec2:"BundleTask" xml:"bundleInstanceTask"`
}

func (v *CancelBundleTaskResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelConversionRequest is undocumented.
type CancelConversionRequest struct {
	ConversionTaskID aws.StringValue  `ec2:"ConversionTaskId" xml:"conversionTaskId"`
	DryRun           aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	ReasonMessage    aws.StringValue  `ec2:"ReasonMessage" xml:"reasonMessage"`
}

func (v *CancelConversionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ConversionTaskID"); err != nil {
		errors["ConversionTaskID"] = append(errors["ConversionTaskID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelExportTaskRequest is undocumented.
type CancelExportTaskRequest struct {
	ExportTaskID aws.StringValue `ec2:"ExportTaskId" xml:"exportTaskId"`
}

func (v *CancelExportTaskRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ExportTaskID"); err != nil {
		errors["ExportTaskID"] = append(errors["ExportTaskID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelReservedInstancesListingRequest is undocumented.
type CancelReservedInstancesListingRequest struct {
	ReservedInstancesListingID aws.StringValue `ec2:"ReservedInstancesListingId" xml:"reservedInstancesListingId"`
}

func (v *CancelReservedInstancesListingRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ReservedInstancesListingID"); err != nil {
		errors["ReservedInstancesListingID"] = append(errors["ReservedInstancesListingID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelReservedInstancesListingResult is undocumented.
type CancelReservedInstancesListingResult struct {
	ReservedInstancesListings []ReservedInstancesListing `ec2:"ReservedInstancesListings" xml:"reservedInstancesListingsSet>item"`
}

func (v *CancelReservedInstancesListingResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	CancelSpotInstanceRequestStateActive    = "active"
	CancelSpotInstanceRequestStateCancelled = "cancelled"
	CancelSpotInstanceRequestStateClosed    = "closed"
	CancelSpotInstanceRequestStateCompleted = "completed"
	CancelSpotInstanceRequestStateOpen      = "open"
)

// CancelSpotInstanceRequestsRequest is undocumented.
type CancelSpotInstanceRequestsRequest struct {
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	SpotInstanceRequestIDs []string         `ec2:"SpotInstanceRequestId" xml:"SpotInstanceRequestId>SpotInstanceRequestId"`
}

func (v *CancelSpotInstanceRequestsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SpotInstanceRequestIDs"); err != nil {
		errors["SpotInstanceRequestIDs"] = append(errors["SpotInstanceRequestIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelSpotInstanceRequestsResult is undocumented.
type CancelSpotInstanceRequestsResult struct {
	CancelledSpotInstanceRequests []CancelledSpotInstanceRequest `ec2:"CancelledSpotInstanceRequests" xml:"spotInstanceRequestSet>item"`
}

func (v *CancelSpotInstanceRequestsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelledSpotInstanceRequest is undocumented.
type CancelledSpotInstanceRequest struct {
	SpotInstanceRequestID aws.StringValue `ec2:"SpotInstanceRequestId" xml:"spotInstanceRequestId"`
	State                 aws.StringValue `ec2:"State" xml:"state"`
}

func (v *CancelledSpotInstanceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		CancelSpotInstanceRequestStateActive,
		CancelSpotInstanceRequestStateCancelled,
		CancelSpotInstanceRequestStateClosed,
		CancelSpotInstanceRequestStateCompleted,
		CancelSpotInstanceRequestStateOpen,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ConfirmProductInstanceRequest is undocumented.
type ConfirmProductInstanceRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID  aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
	ProductCode aws.StringValue  `ec2:"ProductCode" xml:"ProductCode"`
}

func (v *ConfirmProductInstanceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if err := model.ValidateRequired(v, "ProductCode"); err != nil {
		errors["ProductCode"] = append(errors["ProductCode"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ConfirmProductInstanceResult is undocumented.
type ConfirmProductInstanceResult struct {
	OwnerID aws.StringValue `ec2:"OwnerId" xml:"ownerId"`
}

func (v *ConfirmProductInstanceResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ContainerFormatOva = "ova"
)

// ConversionTask is undocumented.
type ConversionTask struct {
	ConversionTaskID aws.StringValue            `ec2:"ConversionTaskId" xml:"conversionTaskId"`
	ExpirationTime   aws.StringValue            `ec2:"ExpirationTime" xml:"expirationTime"`
	ImportInstance   *ImportInstanceTaskDetails `ec2:"ImportInstance" xml:"importInstance"`
	ImportVolume     *ImportVolumeTaskDetails   `ec2:"ImportVolume" xml:"importVolume"`
	State            aws.StringValue            `ec2:"State" xml:"state"`
	StatusMessage    aws.StringValue            `ec2:"StatusMessage" xml:"statusMessage"`
	Tags             []Tag                      `ec2:"Tags" xml:"tagSet>item"`
}

func (v *ConversionTask) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ConversionTaskID"); err != nil {
		errors["ConversionTaskID"] = append(errors["ConversionTaskID"], err)
	}

	if err := model.ValidateRequired(v, "State"); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	StateEnum := []string{
		ConversionTaskStateActive,
		ConversionTaskStateCancelled,
		ConversionTaskStateCancelling,
		ConversionTaskStateCompleted,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ConversionTaskStateActive     = "active"
	ConversionTaskStateCancelled  = "cancelled"
	ConversionTaskStateCancelling = "cancelling"
	ConversionTaskStateCompleted  = "completed"
)

// CopyImageRequest is undocumented.
type CopyImageRequest struct {
	ClientToken   aws.StringValue  `ec2:"ClientToken" xml:"ClientToken"`
	Description   aws.StringValue  `ec2:"Description" xml:"Description"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Name          aws.StringValue  `ec2:"Name" xml:"Name"`
	SourceImageID aws.StringValue  `ec2:"SourceImageId" xml:"SourceImageId"`
	SourceRegion  aws.StringValue  `ec2:"SourceRegion" xml:"SourceRegion"`
}

func (v *CopyImageRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "SourceImageID"); err != nil {
		errors["SourceImageID"] = append(errors["SourceImageID"], err)
	}

	if err := model.ValidateRequired(v, "SourceRegion"); err != nil {
		errors["SourceRegion"] = append(errors["SourceRegion"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CopyImageResult is undocumented.
type CopyImageResult struct {
	ImageID aws.StringValue `ec2:"ImageId" xml:"imageId"`
}

func (v *CopyImageResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CopySnapshotRequest is undocumented.
type CopySnapshotRequest struct {
	Description       aws.StringValue  `ec2:"Description" xml:"Description"`
	DestinationRegion aws.StringValue  `ec2:"DestinationRegion" xml:"destinationRegion"`
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	PresignedURL      aws.StringValue  `ec2:"PresignedUrl" xml:"presignedUrl"`
	SourceRegion      aws.StringValue  `ec2:"SourceRegion" xml:"SourceRegion"`
	SourceSnapshotID  aws.StringValue  `ec2:"SourceSnapshotId" xml:"SourceSnapshotId"`
}

func (v *CopySnapshotRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SourceRegion"); err != nil {
		errors["SourceRegion"] = append(errors["SourceRegion"], err)
	}

	if err := model.ValidateRequired(v, "SourceSnapshotID"); err != nil {
		errors["SourceSnapshotID"] = append(errors["SourceSnapshotID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CopySnapshotResult is undocumented.
type CopySnapshotResult struct {
	SnapshotID aws.StringValue `ec2:"SnapshotId" xml:"snapshotId"`
}

func (v *CopySnapshotResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateCustomerGatewayRequest is undocumented.
type CreateCustomerGatewayRequest struct {
	BGPASN   aws.IntegerValue `ec2:"BgpAsn" xml:"BgpAsn"`
	DryRun   aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	PublicIP aws.StringValue  `ec2:"IpAddress" xml:"IpAddress"`
	Type     aws.StringValue  `ec2:"Type" xml:"Type"`
}

func (v *CreateCustomerGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "BGPASN"); err != nil {
		errors["BGPASN"] = append(errors["BGPASN"], err)
	}

	if err := model.ValidateRequired(v, "PublicIP"); err != nil {
		errors["PublicIP"] = append(errors["PublicIP"], err)
	}

	if err := model.ValidateRequired(v, "Type"); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	TypeEnum := []string{
		GatewayTypeIPsec1,
	}
	if err := model.ValidateEnum(v, "Type", TypeEnum); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateCustomerGatewayResult is undocumented.
type CreateCustomerGatewayResult struct {
	CustomerGateway *CustomerGateway `ec2:"CustomerGateway" xml:"customerGateway"`
}

func (v *CreateCustomerGatewayResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateDHCPOptionsRequest is undocumented.
type CreateDHCPOptionsRequest struct {
	DHCPConfigurations []NewDHCPConfiguration `ec2:"DhcpConfigurations" xml:"dhcpConfiguration>item"`
	DryRun             aws.BooleanValue       `ec2:"DryRun" xml:"dryRun"`
}

func (v *CreateDHCPOptionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DHCPConfigurations"); err != nil {
		errors["DHCPConfigurations"] = append(errors["DHCPConfigurations"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateDHCPOptionsResult is undocumented.
type CreateDHCPOptionsResult struct {
	DHCPOptions *DHCPOptions `ec2:"DhcpOptions" xml:"dhcpOptions"`
}

func (v *CreateDHCPOptionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateImageRequest is undocumented.
type CreateImageRequest struct {
	BlockDeviceMappings []BlockDeviceMapping `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>BlockDeviceMapping"`
	Description         aws.StringValue      `ec2:"Description" xml:"description"`
	DryRun              aws.BooleanValue     `ec2:"DryRun" xml:"dryRun"`
	InstanceID          aws.StringValue      `ec2:"InstanceId" xml:"instanceId"`
	Name                aws.StringValue      `ec2:"Name" xml:"name"`
	NoReboot            aws.BooleanValue     `ec2:"NoReboot" xml:"noReboot"`
}

func (v *CreateImageRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateImageResult is undocumented.
type CreateImageResult struct {
	ImageID aws.StringValue `ec2:"ImageId" xml:"imageId"`
}

func (v *CreateImageResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInstanceExportTaskRequest is undocumented.
type CreateInstanceExportTaskRequest struct {
	Description       aws.StringValue              `ec2:"Description" xml:"description"`
	ExportToS3Task    *ExportToS3TaskSpecification `ec2:"ExportToS3Task" xml:"exportToS3"`
	InstanceID        aws.StringValue              `ec2:"InstanceId" xml:"instanceId"`
	TargetEnvironment aws.StringValue              `ec2:"TargetEnvironment" xml:"targetEnvironment"`
}

func (v *CreateInstanceExportTaskRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	TargetEnvironmentEnum := []string{
		ExportEnvironmentCitrix,
		ExportEnvironmentMicrosoft,
		ExportEnvironmentVMware,
	}
	if err := model.ValidateEnum(v, "TargetEnvironment", TargetEnvironmentEnum); err != nil {
		errors["TargetEnvironment"] = append(errors["TargetEnvironment"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInstanceExportTaskResult is undocumented.
type CreateInstanceExportTaskResult struct {
	ExportTask *ExportTask `ec2:"ExportTask" xml:"exportTask"`
}

func (v *CreateInstanceExportTaskResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInternetGatewayRequest is undocumented.
type CreateInternetGatewayRequest struct {
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *CreateInternetGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInternetGatewayResult is undocumented.
type CreateInternetGatewayResult struct {
	InternetGateway *InternetGateway `ec2:"InternetGateway" xml:"internetGateway"`
}

func (v *CreateInternetGatewayResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateKeyPairRequest is undocumented.
type CreateKeyPairRequest struct {
	DryRun  aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	KeyName aws.StringValue  `ec2:"KeyName" xml:"KeyName"`
}

func (v *CreateKeyPairRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "KeyName"); err != nil {
		errors["KeyName"] = append(errors["KeyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateNetworkACLEntryRequest is undocumented.
type CreateNetworkACLEntryRequest struct {
	CIDRBlock    aws.StringValue  `ec2:"CidrBlock" xml:"cidrBlock"`
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Egress       aws.BooleanValue `ec2:"Egress" xml:"egress"`
	ICMPTypeCode *ICMPTypeCode    `ec2:"Icmp" xml:"Icmp"`
	NetworkACLID aws.StringValue  `ec2:"NetworkAclId" xml:"networkAclId"`
	PortRange    *PortRange       `ec2:"PortRange" xml:"portRange"`
	Protocol     aws.StringValue  `ec2:"Protocol" xml:"protocol"`
	RuleAction   aws.StringValue  `ec2:"RuleAction" xml:"ruleAction"`
	RuleNumber   aws.IntegerValue `ec2:"RuleNumber" xml:"ruleNumber"`
}

func (v *CreateNetworkACLEntryRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CIDRBlock"); err != nil {
		errors["CIDRBlock"] = append(errors["CIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "Egress"); err != nil {
		errors["Egress"] = append(errors["Egress"], err)
	}

	if err := model.ValidateRequired(v, "NetworkACLID"); err != nil {
		errors["NetworkACLID"] = append(errors["NetworkACLID"], err)
	}

	if err := model.ValidateRequired(v, "Protocol"); err != nil {
		errors["Protocol"] = append(errors["Protocol"], err)
	}

	if err := model.ValidateRequired(v, "RuleAction"); err != nil {
		errors["RuleAction"] = append(errors["RuleAction"], err)
	}

	RuleActionEnum := []string{
		RuleActionAllow,
		RuleActionDeny,
	}
	if err := model.ValidateEnum(v, "RuleAction", RuleActionEnum); err != nil {
		errors["RuleAction"] = append(errors["RuleAction"], err)
	}

	if err := model.ValidateRequired(v, "RuleNumber"); err != nil {
		errors["RuleNumber"] = append(errors["RuleNumber"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateNetworkACLRequest is undocumented.
type CreateNetworkACLRequest struct {
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID  aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *CreateNetworkACLRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateNetworkACLResult is undocumented.
type CreateNetworkACLResult struct {
	NetworkACL *NetworkACL `ec2:"NetworkAcl" xml:"networkAcl"`
}

func (v *CreateNetworkACLResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateNetworkInterfaceRequest is undocumented.
type CreateNetworkInterfaceRequest struct {
	Description                    aws.StringValue                 `ec2:"Description" xml:"description"`
	DryRun                         aws.BooleanValue                `ec2:"DryRun" xml:"dryRun"`
	Groups                         []string                        `ec2:"SecurityGroupId" xml:"SecurityGroupId>SecurityGroupId"`
	PrivateIPAddress               aws.StringValue                 `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	PrivateIPAddresses             []PrivateIPAddressSpecification `ec2:"PrivateIpAddresses" xml:"privateIpAddresses>item"`
	SecondaryPrivateIPAddressCount aws.IntegerValue                `ec2:"SecondaryPrivateIpAddressCount" xml:"secondaryPrivateIpAddressCount"`
	SubnetID                       aws.StringValue                 `ec2:"SubnetId" xml:"subnetId"`
}

func (v *CreateNetworkInterfaceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SubnetID"); err != nil {
		errors["SubnetID"] = append(errors["SubnetID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateNetworkInterfaceResult is undocumented.
type CreateNetworkInterfaceResult struct {
	NetworkInterface *NetworkInterface `ec2:"NetworkInterface" xml:"networkInterface"`
}

func (v *CreateNetworkInterfaceResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreatePlacementGroupRequest is undocumented.
type CreatePlacementGroupRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	GroupName aws.StringValue  `ec2:"GroupName" xml:"groupName"`
	Strategy  aws.StringValue  `ec2:"Strategy" xml:"strategy"`
}

func (v *CreatePlacementGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "Strategy"); err != nil {
		errors["Strategy"] = append(errors["Strategy"], err)
	}

	StrategyEnum := []string{
		PlacementStrategyCluster,
	}
	if err := model.ValidateEnum(v, "Strategy", StrategyEnum); err != nil {
		errors["Strategy"] = append(errors["Strategy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateReservedInstancesListingRequest is undocumented.
type CreateReservedInstancesListingRequest struct {
	ClientToken         aws.StringValue              `ec2:"ClientToken" xml:"clientToken"`
	InstanceCount       aws.IntegerValue             `ec2:"InstanceCount" xml:"instanceCount"`
	PriceSchedules      []PriceScheduleSpecification `ec2:"PriceSchedules" xml:"priceSchedules>item"`
	ReservedInstancesID aws.StringValue              `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
}

func (v *CreateReservedInstancesListingRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClientToken"); err != nil {
		errors["ClientToken"] = append(errors["ClientToken"], err)
	}

	if err := model.ValidateRequired(v, "InstanceCount"); err != nil {
		errors["InstanceCount"] = append(errors["InstanceCount"], err)
	}

	if err := model.ValidateRequired(v, "PriceSchedules"); err != nil {
		errors["PriceSchedules"] = append(errors["PriceSchedules"], err)
	}

	if err := model.ValidateRequired(v, "ReservedInstancesID"); err != nil {
		errors["ReservedInstancesID"] = append(errors["ReservedInstancesID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateReservedInstancesListingResult is undocumented.
type CreateReservedInstancesListingResult struct {
	ReservedInstancesListings []ReservedInstancesListing `ec2:"ReservedInstancesListings" xml:"reservedInstancesListingsSet>item"`
}

func (v *CreateReservedInstancesListingResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateRouteRequest is undocumented.
type CreateRouteRequest struct {
	DestinationCIDRBlock   aws.StringValue  `ec2:"DestinationCidrBlock" xml:"destinationCidrBlock"`
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	GatewayID              aws.StringValue  `ec2:"GatewayId" xml:"gatewayId"`
	InstanceID             aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
	NetworkInterfaceID     aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	RouteTableID           aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
	VPCPeeringConnectionID aws.StringValue  `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *CreateRouteRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DestinationCIDRBlock"); err != nil {
		errors["DestinationCIDRBlock"] = append(errors["DestinationCIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateRouteTableRequest is undocumented.
type CreateRouteTableRequest struct {
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID  aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *CreateRouteTableRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateRouteTableResult is undocumented.
type CreateRouteTableResult struct {
	RouteTable *RouteTable `ec2:"RouteTable" xml:"routeTable"`
}

func (v *CreateRouteTableResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSecurityGroupRequest is undocumented.
type CreateSecurityGroupRequest struct {
	Description aws.StringValue  `ec2:"GroupDescription" xml:"GroupDescription"`
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	GroupName   aws.StringValue  `ec2:"GroupName" xml:"GroupName"`
	VPCID       aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
}

func (v *CreateSecurityGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Description"); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSecurityGroupResult is undocumented.
type CreateSecurityGroupResult struct {
	GroupID aws.StringValue `ec2:"GroupId" xml:"groupId"`
}

func (v *CreateSecurityGroupResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSnapshotRequest is undocumented.
type CreateSnapshotRequest struct {
	Description aws.StringValue  `ec2:"Description" xml:"Description"`
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VolumeID    aws.StringValue  `ec2:"VolumeId" xml:"VolumeId"`
}

func (v *CreateSnapshotRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSpotDatafeedSubscriptionRequest is undocumented.
type CreateSpotDatafeedSubscriptionRequest struct {
	Bucket aws.StringValue  `ec2:"Bucket" xml:"bucket"`
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Prefix aws.StringValue  `ec2:"Prefix" xml:"prefix"`
}

func (v *CreateSpotDatafeedSubscriptionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Bucket"); err != nil {
		errors["Bucket"] = append(errors["Bucket"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSpotDatafeedSubscriptionResult is undocumented.
type CreateSpotDatafeedSubscriptionResult struct {
	SpotDatafeedSubscription *SpotDatafeedSubscription `ec2:"SpotDatafeedSubscription" xml:"spotDatafeedSubscription"`
}

func (v *CreateSpotDatafeedSubscriptionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSubnetRequest is undocumented.
type CreateSubnetRequest struct {
	AvailabilityZone aws.StringValue  `ec2:"AvailabilityZone" xml:"AvailabilityZone"`
	CIDRBlock        aws.StringValue  `ec2:"CidrBlock" xml:"CidrBlock"`
	DryRun           aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID            aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
}

func (v *CreateSubnetRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CIDRBlock"); err != nil {
		errors["CIDRBlock"] = append(errors["CIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSubnetResult is undocumented.
type CreateSubnetResult struct {
	Subnet *Subnet `ec2:"Subnet" xml:"subnet"`
}

func (v *CreateSubnetResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateTagsRequest is undocumented.
type CreateTagsRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Resources []string         `ec2:"ResourceId" xml:"ResourceId>member"`
	Tags      []Tag            `ec2:"Tag" xml:"Tag>item"`
}

func (v *CreateTagsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Resources"); err != nil {
		errors["Resources"] = append(errors["Resources"], err)
	}

	if err := model.ValidateRequired(v, "Tags"); err != nil {
		errors["Tags"] = append(errors["Tags"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVolumePermission is undocumented.
type CreateVolumePermission struct {
	Group  aws.StringValue `ec2:"Group" xml:"group"`
	UserID aws.StringValue `ec2:"UserId" xml:"userId"`
}

func (v *CreateVolumePermission) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	GroupEnum := []string{
		PermissionGroupAll,
	}
	if err := model.ValidateEnum(v, "Group", GroupEnum); err != nil {
		errors["Group"] = append(errors["Group"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVolumePermissionModifications is undocumented.
type CreateVolumePermissionModifications struct {
	Add    []CreateVolumePermission `ec2:"Add" xml:"Add>item"`
	Remove []CreateVolumePermission `ec2:"Remove" xml:"Remove>item"`
}

func (v *CreateVolumePermissionModifications) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVolumeRequest is undocumented.
type CreateVolumeRequest struct {
	AvailabilityZone aws.StringValue  `ec2:"AvailabilityZone" xml:"AvailabilityZone"`
	DryRun           aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Encrypted        aws.BooleanValue `ec2:"Encrypted" xml:"encrypted"`
	IOPS             aws.IntegerValue `ec2:"Iops" xml:"Iops"`
	KMSKeyID         aws.StringValue  `ec2:"KmsKeyId" xml:"KmsKeyId"`
	Size             aws.IntegerValue `ec2:"Size" xml:"Size"`
	SnapshotID       aws.StringValue  `ec2:"SnapshotId" xml:"SnapshotId"`
	VolumeType       aws.StringValue  `ec2:"VolumeType" xml:"VolumeType"`
}

func (v *CreateVolumeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AvailabilityZone"); err != nil {
		errors["AvailabilityZone"] = append(errors["AvailabilityZone"], err)
	}

	VolumeTypeEnum := []string{
		VolumeTypeGp2,
		VolumeTypeIo1,
		VolumeTypeStandard,
	}
	if err := model.ValidateEnum(v, "VolumeType", VolumeTypeEnum); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPCPeeringConnectionRequest is undocumented.
type CreateVPCPeeringConnectionRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	PeerOwnerID aws.StringValue  `ec2:"PeerOwnerId" xml:"peerOwnerId"`
	PeerVPCID   aws.StringValue  `ec2:"PeerVpcId" xml:"peerVpcId"`
	VPCID       aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *CreateVPCPeeringConnectionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPCPeeringConnectionResult is undocumented.
type CreateVPCPeeringConnectionResult struct {
	VPCPeeringConnection *VPCPeeringConnection `ec2:"VpcPeeringConnection" xml:"vpcPeeringConnection"`
}

func (v *CreateVPCPeeringConnectionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPCRequest is undocumented.
type CreateVPCRequest struct {
	CIDRBlock       aws.StringValue  `ec2:"CidrBlock" xml:"CidrBlock"`
	DryRun          aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceTenancy aws.StringValue  `ec2:"InstanceTenancy" xml:"instanceTenancy"`
}

func (v *CreateVPCRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CIDRBlock"); err != nil {
		errors["CIDRBlock"] = append(errors["CIDRBlock"], err)
	}

	InstanceTenancyEnum := []string{
		TenancyDedicated,
		TenancyDefault,
	}
	if err := model.ValidateEnum(v, "InstanceTenancy", InstanceTenancyEnum); err != nil {
		errors["InstanceTenancy"] = append(errors["InstanceTenancy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPCResult is undocumented.
type CreateVPCResult struct {
	VPC *VPC `ec2:"Vpc" xml:"vpc"`
}

func (v *CreateVPCResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPNConnectionRequest is undocumented.
type CreateVPNConnectionRequest struct {
	CustomerGatewayID aws.StringValue                    `ec2:"CustomerGatewayId" xml:"CustomerGatewayId"`
	DryRun            aws.BooleanValue                   `ec2:"DryRun" xml:"dryRun"`
	Options           *VPNConnectionOptionsSpecification `ec2:"Options" xml:"options"`
	Type              aws.StringValue                    `ec2:"Type" xml:"Type"`
	VPNGatewayID      aws.StringValue                    `ec2:"VpnGatewayId" xml:"VpnGatewayId"`
}

func (v *CreateVPNConnectionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CustomerGatewayID"); err != nil {
		errors["CustomerGatewayID"] = append(errors["CustomerGatewayID"], err)
	}

	if err := model.ValidateRequired(v, "Type"); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if err := model.ValidateRequired(v, "VPNGatewayID"); err != nil {
		errors["VPNGatewayID"] = append(errors["VPNGatewayID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPNConnectionResult is undocumented.
type CreateVPNConnectionResult struct {
	VPNConnection *VPNConnection `ec2:"VpnConnection" xml:"vpnConnection"`
}

func (v *CreateVPNConnectionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPNConnectionRouteRequest is undocumented.
type CreateVPNConnectionRouteRequest struct {
	DestinationCIDRBlock aws.StringValue `ec2:"DestinationCidrBlock" xml:"DestinationCidrBlock"`
	VPNConnectionID      aws.StringValue `ec2:"VpnConnectionId" xml:"VpnConnectionId"`
}

func (v *CreateVPNConnectionRouteRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DestinationCIDRBlock"); err != nil {
		errors["DestinationCIDRBlock"] = append(errors["DestinationCIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "VPNConnectionID"); err != nil {
		errors["VPNConnectionID"] = append(errors["VPNConnectionID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPNGatewayRequest is undocumented.
type CreateVPNGatewayRequest struct {
	AvailabilityZone aws.StringValue  `ec2:"AvailabilityZone" xml:"AvailabilityZone"`
	DryRun           aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Type             aws.StringValue  `ec2:"Type" xml:"Type"`
}

func (v *CreateVPNGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Type"); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	TypeEnum := []string{
		GatewayTypeIPsec1,
	}
	if err := model.ValidateEnum(v, "Type", TypeEnum); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVPNGatewayResult is undocumented.
type CreateVPNGatewayResult struct {
	VPNGateway *VPNGateway `ec2:"VpnGateway" xml:"vpnGateway"`
}

func (v *CreateVPNGatewayResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	CurrencyCodeValuesUsd = "USD"
)

// CustomerGateway is undocumented.
type CustomerGateway struct {
	BGPASN            aws.StringValue `ec2:"BgpAsn" xml:"bgpAsn"`
	CustomerGatewayID aws.StringValue `ec2:"CustomerGatewayId" xml:"customerGatewayId"`
	IPAddress         aws.StringValue `ec2:"IpAddress" xml:"ipAddress"`
	State             aws.StringValue `ec2:"State" xml:"state"`
	Tags              []Tag           `ec2:"Tags" xml:"tagSet>item"`
	Type              aws.StringValue `ec2:"Type" xml:"type"`
}

func (v *CustomerGateway) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	DatafeedSubscriptionStateActive   = "Active"
	DatafeedSubscriptionStateInactive = "Inactive"
)

// DeleteCustomerGatewayRequest is undocumented.
type DeleteCustomerGatewayRequest struct {
	CustomerGatewayID aws.StringValue  `ec2:"CustomerGatewayId" xml:"CustomerGatewayId"`
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *DeleteCustomerGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CustomerGatewayID"); err != nil {
		errors["CustomerGatewayID"] = append(errors["CustomerGatewayID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteDHCPOptionsRequest is undocumented.
type DeleteDHCPOptionsRequest struct {
	DHCPOptionsID aws.StringValue  `ec2:"DhcpOptionsId" xml:"DhcpOptionsId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *DeleteDHCPOptionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DHCPOptionsID"); err != nil {
		errors["DHCPOptionsID"] = append(errors["DHCPOptionsID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteInternetGatewayRequest is undocumented.
type DeleteInternetGatewayRequest struct {
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InternetGatewayID aws.StringValue  `ec2:"InternetGatewayId" xml:"internetGatewayId"`
}

func (v *DeleteInternetGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InternetGatewayID"); err != nil {
		errors["InternetGatewayID"] = append(errors["InternetGatewayID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteKeyPairRequest is undocumented.
type DeleteKeyPairRequest struct {
	DryRun  aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	KeyName aws.StringValue  `ec2:"KeyName" xml:"KeyName"`
}

func (v *DeleteKeyPairRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "KeyName"); err != nil {
		errors["KeyName"] = append(errors["KeyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteNetworkACLEntryRequest is undocumented.
type DeleteNetworkACLEntryRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Egress       aws.BooleanValue `ec2:"Egress" xml:"egress"`
	NetworkACLID aws.StringValue  `ec2:"NetworkAclId" xml:"networkAclId"`
	RuleNumber   aws.IntegerValue `ec2:"RuleNumber" xml:"ruleNumber"`
}

func (v *DeleteNetworkACLEntryRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Egress"); err != nil {
		errors["Egress"] = append(errors["Egress"], err)
	}

	if err := model.ValidateRequired(v, "NetworkACLID"); err != nil {
		errors["NetworkACLID"] = append(errors["NetworkACLID"], err)
	}

	if err := model.ValidateRequired(v, "RuleNumber"); err != nil {
		errors["RuleNumber"] = append(errors["RuleNumber"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteNetworkACLRequest is undocumented.
type DeleteNetworkACLRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	NetworkACLID aws.StringValue  `ec2:"NetworkAclId" xml:"networkAclId"`
}

func (v *DeleteNetworkACLRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NetworkACLID"); err != nil {
		errors["NetworkACLID"] = append(errors["NetworkACLID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteNetworkInterfaceRequest is undocumented.
type DeleteNetworkInterfaceRequest struct {
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	NetworkInterfaceID aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
}

func (v *DeleteNetworkInterfaceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeletePlacementGroupRequest is undocumented.
type DeletePlacementGroupRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	GroupName aws.StringValue  `ec2:"GroupName" xml:"groupName"`
}

func (v *DeletePlacementGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteRouteRequest is undocumented.
type DeleteRouteRequest struct {
	DestinationCIDRBlock aws.StringValue  `ec2:"DestinationCidrBlock" xml:"destinationCidrBlock"`
	DryRun               aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	RouteTableID         aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
}

func (v *DeleteRouteRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DestinationCIDRBlock"); err != nil {
		errors["DestinationCIDRBlock"] = append(errors["DestinationCIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteRouteTableRequest is undocumented.
type DeleteRouteTableRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	RouteTableID aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
}

func (v *DeleteRouteTableRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSecurityGroupRequest is undocumented.
type DeleteSecurityGroupRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	GroupID   aws.StringValue  `ec2:"GroupId" xml:"GroupId"`
	GroupName aws.StringValue  `ec2:"GroupName" xml:"GroupName"`
}

func (v *DeleteSecurityGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSnapshotRequest is undocumented.
type DeleteSnapshotRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	SnapshotID aws.StringValue  `ec2:"SnapshotId" xml:"SnapshotId"`
}

func (v *DeleteSnapshotRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SnapshotID"); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSpotDatafeedSubscriptionRequest is undocumented.
type DeleteSpotDatafeedSubscriptionRequest struct {
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *DeleteSpotDatafeedSubscriptionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSubnetRequest is undocumented.
type DeleteSubnetRequest struct {
	DryRun   aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	SubnetID aws.StringValue  `ec2:"SubnetId" xml:"SubnetId"`
}

func (v *DeleteSubnetRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SubnetID"); err != nil {
		errors["SubnetID"] = append(errors["SubnetID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteTagsRequest is undocumented.
type DeleteTagsRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Resources []string         `ec2:"Resources" xml:"resourceId>member"`
	Tags      []Tag            `ec2:"Tags" xml:"tag>item"`
}

func (v *DeleteTagsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Resources"); err != nil {
		errors["Resources"] = append(errors["Resources"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVolumeRequest is undocumented.
type DeleteVolumeRequest struct {
	DryRun   aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VolumeID aws.StringValue  `ec2:"VolumeId" xml:"VolumeId"`
}

func (v *DeleteVolumeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVPCPeeringConnectionRequest is undocumented.
type DeleteVPCPeeringConnectionRequest struct {
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCPeeringConnectionID aws.StringValue  `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *DeleteVPCPeeringConnectionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCPeeringConnectionID"); err != nil {
		errors["VPCPeeringConnectionID"] = append(errors["VPCPeeringConnectionID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVPCPeeringConnectionResult is undocumented.
type DeleteVPCPeeringConnectionResult struct {
	Return aws.BooleanValue `ec2:"Return" xml:"return"`
}

func (v *DeleteVPCPeeringConnectionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVPCRequest is undocumented.
type DeleteVPCRequest struct {
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID  aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
}

func (v *DeleteVPCRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVPNConnectionRequest is undocumented.
type DeleteVPNConnectionRequest struct {
	DryRun          aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPNConnectionID aws.StringValue  `ec2:"VpnConnectionId" xml:"VpnConnectionId"`
}

func (v *DeleteVPNConnectionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPNConnectionID"); err != nil {
		errors["VPNConnectionID"] = append(errors["VPNConnectionID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVPNConnectionRouteRequest is undocumented.
type DeleteVPNConnectionRouteRequest struct {
	DestinationCIDRBlock aws.StringValue `ec2:"DestinationCidrBlock" xml:"DestinationCidrBlock"`
	VPNConnectionID      aws.StringValue `ec2:"VpnConnectionId" xml:"VpnConnectionId"`
}

func (v *DeleteVPNConnectionRouteRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DestinationCIDRBlock"); err != nil {
		errors["DestinationCIDRBlock"] = append(errors["DestinationCIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "VPNConnectionID"); err != nil {
		errors["VPNConnectionID"] = append(errors["VPNConnectionID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVPNGatewayRequest is undocumented.
type DeleteVPNGatewayRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPNGatewayID aws.StringValue  `ec2:"VpnGatewayId" xml:"VpnGatewayId"`
}

func (v *DeleteVPNGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPNGatewayID"); err != nil {
		errors["VPNGatewayID"] = append(errors["VPNGatewayID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeregisterImageRequest is undocumented.
type DeregisterImageRequest struct {
	DryRun  aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	ImageID aws.StringValue  `ec2:"ImageId" xml:"ImageId"`
}

func (v *DeregisterImageRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ImageID"); err != nil {
		errors["ImageID"] = append(errors["ImageID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAccountAttributesRequest is undocumented.
type DescribeAccountAttributesRequest struct {
	AttributeNames []string         `ec2:"AttributeNames" xml:"attributeName>attributeName"`
	DryRun         aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *DescribeAccountAttributesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAccountAttributesResult is undocumented.
type DescribeAccountAttributesResult struct {
	AccountAttributes []AccountAttribute `ec2:"AccountAttributes" xml:"accountAttributeSet>item"`
}

func (v *DescribeAccountAttributesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAddressesRequest is undocumented.
type DescribeAddressesRequest struct {
	AllocationIDs []string         `ec2:"AllocationId" xml:"AllocationId>AllocationId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters       []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	PublicIPs     []string         `ec2:"PublicIp" xml:"PublicIp>PublicIp"`
}

func (v *DescribeAddressesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAddressesResult is undocumented.
type DescribeAddressesResult struct {
	Addresses []Address `ec2:"Addresses" xml:"addressesSet>item"`
}

func (v *DescribeAddressesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAvailabilityZonesRequest is undocumented.
type DescribeAvailabilityZonesRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters   []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	ZoneNames []string         `ec2:"ZoneName" xml:"ZoneName>ZoneName"`
}

func (v *DescribeAvailabilityZonesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAvailabilityZonesResult is undocumented.
type DescribeAvailabilityZonesResult struct {
	AvailabilityZones []AvailabilityZone `ec2:"AvailabilityZones" xml:"availabilityZoneInfo>item"`
}

func (v *DescribeAvailabilityZonesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeBundleTasksRequest is undocumented.
type DescribeBundleTasksRequest struct {
	BundleIDs []string         `ec2:"BundleId" xml:"BundleId>BundleId"`
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters   []Filter         `ec2:"Filter" xml:"Filter>Filter"`
}

func (v *DescribeBundleTasksRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeBundleTasksResult is undocumented.
type DescribeBundleTasksResult struct {
	BundleTasks []BundleTask `ec2:"BundleTasks" xml:"bundleInstanceTasksSet>item"`
}

func (v *DescribeBundleTasksResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeConversionTasksRequest is undocumented.
type DescribeConversionTasksRequest struct {
	ConversionTaskIDs []string         `ec2:"ConversionTaskIds" xml:"conversionTaskId>item"`
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters           []Filter         `ec2:"Filters" xml:"filter>Filter"`
}

func (v *DescribeConversionTasksRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeConversionTasksResult is undocumented.
type DescribeConversionTasksResult struct {
	ConversionTasks []ConversionTask `ec2:"ConversionTasks" xml:"conversionTasks>item"`
}

func (v *DescribeConversionTasksResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeCustomerGatewaysRequest is undocumented.
type DescribeCustomerGatewaysRequest struct {
	CustomerGatewayIDs []string         `ec2:"CustomerGatewayId" xml:"CustomerGatewayId>CustomerGatewayId"`
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters            []Filter         `ec2:"Filter" xml:"Filter>Filter"`
}

func (v *DescribeCustomerGatewaysRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeCustomerGatewaysResult is undocumented.
type DescribeCustomerGatewaysResult struct {
	CustomerGateways []CustomerGateway `ec2:"CustomerGateways" xml:"customerGatewaySet>item"`
}

func (v *DescribeCustomerGatewaysResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDHCPOptionsRequest is undocumented.
type DescribeDHCPOptionsRequest struct {
	DHCPOptionsIDs []string         `ec2:"DhcpOptionsId" xml:"DhcpOptionsId>DhcpOptionsId"`
	DryRun         aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters        []Filter         `ec2:"Filter" xml:"Filter>Filter"`
}

func (v *DescribeDHCPOptionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDHCPOptionsResult is undocumented.
type DescribeDHCPOptionsResult struct {
	DHCPOptions []DHCPOptions `ec2:"DhcpOptions" xml:"dhcpOptionsSet>item"`
}

func (v *DescribeDHCPOptionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeExportTasksRequest is undocumented.
type DescribeExportTasksRequest struct {
	ExportTaskIDs []string `ec2:"ExportTaskIds" xml:"exportTaskId>ExportTaskId"`
}

func (v *DescribeExportTasksRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeExportTasksResult is undocumented.
type DescribeExportTasksResult struct {
	ExportTasks []ExportTask `ec2:"ExportTasks" xml:"exportTaskSet>item"`
}

func (v *DescribeExportTasksResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeImageAttributeRequest is undocumented.
type DescribeImageAttributeRequest struct {
	Attribute aws.StringValue  `ec2:"Attribute" xml:"Attribute"`
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	ImageID   aws.StringValue  `ec2:"ImageId" xml:"ImageId"`
}

func (v *DescribeImageAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Attribute"); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	AttributeEnum := []string{
		ImageAttributeNameBlockDeviceMapping,
		ImageAttributeNameDescription,
		ImageAttributeNameKernel,
		ImageAttributeNameLaunchPermission,
		ImageAttributeNameProductCodes,
		ImageAttributeNameRAMDisk,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "ImageID"); err != nil {
		errors["ImageID"] = append(errors["ImageID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeImagesRequest is undocumented.
type DescribeImagesRequest struct {
	DryRun          aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	ExecutableUsers []string         `ec2:"ExecutableBy" xml:"ExecutableBy>ExecutableBy"`
	Filters         []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	ImageIDs        []string         `ec2:"ImageId" xml:"ImageId>ImageId"`
	Owners          []string         `ec2:"Owner" xml:"Owner>Owner"`
}

func (v *DescribeImagesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeImagesResult is undocumented.
type DescribeImagesResult struct {
	Images []Image `ec2:"Images" xml:"imagesSet>item"`
}

func (v *DescribeImagesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInstanceAttributeRequest is undocumented.
type DescribeInstanceAttributeRequest struct {
	Attribute  aws.StringValue  `ec2:"Attribute" xml:"attribute"`
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
}

func (v *DescribeInstanceAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Attribute"); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	AttributeEnum := []string{
		InstanceAttributeNameBlockDeviceMapping,
		InstanceAttributeNameDisableAPITermination,
		InstanceAttributeNameEBSOptimized,
		InstanceAttributeNameGroupSet,
		InstanceAttributeNameInstanceInitiatedShutdownBehavior,
		InstanceAttributeNameInstanceType,
		InstanceAttributeNameKernel,
		InstanceAttributeNameProductCodes,
		InstanceAttributeNameRAMDisk,
		InstanceAttributeNameRootDeviceName,
		InstanceAttributeNameSRIOVNetSupport,
		InstanceAttributeNameSourceDestCheck,
		InstanceAttributeNameUserData,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInstanceStatusRequest is undocumented.
type DescribeInstanceStatusRequest struct {
	DryRun              aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters             []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	IncludeAllInstances aws.BooleanValue `ec2:"IncludeAllInstances" xml:"includeAllInstances"`
	InstanceIDs         []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
	MaxResults          aws.IntegerValue `ec2:"MaxResults" xml:"MaxResults"`
	NextToken           aws.StringValue  `ec2:"NextToken" xml:"NextToken"`
}

func (v *DescribeInstanceStatusRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInstanceStatusResult is undocumented.
type DescribeInstanceStatusResult struct {
	InstanceStatuses []InstanceStatus `ec2:"InstanceStatuses" xml:"instanceStatusSet>item"`
	NextToken        aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
}

func (v *DescribeInstanceStatusResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInstancesRequest is undocumented.
type DescribeInstancesRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters     []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	InstanceIDs []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
	MaxResults  aws.IntegerValue `ec2:"MaxResults" xml:"maxResults"`
	NextToken   aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
}

func (v *DescribeInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInstancesResult is undocumented.
type DescribeInstancesResult struct {
	NextToken    aws.StringValue `ec2:"NextToken" xml:"nextToken"`
	Reservations []Reservation   `ec2:"Reservations" xml:"reservationSet>item"`
}

func (v *DescribeInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInternetGatewaysRequest is undocumented.
type DescribeInternetGatewaysRequest struct {
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters            []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	InternetGatewayIDs []string         `ec2:"InternetGatewayIds" xml:"internetGatewayId>item"`
}

func (v *DescribeInternetGatewaysRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeInternetGatewaysResult is undocumented.
type DescribeInternetGatewaysResult struct {
	InternetGateways []InternetGateway `ec2:"InternetGateways" xml:"internetGatewaySet>item"`
}

func (v *DescribeInternetGatewaysResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeKeyPairsRequest is undocumented.
type DescribeKeyPairsRequest struct {
	DryRun   aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters  []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	KeyNames []string         `ec2:"KeyName" xml:"KeyName>KeyName"`
}

func (v *DescribeKeyPairsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeKeyPairsResult is undocumented.
type DescribeKeyPairsResult struct {
	KeyPairs []KeyPairInfo `ec2:"KeyPairs" xml:"keySet>item"`
}

func (v *DescribeKeyPairsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeNetworkACLsRequest is undocumented.
type DescribeNetworkACLsRequest struct {
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters       []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	NetworkACLIDs []string         `ec2:"NetworkAclId" xml:"NetworkAclId>item"`
}

func (v *DescribeNetworkACLsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeNetworkACLsResult is undocumented.
type DescribeNetworkACLsResult struct {
	NetworkACLs []NetworkACL `ec2:"NetworkAcls" xml:"networkAclSet>item"`
}

func (v *DescribeNetworkACLsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeNetworkInterfaceAttributeRequest is undocumented.
type DescribeNetworkInterfaceAttributeRequest struct {
	Attribute          aws.StringValue  `ec2:"Attribute" xml:"attribute"`
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	NetworkInterfaceID aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
}

func (v *DescribeNetworkInterfaceAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AttributeEnum := []string{
		NetworkInterfaceAttributeAttachment,
		NetworkInterfaceAttributeDescription,
		NetworkInterfaceAttributeGroupSet,
		NetworkInterfaceAttributeSourceDestCheck,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeNetworkInterfaceAttributeResult is undocumented.
type DescribeNetworkInterfaceAttributeResult struct {
	Attachment         *NetworkInterfaceAttachment `ec2:"Attachment" xml:"attachment"`
	Description        *AttributeValue             `ec2:"Description" xml:"description"`
	Groups             []GroupIdentifier           `ec2:"Groups" xml:"groupSet>item"`
	NetworkInterfaceID aws.StringValue             `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	SourceDestCheck    *AttributeBooleanValue      `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
}

func (v *DescribeNetworkInterfaceAttributeResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeNetworkInterfacesRequest is undocumented.
type DescribeNetworkInterfacesRequest struct {
	DryRun              aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters             []Filter         `ec2:"Filters" xml:"filter>Filter"`
	NetworkInterfaceIDs []string         `ec2:"NetworkInterfaceId" xml:"NetworkInterfaceId>item"`
}

func (v *DescribeNetworkInterfacesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeNetworkInterfacesResult is undocumented.
type DescribeNetworkInterfacesResult struct {
	NetworkInterfaces []NetworkInterface `ec2:"NetworkInterfaces" xml:"networkInterfaceSet>item"`
}

func (v *DescribeNetworkInterfacesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribePlacementGroupsRequest is undocumented.
type DescribePlacementGroupsRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters    []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	GroupNames []string         `ec2:"GroupNames" xml:"groupName>member"`
}

func (v *DescribePlacementGroupsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribePlacementGroupsResult is undocumented.
type DescribePlacementGroupsResult struct {
	PlacementGroups []PlacementGroup `ec2:"PlacementGroups" xml:"placementGroupSet>item"`
}

func (v *DescribePlacementGroupsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeRegionsRequest is undocumented.
type DescribeRegionsRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters     []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	RegionNames []string         `ec2:"RegionName" xml:"RegionName>RegionName"`
}

func (v *DescribeRegionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeRegionsResult is undocumented.
type DescribeRegionsResult struct {
	Regions []Region `ec2:"Regions" xml:"regionInfo>item"`
}

func (v *DescribeRegionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesListingsRequest is undocumented.
type DescribeReservedInstancesListingsRequest struct {
	Filters                    []Filter        `ec2:"Filters" xml:"filters>Filter"`
	ReservedInstancesID        aws.StringValue `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
	ReservedInstancesListingID aws.StringValue `ec2:"ReservedInstancesListingId" xml:"reservedInstancesListingId"`
}

func (v *DescribeReservedInstancesListingsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesListingsResult is undocumented.
type DescribeReservedInstancesListingsResult struct {
	ReservedInstancesListings []ReservedInstancesListing `ec2:"ReservedInstancesListings" xml:"reservedInstancesListingsSet>item"`
}

func (v *DescribeReservedInstancesListingsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesModificationsRequest is undocumented.
type DescribeReservedInstancesModificationsRequest struct {
	Filters                          []Filter        `ec2:"Filter" xml:"Filter>Filter"`
	NextToken                        aws.StringValue `ec2:"NextToken" xml:"nextToken"`
	ReservedInstancesModificationIDs []string        `ec2:"ReservedInstancesModificationId" xml:"ReservedInstancesModificationId>ReservedInstancesModificationId"`
}

func (v *DescribeReservedInstancesModificationsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesModificationsResult is undocumented.
type DescribeReservedInstancesModificationsResult struct {
	NextToken                      aws.StringValue                 `ec2:"NextToken" xml:"nextToken"`
	ReservedInstancesModifications []ReservedInstancesModification `ec2:"ReservedInstancesModifications" xml:"reservedInstancesModificationsSet>item"`
}

func (v *DescribeReservedInstancesModificationsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesOfferingsRequest is undocumented.
type DescribeReservedInstancesOfferingsRequest struct {
	AvailabilityZone             aws.StringValue  `ec2:"AvailabilityZone" xml:"AvailabilityZone"`
	DryRun                       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters                      []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	IncludeMarketplace           aws.BooleanValue `ec2:"IncludeMarketplace" xml:"IncludeMarketplace"`
	InstanceTenancy              aws.StringValue  `ec2:"InstanceTenancy" xml:"instanceTenancy"`
	InstanceType                 aws.StringValue  `ec2:"InstanceType" xml:"InstanceType"`
	MaxDuration                  aws.LongValue    `ec2:"MaxDuration" xml:"MaxDuration"`
	MaxInstanceCount             aws.IntegerValue `ec2:"MaxInstanceCount" xml:"MaxInstanceCount"`
	MaxResults                   aws.IntegerValue `ec2:"MaxResults" xml:"maxResults"`
	MinDuration                  aws.LongValue    `ec2:"MinDuration" xml:"MinDuration"`
	NextToken                    aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
	OfferingType                 aws.StringValue  `ec2:"OfferingType" xml:"offeringType"`
	ProductDescription           aws.StringValue  `ec2:"ProductDescription" xml:"ProductDescription"`
	ReservedInstancesOfferingIDs []string         `ec2:"ReservedInstancesOfferingId" xml:"ReservedInstancesOfferingId>member"`
}

func (v *DescribeReservedInstancesOfferingsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	InstanceTenancyEnum := []string{
		TenancyDedicated,
		TenancyDefault,
	}
	if err := model.ValidateEnum(v, "InstanceTenancy", InstanceTenancyEnum); err != nil {
		errors["InstanceTenancy"] = append(errors["InstanceTenancy"], err)
	}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	OfferingTypeEnum := []string{
		OfferingTypeValuesHeavyUtilization,
		OfferingTypeValuesLightUtilization,
		OfferingTypeValuesMediumUtilization,
	}
	if err := model.ValidateEnum(v, "OfferingType", OfferingTypeEnum); err != nil {
		errors["OfferingType"] = append(errors["OfferingType"], err)
	}

	ProductDescriptionEnum := []string{
		RIProductDescriptionLinuxUnix,
		RIProductDescriptionLinuxUnixamazonVPC,
		RIProductDescriptionWindows,
		RIProductDescriptionWindowsAmazonVPC,
	}
	if err := model.ValidateEnum(v, "ProductDescription", ProductDescriptionEnum); err != nil {
		errors["ProductDescription"] = append(errors["ProductDescription"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesOfferingsResult is undocumented.
type DescribeReservedInstancesOfferingsResult struct {
	NextToken                  aws.StringValue             `ec2:"NextToken" xml:"nextToken"`
	ReservedInstancesOfferings []ReservedInstancesOffering `ec2:"ReservedInstancesOfferings" xml:"reservedInstancesOfferingsSet>item"`
}

func (v *DescribeReservedInstancesOfferingsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesRequest is undocumented.
type DescribeReservedInstancesRequest struct {
	DryRun               aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters              []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	OfferingType         aws.StringValue  `ec2:"OfferingType" xml:"offeringType"`
	ReservedInstancesIDs []string         `ec2:"ReservedInstancesId" xml:"ReservedInstancesId>ReservedInstancesId"`
}

func (v *DescribeReservedInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	OfferingTypeEnum := []string{
		OfferingTypeValuesHeavyUtilization,
		OfferingTypeValuesLightUtilization,
		OfferingTypeValuesMediumUtilization,
	}
	if err := model.ValidateEnum(v, "OfferingType", OfferingTypeEnum); err != nil {
		errors["OfferingType"] = append(errors["OfferingType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedInstancesResult is undocumented.
type DescribeReservedInstancesResult struct {
	ReservedInstances []ReservedInstances `ec2:"ReservedInstances" xml:"reservedInstancesSet>item"`
}

func (v *DescribeReservedInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeRouteTablesRequest is undocumented.
type DescribeRouteTablesRequest struct {
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters       []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	RouteTableIDs []string         `ec2:"RouteTableId" xml:"RouteTableId>item"`
}

func (v *DescribeRouteTablesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeRouteTablesResult is undocumented.
type DescribeRouteTablesResult struct {
	RouteTables []RouteTable `ec2:"RouteTables" xml:"routeTableSet>item"`
}

func (v *DescribeRouteTablesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSecurityGroupsRequest is undocumented.
type DescribeSecurityGroupsRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters    []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	GroupIDs   []string         `ec2:"GroupId" xml:"GroupId>groupId"`
	GroupNames []string         `ec2:"GroupName" xml:"GroupName>GroupName"`
}

func (v *DescribeSecurityGroupsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSecurityGroupsResult is undocumented.
type DescribeSecurityGroupsResult struct {
	SecurityGroups []SecurityGroup `ec2:"SecurityGroups" xml:"securityGroupInfo>item"`
}

func (v *DescribeSecurityGroupsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSnapshotAttributeRequest is undocumented.
type DescribeSnapshotAttributeRequest struct {
	Attribute  aws.StringValue  `ec2:"Attribute" xml:"Attribute"`
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	SnapshotID aws.StringValue  `ec2:"SnapshotId" xml:"SnapshotId"`
}

func (v *DescribeSnapshotAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Attribute"); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	AttributeEnum := []string{
		SnapshotAttributeNameCreateVolumePermission,
		SnapshotAttributeNameProductCodes,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotID"); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSnapshotAttributeResult is undocumented.
type DescribeSnapshotAttributeResult struct {
	CreateVolumePermissions []CreateVolumePermission `ec2:"CreateVolumePermissions" xml:"createVolumePermission>item"`
	ProductCodes            []ProductCode            `ec2:"ProductCodes" xml:"productCodes>item"`
	SnapshotID              aws.StringValue          `ec2:"SnapshotId" xml:"snapshotId"`
}

func (v *DescribeSnapshotAttributeResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSnapshotsRequest is undocumented.
type DescribeSnapshotsRequest struct {
	DryRun              aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters             []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	OwnerIDs            []string         `ec2:"Owner" xml:"Owner>Owner"`
	RestorableByUserIDs []string         `ec2:"RestorableBy" xml:"RestorableBy>member"`
	SnapshotIDs         []string         `ec2:"SnapshotId" xml:"SnapshotId>SnapshotId"`
}

func (v *DescribeSnapshotsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSnapshotsResult is undocumented.
type DescribeSnapshotsResult struct {
	Snapshots []Snapshot `ec2:"Snapshots" xml:"snapshotSet>item"`
}

func (v *DescribeSnapshotsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSpotDatafeedSubscriptionRequest is undocumented.
type DescribeSpotDatafeedSubscriptionRequest struct {
	DryRun aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *DescribeSpotDatafeedSubscriptionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSpotDatafeedSubscriptionResult is undocumented.
type DescribeSpotDatafeedSubscriptionResult struct {
	SpotDatafeedSubscription *SpotDatafeedSubscription `ec2:"SpotDatafeedSubscription" xml:"spotDatafeedSubscription"`
}

func (v *DescribeSpotDatafeedSubscriptionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSpotInstanceRequestsRequest is undocumented.
type DescribeSpotInstanceRequestsRequest struct {
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters                []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	SpotInstanceRequestIDs []string         `ec2:"SpotInstanceRequestId" xml:"SpotInstanceRequestId>SpotInstanceRequestId"`
}

func (v *DescribeSpotInstanceRequestsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSpotInstanceRequestsResult is undocumented.
type DescribeSpotInstanceRequestsResult struct {
	SpotInstanceRequests []SpotInstanceRequest `ec2:"SpotInstanceRequests" xml:"spotInstanceRequestSet>item"`
}

func (v *DescribeSpotInstanceRequestsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSpotPriceHistoryRequest is undocumented.
type DescribeSpotPriceHistoryRequest struct {
	AvailabilityZone    aws.StringValue  `ec2:"AvailabilityZone" xml:"availabilityZone"`
	DryRun              aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	EndTime             time.Time        `ec2:"EndTime" xml:"endTime"`
	Filters             []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	InstanceTypes       []string         `ec2:"InstanceType" xml:"InstanceType>member"`
	MaxResults          aws.IntegerValue `ec2:"MaxResults" xml:"maxResults"`
	NextToken           aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
	ProductDescriptions []string         `ec2:"ProductDescription" xml:"ProductDescription>member"`
	StartTime           time.Time        `ec2:"StartTime" xml:"startTime"`
}

func (v *DescribeSpotPriceHistoryRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSpotPriceHistoryResult is undocumented.
type DescribeSpotPriceHistoryResult struct {
	NextToken        aws.StringValue `ec2:"NextToken" xml:"nextToken"`
	SpotPriceHistory []SpotPrice     `ec2:"SpotPriceHistory" xml:"spotPriceHistorySet>item"`
}

func (v *DescribeSpotPriceHistoryResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSubnetsRequest is undocumented.
type DescribeSubnetsRequest struct {
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters   []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	SubnetIDs []string         `ec2:"SubnetId" xml:"SubnetId>SubnetId"`
}

func (v *DescribeSubnetsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSubnetsResult is undocumented.
type DescribeSubnetsResult struct {
	Subnets []Subnet `ec2:"Subnets" xml:"subnetSet>item"`
}

func (v *DescribeSubnetsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTagsRequest is undocumented.
type DescribeTagsRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters    []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	MaxResults aws.IntegerValue `ec2:"MaxResults" xml:"maxResults"`
	NextToken  aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
}

func (v *DescribeTagsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTagsResult is undocumented.
type DescribeTagsResult struct {
	NextToken aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
	Tags      []TagDescription `ec2:"Tags" xml:"tagSet>item"`
}

func (v *DescribeTagsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVolumeAttributeRequest is undocumented.
type DescribeVolumeAttributeRequest struct {
	Attribute aws.StringValue  `ec2:"Attribute" xml:"Attribute"`
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VolumeID  aws.StringValue  `ec2:"VolumeId" xml:"VolumeId"`
}

func (v *DescribeVolumeAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AttributeEnum := []string{
		VolumeAttributeNameAutoEnableIo,
		VolumeAttributeNameProductCodes,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVolumeAttributeResult is undocumented.
type DescribeVolumeAttributeResult struct {
	AutoEnableIO *AttributeBooleanValue `ec2:"AutoEnableIO" xml:"autoEnableIO"`
	ProductCodes []ProductCode          `ec2:"ProductCodes" xml:"productCodes>item"`
	VolumeID     aws.StringValue        `ec2:"VolumeId" xml:"volumeId"`
}

func (v *DescribeVolumeAttributeResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVolumeStatusRequest is undocumented.
type DescribeVolumeStatusRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters    []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	MaxResults aws.IntegerValue `ec2:"MaxResults" xml:"MaxResults"`
	NextToken  aws.StringValue  `ec2:"NextToken" xml:"NextToken"`
	VolumeIDs  []string         `ec2:"VolumeId" xml:"VolumeId>VolumeId"`
}

func (v *DescribeVolumeStatusRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVolumeStatusResult is undocumented.
type DescribeVolumeStatusResult struct {
	NextToken      aws.StringValue    `ec2:"NextToken" xml:"nextToken"`
	VolumeStatuses []VolumeStatusItem `ec2:"VolumeStatuses" xml:"volumeStatusSet>item"`
}

func (v *DescribeVolumeStatusResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVolumesRequest is undocumented.
type DescribeVolumesRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters    []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	MaxResults aws.IntegerValue `ec2:"MaxResults" xml:"maxResults"`
	NextToken  aws.StringValue  `ec2:"NextToken" xml:"nextToken"`
	VolumeIDs  []string         `ec2:"VolumeId" xml:"VolumeId>VolumeId"`
}

func (v *DescribeVolumesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVolumesResult is undocumented.
type DescribeVolumesResult struct {
	NextToken aws.StringValue `ec2:"NextToken" xml:"nextToken"`
	Volumes   []Volume        `ec2:"Volumes" xml:"volumeSet>item"`
}

func (v *DescribeVolumesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPCAttributeRequest is undocumented.
type DescribeVPCAttributeRequest struct {
	Attribute aws.StringValue  `ec2:"Attribute" xml:"Attribute"`
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID     aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
}

func (v *DescribeVPCAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AttributeEnum := []string{
		VPCAttributeNameEnableDNSHostnames,
		VPCAttributeNameEnableDNSSupport,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPCAttributeResult is undocumented.
type DescribeVPCAttributeResult struct {
	EnableDNSHostnames *AttributeBooleanValue `ec2:"EnableDnsHostnames" xml:"enableDnsHostnames"`
	EnableDNSSupport   *AttributeBooleanValue `ec2:"EnableDnsSupport" xml:"enableDnsSupport"`
	VPCID              aws.StringValue        `ec2:"VpcId" xml:"vpcId"`
}

func (v *DescribeVPCAttributeResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPCPeeringConnectionsRequest is undocumented.
type DescribeVPCPeeringConnectionsRequest struct {
	DryRun                  aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters                 []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	VPCPeeringConnectionIDs []string         `ec2:"VpcPeeringConnectionId" xml:"VpcPeeringConnectionId>item"`
}

func (v *DescribeVPCPeeringConnectionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPCPeeringConnectionsResult is undocumented.
type DescribeVPCPeeringConnectionsResult struct {
	VPCPeeringConnections []VPCPeeringConnection `ec2:"VpcPeeringConnections" xml:"vpcPeeringConnectionSet>item"`
}

func (v *DescribeVPCPeeringConnectionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPCsRequest is undocumented.
type DescribeVPCsRequest struct {
	DryRun  aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	VPCIDs  []string         `ec2:"VpcId" xml:"VpcId>VpcId"`
}

func (v *DescribeVPCsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPCsResult is undocumented.
type DescribeVPCsResult struct {
	VPCs []VPC `ec2:"Vpcs" xml:"vpcSet>item"`
}

func (v *DescribeVPCsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPNConnectionsRequest is undocumented.
type DescribeVPNConnectionsRequest struct {
	DryRun           aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters          []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	VPNConnectionIDs []string         `ec2:"VpnConnectionId" xml:"VpnConnectionId>VpnConnectionId"`
}

func (v *DescribeVPNConnectionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPNConnectionsResult is undocumented.
type DescribeVPNConnectionsResult struct {
	VPNConnections []VPNConnection `ec2:"VpnConnections" xml:"vpnConnectionSet>item"`
}

func (v *DescribeVPNConnectionsResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPNGatewaysRequest is undocumented.
type DescribeVPNGatewaysRequest struct {
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Filters       []Filter         `ec2:"Filter" xml:"Filter>Filter"`
	VPNGatewayIDs []string         `ec2:"VpnGatewayId" xml:"VpnGatewayId>VpnGatewayId"`
}

func (v *DescribeVPNGatewaysRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeVPNGatewaysResult is undocumented.
type DescribeVPNGatewaysResult struct {
	VPNGateways []VPNGateway `ec2:"VpnGateways" xml:"vpnGatewaySet>item"`
}

func (v *DescribeVPNGatewaysResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DetachInternetGatewayRequest is undocumented.
type DetachInternetGatewayRequest struct {
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InternetGatewayID aws.StringValue  `ec2:"InternetGatewayId" xml:"internetGatewayId"`
	VPCID             aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *DetachInternetGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InternetGatewayID"); err != nil {
		errors["InternetGatewayID"] = append(errors["InternetGatewayID"], err)
	}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DetachNetworkInterfaceRequest is undocumented.
type DetachNetworkInterfaceRequest struct {
	AttachmentID aws.StringValue  `ec2:"AttachmentId" xml:"attachmentId"`
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Force        aws.BooleanValue `ec2:"Force" xml:"force"`
}

func (v *DetachNetworkInterfaceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AttachmentID"); err != nil {
		errors["AttachmentID"] = append(errors["AttachmentID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DetachVolumeRequest is undocumented.
type DetachVolumeRequest struct {
	Device     aws.StringValue  `ec2:"Device" xml:"Device"`
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Force      aws.BooleanValue `ec2:"Force" xml:"Force"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
	VolumeID   aws.StringValue  `ec2:"VolumeId" xml:"VolumeId"`
}

func (v *DetachVolumeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DetachVPNGatewayRequest is undocumented.
type DetachVPNGatewayRequest struct {
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCID        aws.StringValue  `ec2:"VpcId" xml:"VpcId"`
	VPNGatewayID aws.StringValue  `ec2:"VpnGatewayId" xml:"VpnGatewayId"`
}

func (v *DetachVPNGatewayRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if err := model.ValidateRequired(v, "VPNGatewayID"); err != nil {
		errors["VPNGatewayID"] = append(errors["VPNGatewayID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	DeviceTypeEBS           = "ebs"
	DeviceTypeInstanceStore = "instance-store"
)

// DHCPConfiguration is undocumented.
type DHCPConfiguration struct {
	Key    aws.StringValue  `ec2:"Key" xml:"key"`
	Values []AttributeValue `ec2:"Values" xml:"valueSet>item"`
}

func (v *DHCPConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DHCPOptions is undocumented.
type DHCPOptions struct {
	DHCPConfigurations []DHCPConfiguration `ec2:"DhcpConfigurations" xml:"dhcpConfigurationSet>item"`
	DHCPOptionsID      aws.StringValue     `ec2:"DhcpOptionsId" xml:"dhcpOptionsId"`
	Tags               []Tag               `ec2:"Tags" xml:"tagSet>item"`
}

func (v *DHCPOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisableVGWRoutePropagationRequest is undocumented.
type DisableVGWRoutePropagationRequest struct {
	GatewayID    aws.StringValue `ec2:"GatewayId" xml:"GatewayId"`
	RouteTableID aws.StringValue `ec2:"RouteTableId" xml:"RouteTableId"`
}

func (v *DisableVGWRoutePropagationRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayID"); err != nil {
		errors["GatewayID"] = append(errors["GatewayID"], err)
	}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisassociateAddressRequest is undocumented.
type DisassociateAddressRequest struct {
	AssociationID aws.StringValue  `ec2:"AssociationId" xml:"AssociationId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	PublicIP      aws.StringValue  `ec2:"PublicIp" xml:"PublicIp"`
}

func (v *DisassociateAddressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisassociateRouteTableRequest is undocumented.
type DisassociateRouteTableRequest struct {
	AssociationID aws.StringValue  `ec2:"AssociationId" xml:"associationId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
}

func (v *DisassociateRouteTableRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AssociationID"); err != nil {
		errors["AssociationID"] = append(errors["AssociationID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DiskImage is undocumented.
type DiskImage struct {
	Description aws.StringValue  `ec2:"Description" xml:"Description"`
	Image       *DiskImageDetail `ec2:"Image" xml:"Image"`
	Volume      *VolumeDetail    `ec2:"Volume" xml:"Volume"`
}

func (v *DiskImage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DiskImageDescription is undocumented.
type DiskImageDescription struct {
	Checksum          aws.StringValue `ec2:"Checksum" xml:"checksum"`
	Format            aws.StringValue `ec2:"Format" xml:"format"`
	ImportManifestURL aws.StringValue `ec2:"ImportManifestUrl" xml:"importManifestUrl"`
	Size              aws.LongValue   `ec2:"Size" xml:"size"`
}

func (v *DiskImageDescription) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Format"); err != nil {
		errors["Format"] = append(errors["Format"], err)
	}

	FormatEnum := []string{
		DiskImageFormatRaw,
		DiskImageFormatVHD,
		DiskImageFormatVMDK,
	}
	if err := model.ValidateEnum(v, "Format", FormatEnum); err != nil {
		errors["Format"] = append(errors["Format"], err)
	}

	if err := model.ValidateRequired(v, "ImportManifestURL"); err != nil {
		errors["ImportManifestURL"] = append(errors["ImportManifestURL"], err)
	}

	if err := model.ValidateRequired(v, "Size"); err != nil {
		errors["Size"] = append(errors["Size"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DiskImageDetail is undocumented.
type DiskImageDetail struct {
	Bytes             aws.LongValue   `ec2:"Bytes" xml:"bytes"`
	Format            aws.StringValue `ec2:"Format" xml:"format"`
	ImportManifestURL aws.StringValue `ec2:"ImportManifestUrl" xml:"importManifestUrl"`
}

func (v *DiskImageDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Bytes"); err != nil {
		errors["Bytes"] = append(errors["Bytes"], err)
	}

	if err := model.ValidateRequired(v, "Format"); err != nil {
		errors["Format"] = append(errors["Format"], err)
	}

	FormatEnum := []string{
		DiskImageFormatRaw,
		DiskImageFormatVHD,
		DiskImageFormatVMDK,
	}
	if err := model.ValidateEnum(v, "Format", FormatEnum); err != nil {
		errors["Format"] = append(errors["Format"], err)
	}

	if err := model.ValidateRequired(v, "ImportManifestURL"); err != nil {
		errors["ImportManifestURL"] = append(errors["ImportManifestURL"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	DiskImageFormatRaw  = "RAW"
	DiskImageFormatVHD  = "VHD"
	DiskImageFormatVMDK = "VMDK"
)

// DiskImageVolumeDescription is undocumented.
type DiskImageVolumeDescription struct {
	ID   aws.StringValue `ec2:"Id" xml:"id"`
	Size aws.LongValue   `ec2:"Size" xml:"size"`
}

func (v *DiskImageVolumeDescription) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ID"); err != nil {
		errors["ID"] = append(errors["ID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	DomainTypeStandard = "standard"
	DomainTypeVPC      = "vpc"
)

// EBSBlockDevice is undocumented.
type EBSBlockDevice struct {
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	Encrypted           aws.BooleanValue `ec2:"Encrypted" xml:"encrypted"`
	IOPS                aws.IntegerValue `ec2:"Iops" xml:"iops"`
	SnapshotID          aws.StringValue  `ec2:"SnapshotId" xml:"snapshotId"`
	VolumeSize          aws.IntegerValue `ec2:"VolumeSize" xml:"volumeSize"`
	VolumeType          aws.StringValue  `ec2:"VolumeType" xml:"volumeType"`
}

func (v *EBSBlockDevice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	VolumeTypeEnum := []string{
		VolumeTypeGp2,
		VolumeTypeIo1,
		VolumeTypeStandard,
	}
	if err := model.ValidateEnum(v, "VolumeType", VolumeTypeEnum); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EBSInstanceBlockDevice is undocumented.
type EBSInstanceBlockDevice struct {
	AttachTime          time.Time        `ec2:"AttachTime" xml:"attachTime"`
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	Status              aws.StringValue  `ec2:"Status" xml:"status"`
	VolumeID            aws.StringValue  `ec2:"VolumeId" xml:"volumeId"`
}

func (v *EBSInstanceBlockDevice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		AttachmentStatusAttached,
		AttachmentStatusAttaching,
		AttachmentStatusDetached,
		AttachmentStatusDetaching,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EBSInstanceBlockDeviceSpecification is undocumented.
type EBSInstanceBlockDeviceSpecification struct {
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	VolumeID            aws.StringValue  `ec2:"VolumeId" xml:"volumeId"`
}

func (v *EBSInstanceBlockDeviceSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EnableVGWRoutePropagationRequest is undocumented.
type EnableVGWRoutePropagationRequest struct {
	GatewayID    aws.StringValue `ec2:"GatewayId" xml:"GatewayId"`
	RouteTableID aws.StringValue `ec2:"RouteTableId" xml:"RouteTableId"`
}

func (v *EnableVGWRoutePropagationRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GatewayID"); err != nil {
		errors["GatewayID"] = append(errors["GatewayID"], err)
	}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EnableVolumeIORequest is undocumented.
type EnableVolumeIORequest struct {
	DryRun   aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VolumeID aws.StringValue  `ec2:"VolumeId" xml:"volumeId"`
}

func (v *EnableVolumeIORequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	EventCodeInstanceReboot     = "instance-reboot"
	EventCodeInstanceRetirement = "instance-retirement"
	EventCodeInstanceStop       = "instance-stop"
	EventCodeSystemMaintenance  = "system-maintenance"
	EventCodeSystemReboot       = "system-reboot"
)

// Possible values for EC2.
const (
	ExportEnvironmentCitrix    = "citrix"
	ExportEnvironmentMicrosoft = "microsoft"
	ExportEnvironmentVMware    = "vmware"
)

// ExportTask is undocumented.
type ExportTask struct {
	Description           aws.StringValue        `ec2:"Description" xml:"description"`
	ExportTaskID          aws.StringValue        `ec2:"ExportTaskId" xml:"exportTaskId"`
	ExportToS3Task        *ExportToS3Task        `ec2:"ExportToS3Task" xml:"exportToS3"`
	InstanceExportDetails *InstanceExportDetails `ec2:"InstanceExportDetails" xml:"instanceExport"`
	State                 aws.StringValue        `ec2:"State" xml:"state"`
	StatusMessage         aws.StringValue        `ec2:"StatusMessage" xml:"statusMessage"`
}

func (v *ExportTask) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		ExportTaskStateActive,
		ExportTaskStateCancelled,
		ExportTaskStateCancelling,
		ExportTaskStateCompleted,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ExportTaskStateActive     = "active"
	ExportTaskStateCancelled  = "cancelled"
	ExportTaskStateCancelling = "cancelling"
	ExportTaskStateCompleted  = "completed"
)

// ExportToS3Task is undocumented.
type ExportToS3Task struct {
	ContainerFormat aws.StringValue `ec2:"ContainerFormat" xml:"containerFormat"`
	DiskImageFormat aws.StringValue `ec2:"DiskImageFormat" xml:"diskImageFormat"`
	S3Bucket        aws.StringValue `ec2:"S3Bucket" xml:"s3Bucket"`
	S3Key           aws.StringValue `ec2:"S3Key" xml:"s3Key"`
}

func (v *ExportToS3Task) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ContainerFormatEnum := []string{
		ContainerFormatOva,
	}
	if err := model.ValidateEnum(v, "ContainerFormat", ContainerFormatEnum); err != nil {
		errors["ContainerFormat"] = append(errors["ContainerFormat"], err)
	}

	DiskImageFormatEnum := []string{
		DiskImageFormatRaw,
		DiskImageFormatVHD,
		DiskImageFormatVMDK,
	}
	if err := model.ValidateEnum(v, "DiskImageFormat", DiskImageFormatEnum); err != nil {
		errors["DiskImageFormat"] = append(errors["DiskImageFormat"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ExportToS3TaskSpecification is undocumented.
type ExportToS3TaskSpecification struct {
	ContainerFormat aws.StringValue `ec2:"ContainerFormat" xml:"containerFormat"`
	DiskImageFormat aws.StringValue `ec2:"DiskImageFormat" xml:"diskImageFormat"`
	S3Bucket        aws.StringValue `ec2:"S3Bucket" xml:"s3Bucket"`
	S3Prefix        aws.StringValue `ec2:"S3Prefix" xml:"s3Prefix"`
}

func (v *ExportToS3TaskSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ContainerFormatEnum := []string{
		ContainerFormatOva,
	}
	if err := model.ValidateEnum(v, "ContainerFormat", ContainerFormatEnum); err != nil {
		errors["ContainerFormat"] = append(errors["ContainerFormat"], err)
	}

	DiskImageFormatEnum := []string{
		DiskImageFormatRaw,
		DiskImageFormatVHD,
		DiskImageFormatVMDK,
	}
	if err := model.ValidateEnum(v, "DiskImageFormat", DiskImageFormatEnum); err != nil {
		errors["DiskImageFormat"] = append(errors["DiskImageFormat"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Filter is undocumented.
type Filter struct {
	Name   aws.StringValue `ec2:"Name" xml:"Name"`
	Values []string        `ec2:"Value" xml:"Value>item"`
}

func (v *Filter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	GatewayTypeIPsec1 = "ipsec.1"
)

// GetConsoleOutputRequest is undocumented.
type GetConsoleOutputRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
}

func (v *GetConsoleOutputRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetConsoleOutputResult is undocumented.
type GetConsoleOutputResult struct {
	InstanceID aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	Output     aws.StringValue `ec2:"Output" xml:"output"`
	Timestamp  time.Time       `ec2:"Timestamp" xml:"timestamp"`
}

func (v *GetConsoleOutputResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetPasswordDataRequest is undocumented.
type GetPasswordDataRequest struct {
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"InstanceId"`
}

func (v *GetPasswordDataRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetPasswordDataResult is undocumented.
type GetPasswordDataResult struct {
	InstanceID   aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	PasswordData aws.StringValue `ec2:"PasswordData" xml:"passwordData"`
	Timestamp    time.Time       `ec2:"Timestamp" xml:"timestamp"`
}

func (v *GetPasswordDataResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GroupIdentifier is undocumented.
type GroupIdentifier struct {
	GroupID   aws.StringValue `ec2:"GroupId" xml:"groupId"`
	GroupName aws.StringValue `ec2:"GroupName" xml:"groupName"`
}

func (v *GroupIdentifier) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	HypervisorTypeOvm = "ovm"
	HypervisorTypeXen = "xen"
)

// IAMInstanceProfile is undocumented.
type IAMInstanceProfile struct {
	ARN aws.StringValue `ec2:"Arn" xml:"arn"`
	ID  aws.StringValue `ec2:"Id" xml:"id"`
}

func (v *IAMInstanceProfile) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IAMInstanceProfileSpecification is undocumented.
type IAMInstanceProfileSpecification struct {
	ARN  aws.StringValue `ec2:"Arn" xml:"arn"`
	Name aws.StringValue `ec2:"Name" xml:"name"`
}

func (v *IAMInstanceProfileSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ICMPTypeCode is undocumented.
type ICMPTypeCode struct {
	Code aws.IntegerValue `ec2:"Code" xml:"code"`
	Type aws.IntegerValue `ec2:"Type" xml:"type"`
}

func (v *ICMPTypeCode) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Image is undocumented.
type Image struct {
	Architecture        aws.StringValue      `ec2:"Architecture" xml:"architecture"`
	BlockDeviceMappings []BlockDeviceMapping `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	Description         aws.StringValue      `ec2:"Description" xml:"description"`
	Hypervisor          aws.StringValue      `ec2:"Hypervisor" xml:"hypervisor"`
	ImageID             aws.StringValue      `ec2:"ImageId" xml:"imageId"`
	ImageLocation       aws.StringValue      `ec2:"ImageLocation" xml:"imageLocation"`
	ImageOwnerAlias     aws.StringValue      `ec2:"ImageOwnerAlias" xml:"imageOwnerAlias"`
	ImageType           aws.StringValue      `ec2:"ImageType" xml:"imageType"`
	KernelID            aws.StringValue      `ec2:"KernelId" xml:"kernelId"`
	Name                aws.StringValue      `ec2:"Name" xml:"name"`
	OwnerID             aws.StringValue      `ec2:"OwnerId" xml:"imageOwnerId"`
	Platform            aws.StringValue      `ec2:"Platform" xml:"platform"`
	ProductCodes        []ProductCode        `ec2:"ProductCodes" xml:"productCodes>item"`
	Public              aws.BooleanValue     `ec2:"Public" xml:"isPublic"`
	RAMDiskID           aws.StringValue      `ec2:"RamdiskId" xml:"ramdiskId"`
	RootDeviceName      aws.StringValue      `ec2:"RootDeviceName" xml:"rootDeviceName"`
	RootDeviceType      aws.StringValue      `ec2:"RootDeviceType" xml:"rootDeviceType"`
	SRIOVNetSupport     aws.StringValue      `ec2:"SriovNetSupport" xml:"sriovNetSupport"`
	State               aws.StringValue      `ec2:"State" xml:"imageState"`
	StateReason         *StateReason         `ec2:"StateReason" xml:"stateReason"`
	Tags                []Tag                `ec2:"Tags" xml:"tagSet>item"`
	VirtualizationType  aws.StringValue      `ec2:"VirtualizationType" xml:"virtualizationType"`
}

func (v *Image) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ArchitectureEnum := []string{
		ArchitectureValuesI386,
		ArchitectureValuesX8664,
	}
	if err := model.ValidateEnum(v, "Architecture", ArchitectureEnum); err != nil {
		errors["Architecture"] = append(errors["Architecture"], err)
	}

	HypervisorEnum := []string{
		HypervisorTypeOvm,
		HypervisorTypeXen,
	}
	if err := model.ValidateEnum(v, "Hypervisor", HypervisorEnum); err != nil {
		errors["Hypervisor"] = append(errors["Hypervisor"], err)
	}

	ImageTypeEnum := []string{
		ImageTypeValuesKernel,
		ImageTypeValuesMachine,
		ImageTypeValuesRAMDisk,
	}
	if err := model.ValidateEnum(v, "ImageType", ImageTypeEnum); err != nil {
		errors["ImageType"] = append(errors["ImageType"], err)
	}

	PlatformEnum := []string{
		PlatformValuesWindows,
	}
	if err := model.ValidateEnum(v, "Platform", PlatformEnum); err != nil {
		errors["Platform"] = append(errors["Platform"], err)
	}

	RootDeviceTypeEnum := []string{
		DeviceTypeEBS,
		DeviceTypeInstanceStore,
	}
	if err := model.ValidateEnum(v, "RootDeviceType", RootDeviceTypeEnum); err != nil {
		errors["RootDeviceType"] = append(errors["RootDeviceType"], err)
	}

	StateEnum := []string{
		ImageStateAvailable,
		ImageStateDeregistered,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	VirtualizationTypeEnum := []string{
		VirtualizationTypeHVM,
		VirtualizationTypeParavirtual,
	}
	if err := model.ValidateEnum(v, "VirtualizationType", VirtualizationTypeEnum); err != nil {
		errors["VirtualizationType"] = append(errors["VirtualizationType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImageAttribute is undocumented.
type ImageAttribute struct {
	BlockDeviceMappings []BlockDeviceMapping `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	Description         *AttributeValue      `ec2:"Description" xml:"description"`
	ImageID             aws.StringValue      `ec2:"ImageId" xml:"imageId"`
	KernelID            *AttributeValue      `ec2:"KernelId" xml:"kernel"`
	LaunchPermissions   []LaunchPermission   `ec2:"LaunchPermissions" xml:"launchPermission>item"`
	ProductCodes        []ProductCode        `ec2:"ProductCodes" xml:"productCodes>item"`
	RAMDiskID           *AttributeValue      `ec2:"RamdiskId" xml:"ramdisk"`
	SRIOVNetSupport     *AttributeValue      `ec2:"SriovNetSupport" xml:"sriovNetSupport"`
}

func (v *ImageAttribute) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ImageAttributeNameBlockDeviceMapping = "blockDeviceMapping"
	ImageAttributeNameDescription        = "description"
	ImageAttributeNameKernel             = "kernel"
	ImageAttributeNameLaunchPermission   = "launchPermission"
	ImageAttributeNameProductCodes       = "productCodes"
	ImageAttributeNameRAMDisk            = "ramdisk"
)

// Possible values for EC2.
const (
	ImageStateAvailable    = "available"
	ImageStateDeregistered = "deregistered"
)

// Possible values for EC2.
const (
	ImageTypeValuesKernel  = "kernel"
	ImageTypeValuesMachine = "machine"
	ImageTypeValuesRAMDisk = "ramdisk"
)

// ImportInstanceLaunchSpecification is undocumented.
type ImportInstanceLaunchSpecification struct {
	AdditionalInfo                    aws.StringValue  `ec2:"AdditionalInfo" xml:"additionalInfo"`
	Architecture                      aws.StringValue  `ec2:"Architecture" xml:"architecture"`
	GroupIDs                          []string         `ec2:"GroupId" xml:"GroupId>SecurityGroupId"`
	GroupNames                        []string         `ec2:"GroupName" xml:"GroupName>SecurityGroup"`
	InstanceInitiatedShutdownBehavior aws.StringValue  `ec2:"InstanceInitiatedShutdownBehavior" xml:"instanceInitiatedShutdownBehavior"`
	InstanceType                      aws.StringValue  `ec2:"InstanceType" xml:"instanceType"`
	Monitoring                        aws.BooleanValue `ec2:"Monitoring" xml:"monitoring"`
	Placement                         *Placement       `ec2:"Placement" xml:"placement"`
	PrivateIPAddress                  aws.StringValue  `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	SubnetID                          aws.StringValue  `ec2:"SubnetId" xml:"subnetId"`
	UserData                          aws.StringValue  `ec2:"UserData" xml:"userData"`
}

func (v *ImportInstanceLaunchSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ArchitectureEnum := []string{
		ArchitectureValuesI386,
		ArchitectureValuesX8664,
	}
	if err := model.ValidateEnum(v, "Architecture", ArchitectureEnum); err != nil {
		errors["Architecture"] = append(errors["Architecture"], err)
	}

	InstanceInitiatedShutdownBehaviorEnum := []string{
		ShutdownBehaviorStop,
		ShutdownBehaviorTerminate,
	}
	if err := model.ValidateEnum(v, "InstanceInitiatedShutdownBehavior", InstanceInitiatedShutdownBehaviorEnum); err != nil {
		errors["InstanceInitiatedShutdownBehavior"] = append(errors["InstanceInitiatedShutdownBehavior"], err)
	}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportInstanceRequest is undocumented.
type ImportInstanceRequest struct {
	Description         aws.StringValue                    `ec2:"Description" xml:"description"`
	DiskImages          []DiskImage                        `ec2:"DiskImages" xml:"diskImage>member"`
	DryRun              aws.BooleanValue                   `ec2:"DryRun" xml:"dryRun"`
	LaunchSpecification *ImportInstanceLaunchSpecification `ec2:"LaunchSpecification" xml:"launchSpecification"`
	Platform            aws.StringValue                    `ec2:"Platform" xml:"platform"`
}

func (v *ImportInstanceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Platform"); err != nil {
		errors["Platform"] = append(errors["Platform"], err)
	}

	PlatformEnum := []string{
		PlatformValuesWindows,
	}
	if err := model.ValidateEnum(v, "Platform", PlatformEnum); err != nil {
		errors["Platform"] = append(errors["Platform"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportInstanceResult is undocumented.
type ImportInstanceResult struct {
	ConversionTask *ConversionTask `ec2:"ConversionTask" xml:"conversionTask"`
}

func (v *ImportInstanceResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportInstanceTaskDetails is undocumented.
type ImportInstanceTaskDetails struct {
	Description aws.StringValue                  `ec2:"Description" xml:"description"`
	InstanceID  aws.StringValue                  `ec2:"InstanceId" xml:"instanceId"`
	Platform    aws.StringValue                  `ec2:"Platform" xml:"platform"`
	Volumes     []ImportInstanceVolumeDetailItem `ec2:"Volumes" xml:"volumes>item"`
}

func (v *ImportInstanceTaskDetails) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	PlatformEnum := []string{
		PlatformValuesWindows,
	}
	if err := model.ValidateEnum(v, "Platform", PlatformEnum); err != nil {
		errors["Platform"] = append(errors["Platform"], err)
	}

	if err := model.ValidateRequired(v, "Volumes"); err != nil {
		errors["Volumes"] = append(errors["Volumes"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportInstanceVolumeDetailItem is undocumented.
type ImportInstanceVolumeDetailItem struct {
	AvailabilityZone aws.StringValue             `ec2:"AvailabilityZone" xml:"availabilityZone"`
	BytesConverted   aws.LongValue               `ec2:"BytesConverted" xml:"bytesConverted"`
	Description      aws.StringValue             `ec2:"Description" xml:"description"`
	Image            *DiskImageDescription       `ec2:"Image" xml:"image"`
	Status           aws.StringValue             `ec2:"Status" xml:"status"`
	StatusMessage    aws.StringValue             `ec2:"StatusMessage" xml:"statusMessage"`
	Volume           *DiskImageVolumeDescription `ec2:"Volume" xml:"volume"`
}

func (v *ImportInstanceVolumeDetailItem) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AvailabilityZone"); err != nil {
		errors["AvailabilityZone"] = append(errors["AvailabilityZone"], err)
	}

	if err := model.ValidateRequired(v, "BytesConverted"); err != nil {
		errors["BytesConverted"] = append(errors["BytesConverted"], err)
	}

	if err := model.ValidateRequired(v, "Image"); err != nil {
		errors["Image"] = append(errors["Image"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "Volume"); err != nil {
		errors["Volume"] = append(errors["Volume"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportKeyPairRequest is undocumented.
type ImportKeyPairRequest struct {
	DryRun            aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	KeyName           aws.StringValue  `ec2:"KeyName" xml:"keyName"`
	PublicKeyMaterial []byte           `ec2:"PublicKeyMaterial" xml:"publicKeyMaterial"`
}

func (v *ImportKeyPairRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "KeyName"); err != nil {
		errors["KeyName"] = append(errors["KeyName"], err)
	}

	if err := model.ValidateRequired(v, "PublicKeyMaterial"); err != nil {
		errors["PublicKeyMaterial"] = append(errors["PublicKeyMaterial"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportKeyPairResult is undocumented.
type ImportKeyPairResult struct {
	KeyFingerprint aws.StringValue `ec2:"KeyFingerprint" xml:"keyFingerprint"`
	KeyName        aws.StringValue `ec2:"KeyName" xml:"keyName"`
}

func (v *ImportKeyPairResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportVolumeRequest is undocumented.
type ImportVolumeRequest struct {
	AvailabilityZone aws.StringValue  `ec2:"AvailabilityZone" xml:"availabilityZone"`
	Description      aws.StringValue  `ec2:"Description" xml:"description"`
	DryRun           aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Image            *DiskImageDetail `ec2:"Image" xml:"image"`
	Volume           *VolumeDetail    `ec2:"Volume" xml:"volume"`
}

func (v *ImportVolumeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AvailabilityZone"); err != nil {
		errors["AvailabilityZone"] = append(errors["AvailabilityZone"], err)
	}

	if err := model.ValidateRequired(v, "Image"); err != nil {
		errors["Image"] = append(errors["Image"], err)
	}

	if err := model.ValidateRequired(v, "Volume"); err != nil {
		errors["Volume"] = append(errors["Volume"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportVolumeResult is undocumented.
type ImportVolumeResult struct {
	ConversionTask *ConversionTask `ec2:"ConversionTask" xml:"conversionTask"`
}

func (v *ImportVolumeResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ImportVolumeTaskDetails is undocumented.
type ImportVolumeTaskDetails struct {
	AvailabilityZone aws.StringValue             `ec2:"AvailabilityZone" xml:"availabilityZone"`
	BytesConverted   aws.LongValue               `ec2:"BytesConverted" xml:"bytesConverted"`
	Description      aws.StringValue             `ec2:"Description" xml:"description"`
	Image            *DiskImageDescription       `ec2:"Image" xml:"image"`
	Volume           *DiskImageVolumeDescription `ec2:"Volume" xml:"volume"`
}

func (v *ImportVolumeTaskDetails) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AvailabilityZone"); err != nil {
		errors["AvailabilityZone"] = append(errors["AvailabilityZone"], err)
	}

	if err := model.ValidateRequired(v, "BytesConverted"); err != nil {
		errors["BytesConverted"] = append(errors["BytesConverted"], err)
	}

	if err := model.ValidateRequired(v, "Image"); err != nil {
		errors["Image"] = append(errors["Image"], err)
	}

	if err := model.ValidateRequired(v, "Volume"); err != nil {
		errors["Volume"] = append(errors["Volume"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Instance is undocumented.
type Instance struct {
	AMILaunchIndex        aws.IntegerValue             `ec2:"AmiLaunchIndex" xml:"amiLaunchIndex"`
	Architecture          aws.StringValue              `ec2:"Architecture" xml:"architecture"`
	BlockDeviceMappings   []InstanceBlockDeviceMapping `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	ClientToken           aws.StringValue              `ec2:"ClientToken" xml:"clientToken"`
	EBSOptimized          aws.BooleanValue             `ec2:"EbsOptimized" xml:"ebsOptimized"`
	Hypervisor            aws.StringValue              `ec2:"Hypervisor" xml:"hypervisor"`
	IAMInstanceProfile    *IAMInstanceProfile          `ec2:"IamInstanceProfile" xml:"iamInstanceProfile"`
	ImageID               aws.StringValue              `ec2:"ImageId" xml:"imageId"`
	InstanceID            aws.StringValue              `ec2:"InstanceId" xml:"instanceId"`
	InstanceLifecycle     aws.StringValue              `ec2:"InstanceLifecycle" xml:"instanceLifecycle"`
	InstanceType          aws.StringValue              `ec2:"InstanceType" xml:"instanceType"`
	KernelID              aws.StringValue              `ec2:"KernelId" xml:"kernelId"`
	KeyName               aws.StringValue              `ec2:"KeyName" xml:"keyName"`
	LaunchTime            time.Time                    `ec2:"LaunchTime" xml:"launchTime"`
	Monitoring            *Monitoring                  `ec2:"Monitoring" xml:"monitoring"`
	NetworkInterfaces     []InstanceNetworkInterface   `ec2:"NetworkInterfaces" xml:"networkInterfaceSet>item"`
	Placement             *Placement                   `ec2:"Placement" xml:"placement"`
	Platform              aws.StringValue              `ec2:"Platform" xml:"platform"`
	PrivateDNSName        aws.StringValue              `ec2:"PrivateDnsName" xml:"privateDnsName"`
	PrivateIPAddress      aws.StringValue              `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	ProductCodes          []ProductCode                `ec2:"ProductCodes" xml:"productCodes>item"`
	PublicDNSName         aws.StringValue              `ec2:"PublicDnsName" xml:"dnsName"`
	PublicIPAddress       aws.StringValue              `ec2:"PublicIpAddress" xml:"ipAddress"`
	RAMDiskID             aws.StringValue              `ec2:"RamdiskId" xml:"ramdiskId"`
	RootDeviceName        aws.StringValue              `ec2:"RootDeviceName" xml:"rootDeviceName"`
	RootDeviceType        aws.StringValue              `ec2:"RootDeviceType" xml:"rootDeviceType"`
	SecurityGroups        []GroupIdentifier            `ec2:"SecurityGroups" xml:"groupSet>item"`
	SourceDestCheck       aws.BooleanValue             `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
	SpotInstanceRequestID aws.StringValue              `ec2:"SpotInstanceRequestId" xml:"spotInstanceRequestId"`
	SRIOVNetSupport       aws.StringValue              `ec2:"SriovNetSupport" xml:"sriovNetSupport"`
	State                 *InstanceState               `ec2:"State" xml:"instanceState"`
	StateReason           *StateReason                 `ec2:"StateReason" xml:"stateReason"`
	StateTransitionReason aws.StringValue              `ec2:"StateTransitionReason" xml:"reason"`
	SubnetID              aws.StringValue              `ec2:"SubnetId" xml:"subnetId"`
	Tags                  []Tag                        `ec2:"Tags" xml:"tagSet>item"`
	VirtualizationType    aws.StringValue              `ec2:"VirtualizationType" xml:"virtualizationType"`
	VPCID                 aws.StringValue              `ec2:"VpcId" xml:"vpcId"`
}

func (v *Instance) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ArchitectureEnum := []string{
		ArchitectureValuesI386,
		ArchitectureValuesX8664,
	}
	if err := model.ValidateEnum(v, "Architecture", ArchitectureEnum); err != nil {
		errors["Architecture"] = append(errors["Architecture"], err)
	}

	HypervisorEnum := []string{
		HypervisorTypeOvm,
		HypervisorTypeXen,
	}
	if err := model.ValidateEnum(v, "Hypervisor", HypervisorEnum); err != nil {
		errors["Hypervisor"] = append(errors["Hypervisor"], err)
	}

	InstanceLifecycleEnum := []string{
		InstanceLifecycleTypeSpot,
	}
	if err := model.ValidateEnum(v, "InstanceLifecycle", InstanceLifecycleEnum); err != nil {
		errors["InstanceLifecycle"] = append(errors["InstanceLifecycle"], err)
	}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	PlatformEnum := []string{
		PlatformValuesWindows,
	}
	if err := model.ValidateEnum(v, "Platform", PlatformEnum); err != nil {
		errors["Platform"] = append(errors["Platform"], err)
	}

	RootDeviceTypeEnum := []string{
		DeviceTypeEBS,
		DeviceTypeInstanceStore,
	}
	if err := model.ValidateEnum(v, "RootDeviceType", RootDeviceTypeEnum); err != nil {
		errors["RootDeviceType"] = append(errors["RootDeviceType"], err)
	}

	VirtualizationTypeEnum := []string{
		VirtualizationTypeHVM,
		VirtualizationTypeParavirtual,
	}
	if err := model.ValidateEnum(v, "VirtualizationType", VirtualizationTypeEnum); err != nil {
		errors["VirtualizationType"] = append(errors["VirtualizationType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceAttribute is undocumented.
type InstanceAttribute struct {
	BlockDeviceMappings               []InstanceBlockDeviceMapping `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	DisableAPITermination             *AttributeBooleanValue       `ec2:"DisableApiTermination" xml:"disableApiTermination"`
	EBSOptimized                      *AttributeBooleanValue       `ec2:"EbsOptimized" xml:"ebsOptimized"`
	Groups                            []GroupIdentifier            `ec2:"Groups" xml:"groupSet>item"`
	InstanceID                        aws.StringValue              `ec2:"InstanceId" xml:"instanceId"`
	InstanceInitiatedShutdownBehavior *AttributeValue              `ec2:"InstanceInitiatedShutdownBehavior" xml:"instanceInitiatedShutdownBehavior"`
	InstanceType                      *AttributeValue              `ec2:"InstanceType" xml:"instanceType"`
	KernelID                          *AttributeValue              `ec2:"KernelId" xml:"kernel"`
	ProductCodes                      []ProductCode                `ec2:"ProductCodes" xml:"productCodes>item"`
	RAMDiskID                         *AttributeValue              `ec2:"RamdiskId" xml:"ramdisk"`
	RootDeviceName                    *AttributeValue              `ec2:"RootDeviceName" xml:"rootDeviceName"`
	SourceDestCheck                   *AttributeBooleanValue       `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
	SRIOVNetSupport                   *AttributeValue              `ec2:"SriovNetSupport" xml:"sriovNetSupport"`
	UserData                          *AttributeValue              `ec2:"UserData" xml:"userData"`
}

func (v *InstanceAttribute) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	InstanceAttributeNameBlockDeviceMapping                = "blockDeviceMapping"
	InstanceAttributeNameDisableAPITermination             = "disableApiTermination"
	InstanceAttributeNameEBSOptimized                      = "ebsOptimized"
	InstanceAttributeNameGroupSet                          = "groupSet"
	InstanceAttributeNameInstanceInitiatedShutdownBehavior = "instanceInitiatedShutdownBehavior"
	InstanceAttributeNameInstanceType                      = "instanceType"
	InstanceAttributeNameKernel                            = "kernel"
	InstanceAttributeNameProductCodes                      = "productCodes"
	InstanceAttributeNameRAMDisk                           = "ramdisk"
	InstanceAttributeNameRootDeviceName                    = "rootDeviceName"
	InstanceAttributeNameSRIOVNetSupport                   = "sriovNetSupport"
	InstanceAttributeNameSourceDestCheck                   = "sourceDestCheck"
	InstanceAttributeNameUserData                          = "userData"
)

// InstanceBlockDeviceMapping is undocumented.
type InstanceBlockDeviceMapping struct {
	DeviceName aws.StringValue         `ec2:"DeviceName" xml:"deviceName"`
	EBS        *EBSInstanceBlockDevice `ec2:"Ebs" xml:"ebs"`
}

func (v *InstanceBlockDeviceMapping) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceBlockDeviceMappingSpecification is undocumented.
type InstanceBlockDeviceMappingSpecification struct {
	DeviceName  aws.StringValue                      `ec2:"DeviceName" xml:"deviceName"`
	EBS         *EBSInstanceBlockDeviceSpecification `ec2:"Ebs" xml:"ebs"`
	NoDevice    aws.StringValue                      `ec2:"NoDevice" xml:"noDevice"`
	VirtualName aws.StringValue                      `ec2:"VirtualName" xml:"virtualName"`
}

func (v *InstanceBlockDeviceMappingSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceCount is undocumented.
type InstanceCount struct {
	InstanceCount aws.IntegerValue `ec2:"InstanceCount" xml:"instanceCount"`
	State         aws.StringValue  `ec2:"State" xml:"state"`
}

func (v *InstanceCount) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		ListingStateAvailable,
		ListingStateCancelled,
		ListingStatePending,
		ListingStateSold,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceExportDetails is undocumented.
type InstanceExportDetails struct {
	InstanceID        aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	TargetEnvironment aws.StringValue `ec2:"TargetEnvironment" xml:"targetEnvironment"`
}

func (v *InstanceExportDetails) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	TargetEnvironmentEnum := []string{
		ExportEnvironmentCitrix,
		ExportEnvironmentMicrosoft,
		ExportEnvironmentVMware,
	}
	if err := model.ValidateEnum(v, "TargetEnvironment", TargetEnvironmentEnum); err != nil {
		errors["TargetEnvironment"] = append(errors["TargetEnvironment"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	InstanceLifecycleTypeSpot = "spot"
)

// InstanceMonitoring is undocumented.
type InstanceMonitoring struct {
	InstanceID aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	Monitoring *Monitoring     `ec2:"Monitoring" xml:"monitoring"`
}

func (v *InstanceMonitoring) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceNetworkInterface is undocumented.
type InstanceNetworkInterface struct {
	Association        *InstanceNetworkInterfaceAssociation `ec2:"Association" xml:"association"`
	Attachment         *InstanceNetworkInterfaceAttachment  `ec2:"Attachment" xml:"attachment"`
	Description        aws.StringValue                      `ec2:"Description" xml:"description"`
	Groups             []GroupIdentifier                    `ec2:"Groups" xml:"groupSet>item"`
	MACAddress         aws.StringValue                      `ec2:"MacAddress" xml:"macAddress"`
	NetworkInterfaceID aws.StringValue                      `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	OwnerID            aws.StringValue                      `ec2:"OwnerId" xml:"ownerId"`
	PrivateDNSName     aws.StringValue                      `ec2:"PrivateDnsName" xml:"privateDnsName"`
	PrivateIPAddress   aws.StringValue                      `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	PrivateIPAddresses []InstancePrivateIPAddress           `ec2:"PrivateIpAddresses" xml:"privateIpAddressesSet>item"`
	SourceDestCheck    aws.BooleanValue                     `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
	Status             aws.StringValue                      `ec2:"Status" xml:"status"`
	SubnetID           aws.StringValue                      `ec2:"SubnetId" xml:"subnetId"`
	VPCID              aws.StringValue                      `ec2:"VpcId" xml:"vpcId"`
}

func (v *InstanceNetworkInterface) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		NetworkInterfaceStatusAttaching,
		NetworkInterfaceStatusAvailable,
		NetworkInterfaceStatusDetaching,
		NetworkInterfaceStatusInUse,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceNetworkInterfaceAssociation is undocumented.
type InstanceNetworkInterfaceAssociation struct {
	IPOwnerID     aws.StringValue `ec2:"IpOwnerId" xml:"ipOwnerId"`
	PublicDNSName aws.StringValue `ec2:"PublicDnsName" xml:"publicDnsName"`
	PublicIP      aws.StringValue `ec2:"PublicIp" xml:"publicIp"`
}

func (v *InstanceNetworkInterfaceAssociation) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceNetworkInterfaceAttachment is undocumented.
type InstanceNetworkInterfaceAttachment struct {
	AttachTime          time.Time        `ec2:"AttachTime" xml:"attachTime"`
	AttachmentID        aws.StringValue  `ec2:"AttachmentId" xml:"attachmentId"`
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	DeviceIndex         aws.IntegerValue `ec2:"DeviceIndex" xml:"deviceIndex"`
	Status              aws.StringValue  `ec2:"Status" xml:"status"`
}

func (v *InstanceNetworkInterfaceAttachment) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		AttachmentStatusAttached,
		AttachmentStatusAttaching,
		AttachmentStatusDetached,
		AttachmentStatusDetaching,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceNetworkInterfaceSpecification is undocumented.
type InstanceNetworkInterfaceSpecification struct {
	AssociatePublicIPAddress       aws.BooleanValue                `ec2:"AssociatePublicIpAddress" xml:"associatePublicIpAddress"`
	DeleteOnTermination            aws.BooleanValue                `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	Description                    aws.StringValue                 `ec2:"Description" xml:"description"`
	DeviceIndex                    aws.IntegerValue                `ec2:"DeviceIndex" xml:"deviceIndex"`
	Groups                         []string                        `ec2:"SecurityGroupId" xml:"SecurityGroupId>SecurityGroupId"`
	NetworkInterfaceID             aws.StringValue                 `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	PrivateIPAddress               aws.StringValue                 `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	PrivateIPAddresses             []PrivateIPAddressSpecification `ec2:"PrivateIpAddresses" xml:"privateIpAddressesSet>item"`
	SecondaryPrivateIPAddressCount aws.IntegerValue                `ec2:"SecondaryPrivateIpAddressCount" xml:"secondaryPrivateIpAddressCount"`
	SubnetID                       aws.StringValue                 `ec2:"SubnetId" xml:"subnetId"`
}

func (v *InstanceNetworkInterfaceSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstancePrivateIPAddress is undocumented.
type InstancePrivateIPAddress struct {
	Association      *InstanceNetworkInterfaceAssociation `ec2:"Association" xml:"association"`
	Primary          aws.BooleanValue                     `ec2:"Primary" xml:"primary"`
	PrivateDNSName   aws.StringValue                      `ec2:"PrivateDnsName" xml:"privateDnsName"`
	PrivateIPAddress aws.StringValue                      `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
}

func (v *InstancePrivateIPAddress) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceState is undocumented.
type InstanceState struct {
	Code aws.IntegerValue `ec2:"Code" xml:"code"`
	Name aws.StringValue  `ec2:"Name" xml:"name"`
}

func (v *InstanceState) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	NameEnum := []string{
		InstanceStateNamePending,
		InstanceStateNameRunning,
		InstanceStateNameShuttingDown,
		InstanceStateNameStopped,
		InstanceStateNameStopping,
		InstanceStateNameTerminated,
	}
	if err := model.ValidateEnum(v, "Name", NameEnum); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceStateChange is undocumented.
type InstanceStateChange struct {
	CurrentState  *InstanceState  `ec2:"CurrentState" xml:"currentState"`
	InstanceID    aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	PreviousState *InstanceState  `ec2:"PreviousState" xml:"previousState"`
}

func (v *InstanceStateChange) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	InstanceStateNamePending      = "pending"
	InstanceStateNameRunning      = "running"
	InstanceStateNameShuttingDown = "shutting-down"
	InstanceStateNameStopped      = "stopped"
	InstanceStateNameStopping     = "stopping"
	InstanceStateNameTerminated   = "terminated"
)

// InstanceStatus is undocumented.
type InstanceStatus struct {
	AvailabilityZone aws.StringValue        `ec2:"AvailabilityZone" xml:"availabilityZone"`
	Events           []InstanceStatusEvent  `ec2:"Events" xml:"eventsSet>item"`
	InstanceID       aws.StringValue        `ec2:"InstanceId" xml:"instanceId"`
	InstanceState    *InstanceState         `ec2:"InstanceState" xml:"instanceState"`
	InstanceStatus   *InstanceStatusSummary `ec2:"InstanceStatus" xml:"instanceStatus"`
	SystemStatus     *InstanceStatusSummary `ec2:"SystemStatus" xml:"systemStatus"`
}

func (v *InstanceStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceStatusDetails is undocumented.
type InstanceStatusDetails struct {
	ImpairedSince time.Time       `ec2:"ImpairedSince" xml:"impairedSince"`
	Name          aws.StringValue `ec2:"Name" xml:"name"`
	Status        aws.StringValue `ec2:"Status" xml:"status"`
}

func (v *InstanceStatusDetails) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	NameEnum := []string{
		StatusNameReachability,
	}
	if err := model.ValidateEnum(v, "Name", NameEnum); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	StatusEnum := []string{
		StatusTypeFailed,
		StatusTypeInsufficientData,
		StatusTypePassed,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceStatusEvent is undocumented.
type InstanceStatusEvent struct {
	Code        aws.StringValue `ec2:"Code" xml:"code"`
	Description aws.StringValue `ec2:"Description" xml:"description"`
	NotAfter    time.Time       `ec2:"NotAfter" xml:"notAfter"`
	NotBefore   time.Time       `ec2:"NotBefore" xml:"notBefore"`
}

func (v *InstanceStatusEvent) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	CodeEnum := []string{
		EventCodeInstanceReboot,
		EventCodeInstanceRetirement,
		EventCodeInstanceStop,
		EventCodeSystemMaintenance,
		EventCodeSystemReboot,
	}
	if err := model.ValidateEnum(v, "Code", CodeEnum); err != nil {
		errors["Code"] = append(errors["Code"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceStatusSummary is undocumented.
type InstanceStatusSummary struct {
	Details []InstanceStatusDetails `ec2:"Details" xml:"details>item"`
	Status  aws.StringValue         `ec2:"Status" xml:"status"`
}

func (v *InstanceStatusSummary) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		SummaryStatusImpaired,
		SummaryStatusInsufficientData,
		SummaryStatusNotApplicable,
		SummaryStatusOK,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	InstanceTypeC1Medium   = "c1.medium"
	InstanceTypeC1Xlarge   = "c1.xlarge"
	InstanceTypeC32xlarge  = "c3.2xlarge"
	InstanceTypeC34xlarge  = "c3.4xlarge"
	InstanceTypeC38xlarge  = "c3.8xlarge"
	InstanceTypeC3Large    = "c3.large"
	InstanceTypeC3Xlarge   = "c3.xlarge"
	InstanceTypeCc14xlarge = "cc1.4xlarge"
	InstanceTypeCc28xlarge = "cc2.8xlarge"
	InstanceTypeCg14xlarge = "cg1.4xlarge"
	InstanceTypeCr18xlarge = "cr1.8xlarge"
	InstanceTypeG22xlarge  = "g2.2xlarge"
	InstanceTypeHi14xlarge = "hi1.4xlarge"
	InstanceTypeHs18xlarge = "hs1.8xlarge"
	InstanceTypeI22xlarge  = "i2.2xlarge"
	InstanceTypeI24xlarge  = "i2.4xlarge"
	InstanceTypeI28xlarge  = "i2.8xlarge"
	InstanceTypeI2Xlarge   = "i2.xlarge"
	InstanceTypeM1Large    = "m1.large"
	InstanceTypeM1Medium   = "m1.medium"
	InstanceTypeM1Small    = "m1.small"
	InstanceTypeM1Xlarge   = "m1.xlarge"
	InstanceTypeM22xlarge  = "m2.2xlarge"
	InstanceTypeM24xlarge  = "m2.4xlarge"
	InstanceTypeM2Xlarge   = "m2.xlarge"
	InstanceTypeM32xlarge  = "m3.2xlarge"
	InstanceTypeM3Large    = "m3.large"
	InstanceTypeM3Medium   = "m3.medium"
	InstanceTypeM3Xlarge   = "m3.xlarge"
	InstanceTypeR32xlarge  = "r3.2xlarge"
	InstanceTypeR34xlarge  = "r3.4xlarge"
	InstanceTypeR38xlarge  = "r3.8xlarge"
	InstanceTypeR3Large    = "r3.large"
	InstanceTypeR3Xlarge   = "r3.xlarge"
	InstanceTypeT1Micro    = "t1.micro"
	InstanceTypeT2Medium   = "t2.medium"
	InstanceTypeT2Micro    = "t2.micro"
	InstanceTypeT2Small    = "t2.small"
)

// InternetGateway is undocumented.
type InternetGateway struct {
	Attachments       []InternetGatewayAttachment `ec2:"Attachments" xml:"attachmentSet>item"`
	InternetGatewayID aws.StringValue             `ec2:"InternetGatewayId" xml:"internetGatewayId"`
	Tags              []Tag                       `ec2:"Tags" xml:"tagSet>item"`
}

func (v *InternetGateway) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InternetGatewayAttachment is undocumented.
type InternetGatewayAttachment struct {
	State aws.StringValue `ec2:"State" xml:"state"`
	VPCID aws.StringValue `ec2:"VpcId" xml:"vpcId"`
}

func (v *InternetGatewayAttachment) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		AttachmentStatusAttached,
		AttachmentStatusAttaching,
		AttachmentStatusDetached,
		AttachmentStatusDetaching,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IPPermission is undocumented.
type IPPermission struct {
	FromPort         aws.IntegerValue  `ec2:"FromPort" xml:"fromPort"`
	IPProtocol       aws.StringValue   `ec2:"IpProtocol" xml:"ipProtocol"`
	IPRanges         []IPRange         `ec2:"IpRanges" xml:"ipRanges>item"`
	ToPort           aws.IntegerValue  `ec2:"ToPort" xml:"toPort"`
	UserIDGroupPairs []UserIDGroupPair `ec2:"UserIdGroupPairs" xml:"groups>item"`
}

func (v *IPPermission) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IPRange is undocumented.
type IPRange struct {
	CIDRIP aws.StringValue `ec2:"CidrIp" xml:"cidrIp"`
}

func (v *IPRange) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// KeyPair is undocumented.
type KeyPair struct {
	KeyFingerprint aws.StringValue `ec2:"KeyFingerprint" xml:"keyFingerprint"`
	KeyMaterial    aws.StringValue `ec2:"KeyMaterial" xml:"keyMaterial"`
	KeyName        aws.StringValue `ec2:"KeyName" xml:"keyName"`
}

func (v *KeyPair) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// KeyPairInfo is undocumented.
type KeyPairInfo struct {
	KeyFingerprint aws.StringValue `ec2:"KeyFingerprint" xml:"keyFingerprint"`
	KeyName        aws.StringValue `ec2:"KeyName" xml:"keyName"`
}

func (v *KeyPairInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LaunchPermission is undocumented.
type LaunchPermission struct {
	Group  aws.StringValue `ec2:"Group" xml:"group"`
	UserID aws.StringValue `ec2:"UserId" xml:"userId"`
}

func (v *LaunchPermission) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	GroupEnum := []string{
		PermissionGroupAll,
	}
	if err := model.ValidateEnum(v, "Group", GroupEnum); err != nil {
		errors["Group"] = append(errors["Group"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LaunchPermissionModifications is undocumented.
type LaunchPermissionModifications struct {
	Add    []LaunchPermission `ec2:"Add" xml:"Add>item"`
	Remove []LaunchPermission `ec2:"Remove" xml:"Remove>item"`
}

func (v *LaunchPermissionModifications) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LaunchSpecification is undocumented.
type LaunchSpecification struct {
	AddressingType      aws.StringValue                         `ec2:"AddressingType" xml:"addressingType"`
	BlockDeviceMappings []BlockDeviceMapping                    `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	EBSOptimized        aws.BooleanValue                        `ec2:"EbsOptimized" xml:"ebsOptimized"`
	IAMInstanceProfile  *IAMInstanceProfileSpecification        `ec2:"IamInstanceProfile" xml:"iamInstanceProfile"`
	ImageID             aws.StringValue                         `ec2:"ImageId" xml:"imageId"`
	InstanceType        aws.StringValue                         `ec2:"InstanceType" xml:"instanceType"`
	KernelID            aws.StringValue                         `ec2:"KernelId" xml:"kernelId"`
	KeyName             aws.StringValue                         `ec2:"KeyName" xml:"keyName"`
	Monitoring          *RunInstancesMonitoringEnabled          `ec2:"Monitoring" xml:"monitoring"`
	NetworkInterfaces   []InstanceNetworkInterfaceSpecification `ec2:"NetworkInterfaces" xml:"networkInterfaceSet>item"`
	Placement           *SpotPlacement                          `ec2:"Placement" xml:"placement"`
	RAMDiskID           aws.StringValue                         `ec2:"RamdiskId" xml:"ramdiskId"`
	SecurityGroups      []GroupIdentifier                       `ec2:"SecurityGroups" xml:"groupSet>item"`
	SubnetID            aws.StringValue                         `ec2:"SubnetId" xml:"subnetId"`
	UserData            aws.StringValue                         `ec2:"UserData" xml:"userData"`
}

func (v *LaunchSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ListingStateAvailable = "available"
	ListingStateCancelled = "cancelled"
	ListingStatePending   = "pending"
	ListingStateSold      = "sold"
)

// Possible values for EC2.
const (
	ListingStatusActive    = "active"
	ListingStatusCancelled = "cancelled"
	ListingStatusClosed    = "closed"
	ListingStatusPending   = "pending"
)

// ModifyImageAttributeRequest is undocumented.
type ModifyImageAttributeRequest struct {
	Attribute        aws.StringValue                `ec2:"Attribute" xml:"Attribute"`
	Description      *AttributeValue                `ec2:"Description" xml:"Description"`
	DryRun           aws.BooleanValue               `ec2:"DryRun" xml:"dryRun"`
	ImageID          aws.StringValue                `ec2:"ImageId" xml:"ImageId"`
	LaunchPermission *LaunchPermissionModifications `ec2:"LaunchPermission" xml:"LaunchPermission"`
	OperationType    aws.StringValue                `ec2:"OperationType" xml:"OperationType"`
	ProductCodes     []string                       `ec2:"ProductCode" xml:"ProductCode>ProductCode"`
	UserGroups       []string                       `ec2:"UserGroup" xml:"UserGroup>UserGroup"`
	UserIDs          []string                       `ec2:"UserId" xml:"UserId>UserId"`
	Value            aws.StringValue                `ec2:"Value" xml:"Value"`
}

func (v *ModifyImageAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ImageID"); err != nil {
		errors["ImageID"] = append(errors["ImageID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyInstanceAttributeRequest is undocumented.
type ModifyInstanceAttributeRequest struct {
	Attribute                         aws.StringValue                           `ec2:"Attribute" xml:"attribute"`
	BlockDeviceMappings               []InstanceBlockDeviceMappingSpecification `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	DisableAPITermination             *AttributeBooleanValue                    `ec2:"DisableApiTermination" xml:"disableApiTermination"`
	DryRun                            aws.BooleanValue                          `ec2:"DryRun" xml:"dryRun"`
	EBSOptimized                      *AttributeBooleanValue                    `ec2:"EbsOptimized" xml:"ebsOptimized"`
	Groups                            []string                                  `ec2:"GroupId" xml:"GroupId>groupId"`
	InstanceID                        aws.StringValue                           `ec2:"InstanceId" xml:"instanceId"`
	InstanceInitiatedShutdownBehavior *AttributeValue                           `ec2:"InstanceInitiatedShutdownBehavior" xml:"instanceInitiatedShutdownBehavior"`
	InstanceType                      *AttributeValue                           `ec2:"InstanceType" xml:"instanceType"`
	Kernel                            *AttributeValue                           `ec2:"Kernel" xml:"kernel"`
	RAMDisk                           *AttributeValue                           `ec2:"Ramdisk" xml:"ramdisk"`
	SourceDestCheck                   *AttributeBooleanValue                    `ec2:"SourceDestCheck" xml:"SourceDestCheck"`
	SRIOVNetSupport                   *AttributeValue                           `ec2:"SriovNetSupport" xml:"sriovNetSupport"`
	UserData                          *BlobAttributeValue                       `ec2:"UserData" xml:"userData"`
	Value                             aws.StringValue                           `ec2:"Value" xml:"value"`
}

func (v *ModifyInstanceAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AttributeEnum := []string{
		InstanceAttributeNameBlockDeviceMapping,
		InstanceAttributeNameDisableAPITermination,
		InstanceAttributeNameEBSOptimized,
		InstanceAttributeNameGroupSet,
		InstanceAttributeNameInstanceInitiatedShutdownBehavior,
		InstanceAttributeNameInstanceType,
		InstanceAttributeNameKernel,
		InstanceAttributeNameProductCodes,
		InstanceAttributeNameRAMDisk,
		InstanceAttributeNameRootDeviceName,
		InstanceAttributeNameSRIOVNetSupport,
		InstanceAttributeNameSourceDestCheck,
		InstanceAttributeNameUserData,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyNetworkInterfaceAttributeRequest is undocumented.
type ModifyNetworkInterfaceAttributeRequest struct {
	Attachment         *NetworkInterfaceAttachmentChanges `ec2:"Attachment" xml:"attachment"`
	Description        *AttributeValue                    `ec2:"Description" xml:"description"`
	DryRun             aws.BooleanValue                   `ec2:"DryRun" xml:"dryRun"`
	Groups             []string                           `ec2:"SecurityGroupId" xml:"SecurityGroupId>SecurityGroupId"`
	NetworkInterfaceID aws.StringValue                    `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	SourceDestCheck    *AttributeBooleanValue             `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
}

func (v *ModifyNetworkInterfaceAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyReservedInstancesRequest is undocumented.
type ModifyReservedInstancesRequest struct {
	ClientToken          aws.StringValue                  `ec2:"ClientToken" xml:"clientToken"`
	ReservedInstancesIDs []string                         `ec2:"ReservedInstancesId" xml:"ReservedInstancesId>ReservedInstancesId"`
	TargetConfigurations []ReservedInstancesConfiguration `ec2:"ReservedInstancesConfigurationSetItemType" xml:"ReservedInstancesConfigurationSetItemType>item"`
}

func (v *ModifyReservedInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ReservedInstancesIDs"); err != nil {
		errors["ReservedInstancesIDs"] = append(errors["ReservedInstancesIDs"], err)
	}

	if err := model.ValidateRequired(v, "TargetConfigurations"); err != nil {
		errors["TargetConfigurations"] = append(errors["TargetConfigurations"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyReservedInstancesResult is undocumented.
type ModifyReservedInstancesResult struct {
	ReservedInstancesModificationID aws.StringValue `ec2:"ReservedInstancesModificationId" xml:"reservedInstancesModificationId"`
}

func (v *ModifyReservedInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifySnapshotAttributeRequest is undocumented.
type ModifySnapshotAttributeRequest struct {
	Attribute              aws.StringValue                      `ec2:"Attribute" xml:"Attribute"`
	CreateVolumePermission *CreateVolumePermissionModifications `ec2:"CreateVolumePermission" xml:"CreateVolumePermission"`
	DryRun                 aws.BooleanValue                     `ec2:"DryRun" xml:"dryRun"`
	GroupNames             []string                             `ec2:"UserGroup" xml:"UserGroup>GroupName"`
	OperationType          aws.StringValue                      `ec2:"OperationType" xml:"OperationType"`
	SnapshotID             aws.StringValue                      `ec2:"SnapshotId" xml:"SnapshotId"`
	UserIDs                []string                             `ec2:"UserId" xml:"UserId>UserId"`
}

func (v *ModifySnapshotAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AttributeEnum := []string{
		SnapshotAttributeNameCreateVolumePermission,
		SnapshotAttributeNameProductCodes,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotID"); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifySubnetAttributeRequest is undocumented.
type ModifySubnetAttributeRequest struct {
	MapPublicIPOnLaunch *AttributeBooleanValue `ec2:"MapPublicIpOnLaunch" xml:"MapPublicIpOnLaunch"`
	SubnetID            aws.StringValue        `ec2:"SubnetId" xml:"subnetId"`
}

func (v *ModifySubnetAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SubnetID"); err != nil {
		errors["SubnetID"] = append(errors["SubnetID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyVolumeAttributeRequest is undocumented.
type ModifyVolumeAttributeRequest struct {
	AutoEnableIO *AttributeBooleanValue `ec2:"AutoEnableIO" xml:"AutoEnableIO"`
	DryRun       aws.BooleanValue       `ec2:"DryRun" xml:"dryRun"`
	VolumeID     aws.StringValue        `ec2:"VolumeId" xml:"VolumeId"`
}

func (v *ModifyVolumeAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VolumeID"); err != nil {
		errors["VolumeID"] = append(errors["VolumeID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyVPCAttributeRequest is undocumented.
type ModifyVPCAttributeRequest struct {
	EnableDNSHostnames *AttributeBooleanValue `ec2:"EnableDnsHostnames" xml:"EnableDnsHostnames"`
	EnableDNSSupport   *AttributeBooleanValue `ec2:"EnableDnsSupport" xml:"EnableDnsSupport"`
	VPCID              aws.StringValue        `ec2:"VpcId" xml:"vpcId"`
}

func (v *ModifyVPCAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCID"); err != nil {
		errors["VPCID"] = append(errors["VPCID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// MonitorInstancesRequest is undocumented.
type MonitorInstancesRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceIDs []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
}

func (v *MonitorInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceIDs"); err != nil {
		errors["InstanceIDs"] = append(errors["InstanceIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// MonitorInstancesResult is undocumented.
type MonitorInstancesResult struct {
	InstanceMonitorings []InstanceMonitoring `ec2:"InstanceMonitorings" xml:"instancesSet>item"`
}

func (v *MonitorInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Monitoring is undocumented.
type Monitoring struct {
	State aws.StringValue `ec2:"State" xml:"state"`
}

func (v *Monitoring) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		MonitoringStateDisabled,
		MonitoringStateEnabled,
		MonitoringStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	MonitoringStateDisabled = "disabled"
	MonitoringStateEnabled  = "enabled"
	MonitoringStatePending  = "pending"
)

// NetworkACL is undocumented.
type NetworkACL struct {
	Associations []NetworkACLAssociation `ec2:"Associations" xml:"associationSet>item"`
	Entries      []NetworkACLEntry       `ec2:"Entries" xml:"entrySet>item"`
	IsDefault    aws.BooleanValue        `ec2:"IsDefault" xml:"default"`
	NetworkACLID aws.StringValue         `ec2:"NetworkAclId" xml:"networkAclId"`
	Tags         []Tag                   `ec2:"Tags" xml:"tagSet>item"`
	VPCID        aws.StringValue         `ec2:"VpcId" xml:"vpcId"`
}

func (v *NetworkACL) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkACLAssociation is undocumented.
type NetworkACLAssociation struct {
	NetworkACLAssociationID aws.StringValue `ec2:"NetworkAclAssociationId" xml:"networkAclAssociationId"`
	NetworkACLID            aws.StringValue `ec2:"NetworkAclId" xml:"networkAclId"`
	SubnetID                aws.StringValue `ec2:"SubnetId" xml:"subnetId"`
}

func (v *NetworkACLAssociation) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkACLEntry is undocumented.
type NetworkACLEntry struct {
	CIDRBlock    aws.StringValue  `ec2:"CidrBlock" xml:"cidrBlock"`
	Egress       aws.BooleanValue `ec2:"Egress" xml:"egress"`
	ICMPTypeCode *ICMPTypeCode    `ec2:"IcmpTypeCode" xml:"icmpTypeCode"`
	PortRange    *PortRange       `ec2:"PortRange" xml:"portRange"`
	Protocol     aws.StringValue  `ec2:"Protocol" xml:"protocol"`
	RuleAction   aws.StringValue  `ec2:"RuleAction" xml:"ruleAction"`
	RuleNumber   aws.IntegerValue `ec2:"RuleNumber" xml:"ruleNumber"`
}

func (v *NetworkACLEntry) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	RuleActionEnum := []string{
		RuleActionAllow,
		RuleActionDeny,
	}
	if err := model.ValidateEnum(v, "RuleAction", RuleActionEnum); err != nil {
		errors["RuleAction"] = append(errors["RuleAction"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkInterface is undocumented.
type NetworkInterface struct {
	Association        *NetworkInterfaceAssociation       `ec2:"Association" xml:"association"`
	Attachment         *NetworkInterfaceAttachment        `ec2:"Attachment" xml:"attachment"`
	AvailabilityZone   aws.StringValue                    `ec2:"AvailabilityZone" xml:"availabilityZone"`
	Description        aws.StringValue                    `ec2:"Description" xml:"description"`
	Groups             []GroupIdentifier                  `ec2:"Groups" xml:"groupSet>item"`
	MACAddress         aws.StringValue                    `ec2:"MacAddress" xml:"macAddress"`
	NetworkInterfaceID aws.StringValue                    `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	OwnerID            aws.StringValue                    `ec2:"OwnerId" xml:"ownerId"`
	PrivateDNSName     aws.StringValue                    `ec2:"PrivateDnsName" xml:"privateDnsName"`
	PrivateIPAddress   aws.StringValue                    `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	PrivateIPAddresses []NetworkInterfacePrivateIPAddress `ec2:"PrivateIpAddresses" xml:"privateIpAddressesSet>item"`
	RequesterID        aws.StringValue                    `ec2:"RequesterId" xml:"requesterId"`
	RequesterManaged   aws.BooleanValue                   `ec2:"RequesterManaged" xml:"requesterManaged"`
	SourceDestCheck    aws.BooleanValue                   `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
	Status             aws.StringValue                    `ec2:"Status" xml:"status"`
	SubnetID           aws.StringValue                    `ec2:"SubnetId" xml:"subnetId"`
	TagSet             []Tag                              `ec2:"TagSet" xml:"tagSet>item"`
	VPCID              aws.StringValue                    `ec2:"VpcId" xml:"vpcId"`
}

func (v *NetworkInterface) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		NetworkInterfaceStatusAttaching,
		NetworkInterfaceStatusAvailable,
		NetworkInterfaceStatusDetaching,
		NetworkInterfaceStatusInUse,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkInterfaceAssociation is undocumented.
type NetworkInterfaceAssociation struct {
	AllocationID  aws.StringValue `ec2:"AllocationId" xml:"allocationId"`
	AssociationID aws.StringValue `ec2:"AssociationId" xml:"associationId"`
	IPOwnerID     aws.StringValue `ec2:"IpOwnerId" xml:"ipOwnerId"`
	PublicDNSName aws.StringValue `ec2:"PublicDnsName" xml:"publicDnsName"`
	PublicIP      aws.StringValue `ec2:"PublicIp" xml:"publicIp"`
}

func (v *NetworkInterfaceAssociation) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkInterfaceAttachment is undocumented.
type NetworkInterfaceAttachment struct {
	AttachTime          time.Time        `ec2:"AttachTime" xml:"attachTime"`
	AttachmentID        aws.StringValue  `ec2:"AttachmentId" xml:"attachmentId"`
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	DeviceIndex         aws.IntegerValue `ec2:"DeviceIndex" xml:"deviceIndex"`
	InstanceID          aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
	InstanceOwnerID     aws.StringValue  `ec2:"InstanceOwnerId" xml:"instanceOwnerId"`
	Status              aws.StringValue  `ec2:"Status" xml:"status"`
}

func (v *NetworkInterfaceAttachment) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		AttachmentStatusAttached,
		AttachmentStatusAttaching,
		AttachmentStatusDetached,
		AttachmentStatusDetaching,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// NetworkInterfaceAttachmentChanges is undocumented.
type NetworkInterfaceAttachmentChanges struct {
	AttachmentID        aws.StringValue  `ec2:"AttachmentId" xml:"attachmentId"`
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
}

func (v *NetworkInterfaceAttachmentChanges) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	NetworkInterfaceAttributeAttachment      = "attachment"
	NetworkInterfaceAttributeDescription     = "description"
	NetworkInterfaceAttributeGroupSet        = "groupSet"
	NetworkInterfaceAttributeSourceDestCheck = "sourceDestCheck"
)

// NetworkInterfacePrivateIPAddress is undocumented.
type NetworkInterfacePrivateIPAddress struct {
	Association      *NetworkInterfaceAssociation `ec2:"Association" xml:"association"`
	Primary          aws.BooleanValue             `ec2:"Primary" xml:"primary"`
	PrivateDNSName   aws.StringValue              `ec2:"PrivateDnsName" xml:"privateDnsName"`
	PrivateIPAddress aws.StringValue              `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
}

func (v *NetworkInterfacePrivateIPAddress) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	NetworkInterfaceStatusAttaching = "attaching"
	NetworkInterfaceStatusAvailable = "available"
	NetworkInterfaceStatusDetaching = "detaching"
	NetworkInterfaceStatusInUse     = "in-use"
)

// NewDHCPConfiguration is undocumented.
type NewDHCPConfiguration struct {
	Key    aws.StringValue `ec2:"Key" xml:"key"`
	Values []string        `ec2:"Value" xml:"Value>item"`
}

func (v *NewDHCPConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	OfferingTypeValuesHeavyUtilization  = "Heavy Utilization"
	OfferingTypeValuesLightUtilization  = "Light Utilization"
	OfferingTypeValuesMediumUtilization = "Medium Utilization"
)

// Possible values for EC2.
const (
	PermissionGroupAll = "all"
)

// Placement is undocumented.
type Placement struct {
	AvailabilityZone aws.StringValue `ec2:"AvailabilityZone" xml:"availabilityZone"`
	GroupName        aws.StringValue `ec2:"GroupName" xml:"groupName"`
	Tenancy          aws.StringValue `ec2:"Tenancy" xml:"tenancy"`
}

func (v *Placement) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	TenancyEnum := []string{
		TenancyDedicated,
		TenancyDefault,
	}
	if err := model.ValidateEnum(v, "Tenancy", TenancyEnum); err != nil {
		errors["Tenancy"] = append(errors["Tenancy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PlacementGroup is undocumented.
type PlacementGroup struct {
	GroupName aws.StringValue `ec2:"GroupName" xml:"groupName"`
	State     aws.StringValue `ec2:"State" xml:"state"`
	Strategy  aws.StringValue `ec2:"Strategy" xml:"strategy"`
}

func (v *PlacementGroup) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		PlacementGroupStateAvailable,
		PlacementGroupStateDeleted,
		PlacementGroupStateDeleting,
		PlacementGroupStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	StrategyEnum := []string{
		PlacementStrategyCluster,
	}
	if err := model.ValidateEnum(v, "Strategy", StrategyEnum); err != nil {
		errors["Strategy"] = append(errors["Strategy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	PlacementGroupStateAvailable = "available"
	PlacementGroupStateDeleted   = "deleted"
	PlacementGroupStateDeleting  = "deleting"
	PlacementGroupStatePending   = "pending"
)

// Possible values for EC2.
const (
	PlacementStrategyCluster = "cluster"
)

// Possible values for EC2.
const (
	PlatformValuesWindows = "Windows"
)

// PortRange is undocumented.
type PortRange struct {
	From aws.IntegerValue `ec2:"From" xml:"from"`
	To   aws.IntegerValue `ec2:"To" xml:"to"`
}

func (v *PortRange) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PriceSchedule is undocumented.
type PriceSchedule struct {
	Active       aws.BooleanValue `ec2:"Active" xml:"active"`
	CurrencyCode aws.StringValue  `ec2:"CurrencyCode" xml:"currencyCode"`
	Price        aws.DoubleValue  `ec2:"Price" xml:"price"`
	Term         aws.LongValue    `ec2:"Term" xml:"term"`
}

func (v *PriceSchedule) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	CurrencyCodeEnum := []string{
		CurrencyCodeValuesUsd,
	}
	if err := model.ValidateEnum(v, "CurrencyCode", CurrencyCodeEnum); err != nil {
		errors["CurrencyCode"] = append(errors["CurrencyCode"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PriceScheduleSpecification is undocumented.
type PriceScheduleSpecification struct {
	CurrencyCode aws.StringValue `ec2:"CurrencyCode" xml:"currencyCode"`
	Price        aws.DoubleValue `ec2:"Price" xml:"price"`
	Term         aws.LongValue   `ec2:"Term" xml:"term"`
}

func (v *PriceScheduleSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	CurrencyCodeEnum := []string{
		CurrencyCodeValuesUsd,
	}
	if err := model.ValidateEnum(v, "CurrencyCode", CurrencyCodeEnum); err != nil {
		errors["CurrencyCode"] = append(errors["CurrencyCode"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PricingDetail is undocumented.
type PricingDetail struct {
	Count aws.IntegerValue `ec2:"Count" xml:"count"`
	Price aws.DoubleValue  `ec2:"Price" xml:"price"`
}

func (v *PricingDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PrivateIPAddressSpecification is undocumented.
type PrivateIPAddressSpecification struct {
	Primary          aws.BooleanValue `ec2:"Primary" xml:"primary"`
	PrivateIPAddress aws.StringValue  `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
}

func (v *PrivateIPAddressSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PrivateIPAddress"); err != nil {
		errors["PrivateIPAddress"] = append(errors["PrivateIPAddress"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ProductCode is undocumented.
type ProductCode struct {
	ProductCodeID   aws.StringValue `ec2:"ProductCodeId" xml:"productCode"`
	ProductCodeType aws.StringValue `ec2:"ProductCodeType" xml:"type"`
}

func (v *ProductCode) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ProductCodeTypeEnum := []string{
		ProductCodeValuesDevpay,
		ProductCodeValuesMarketplace,
	}
	if err := model.ValidateEnum(v, "ProductCodeType", ProductCodeTypeEnum); err != nil {
		errors["ProductCodeType"] = append(errors["ProductCodeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ProductCodeValuesDevpay      = "devpay"
	ProductCodeValuesMarketplace = "marketplace"
)

// PropagatingVGW is undocumented.
type PropagatingVGW struct {
	GatewayID aws.StringValue `ec2:"GatewayId" xml:"gatewayId"`
}

func (v *PropagatingVGW) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PurchaseReservedInstancesOfferingRequest is undocumented.
type PurchaseReservedInstancesOfferingRequest struct {
	DryRun                      aws.BooleanValue            `ec2:"DryRun" xml:"dryRun"`
	InstanceCount               aws.IntegerValue            `ec2:"InstanceCount" xml:"InstanceCount"`
	LimitPrice                  *ReservedInstanceLimitPrice `ec2:"LimitPrice" xml:"limitPrice"`
	ReservedInstancesOfferingID aws.StringValue             `ec2:"ReservedInstancesOfferingId" xml:"ReservedInstancesOfferingId"`
}

func (v *PurchaseReservedInstancesOfferingRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceCount"); err != nil {
		errors["InstanceCount"] = append(errors["InstanceCount"], err)
	}

	if err := model.ValidateRequired(v, "ReservedInstancesOfferingID"); err != nil {
		errors["ReservedInstancesOfferingID"] = append(errors["ReservedInstancesOfferingID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PurchaseReservedInstancesOfferingResult is undocumented.
type PurchaseReservedInstancesOfferingResult struct {
	ReservedInstancesID aws.StringValue `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
}

func (v *PurchaseReservedInstancesOfferingResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	RIProductDescriptionLinuxUnix          = "Linux/UNIX"
	RIProductDescriptionLinuxUnixamazonVPC = "Linux/UNIX (Amazon VPC)"
	RIProductDescriptionWindows            = "Windows"
	RIProductDescriptionWindowsAmazonVPC   = "Windows (Amazon VPC)"
)

// RebootInstancesRequest is undocumented.
type RebootInstancesRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceIDs []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
}

func (v *RebootInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceIDs"); err != nil {
		errors["InstanceIDs"] = append(errors["InstanceIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RecurringCharge is undocumented.
type RecurringCharge struct {
	Amount    aws.DoubleValue `ec2:"Amount" xml:"amount"`
	Frequency aws.StringValue `ec2:"Frequency" xml:"frequency"`
}

func (v *RecurringCharge) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	FrequencyEnum := []string{
		RecurringChargeFrequencyHourly,
	}
	if err := model.ValidateEnum(v, "Frequency", FrequencyEnum); err != nil {
		errors["Frequency"] = append(errors["Frequency"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	RecurringChargeFrequencyHourly = "Hourly"
)

// Region is undocumented.
type Region struct {
	Endpoint   aws.StringValue `ec2:"Endpoint" xml:"regionEndpoint"`
	RegionName aws.StringValue `ec2:"RegionName" xml:"regionName"`
}

func (v *Region) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RegisterImageRequest is undocumented.
type RegisterImageRequest struct {
	Architecture        aws.StringValue      `ec2:"Architecture" xml:"architecture"`
	BlockDeviceMappings []BlockDeviceMapping `ec2:"BlockDeviceMapping" xml:"BlockDeviceMapping>BlockDeviceMapping"`
	Description         aws.StringValue      `ec2:"Description" xml:"description"`
	DryRun              aws.BooleanValue     `ec2:"DryRun" xml:"dryRun"`
	ImageLocation       aws.StringValue      `ec2:"ImageLocation" xml:"ImageLocation"`
	KernelID            aws.StringValue      `ec2:"KernelId" xml:"kernelId"`
	Name                aws.StringValue      `ec2:"Name" xml:"name"`
	RAMDiskID           aws.StringValue      `ec2:"RamdiskId" xml:"ramdiskId"`
	RootDeviceName      aws.StringValue      `ec2:"RootDeviceName" xml:"rootDeviceName"`
	SRIOVNetSupport     aws.StringValue      `ec2:"SriovNetSupport" xml:"sriovNetSupport"`
	VirtualizationType  aws.StringValue      `ec2:"VirtualizationType" xml:"virtualizationType"`
}

func (v *RegisterImageRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ArchitectureEnum := []string{
		ArchitectureValuesI386,
		ArchitectureValuesX8664,
	}
	if err := model.ValidateEnum(v, "Architecture", ArchitectureEnum); err != nil {
		errors["Architecture"] = append(errors["Architecture"], err)
	}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RegisterImageResult is undocumented.
type RegisterImageResult struct {
	ImageID aws.StringValue `ec2:"ImageId" xml:"imageId"`
}

func (v *RegisterImageResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RejectVPCPeeringConnectionRequest is undocumented.
type RejectVPCPeeringConnectionRequest struct {
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	VPCPeeringConnectionID aws.StringValue  `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *RejectVPCPeeringConnectionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VPCPeeringConnectionID"); err != nil {
		errors["VPCPeeringConnectionID"] = append(errors["VPCPeeringConnectionID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RejectVPCPeeringConnectionResult is undocumented.
type RejectVPCPeeringConnectionResult struct {
	Return aws.BooleanValue `ec2:"Return" xml:"return"`
}

func (v *RejectVPCPeeringConnectionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReleaseAddressRequest is undocumented.
type ReleaseAddressRequest struct {
	AllocationID aws.StringValue  `ec2:"AllocationId" xml:"AllocationId"`
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	PublicIP     aws.StringValue  `ec2:"PublicIp" xml:"PublicIp"`
}

func (v *ReleaseAddressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReplaceNetworkACLAssociationRequest is undocumented.
type ReplaceNetworkACLAssociationRequest struct {
	AssociationID aws.StringValue  `ec2:"AssociationId" xml:"associationId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	NetworkACLID  aws.StringValue  `ec2:"NetworkAclId" xml:"networkAclId"`
}

func (v *ReplaceNetworkACLAssociationRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AssociationID"); err != nil {
		errors["AssociationID"] = append(errors["AssociationID"], err)
	}

	if err := model.ValidateRequired(v, "NetworkACLID"); err != nil {
		errors["NetworkACLID"] = append(errors["NetworkACLID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReplaceNetworkACLAssociationResult is undocumented.
type ReplaceNetworkACLAssociationResult struct {
	NewAssociationID aws.StringValue `ec2:"NewAssociationId" xml:"newAssociationId"`
}

func (v *ReplaceNetworkACLAssociationResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReplaceNetworkACLEntryRequest is undocumented.
type ReplaceNetworkACLEntryRequest struct {
	CIDRBlock    aws.StringValue  `ec2:"CidrBlock" xml:"cidrBlock"`
	DryRun       aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Egress       aws.BooleanValue `ec2:"Egress" xml:"egress"`
	ICMPTypeCode *ICMPTypeCode    `ec2:"Icmp" xml:"Icmp"`
	NetworkACLID aws.StringValue  `ec2:"NetworkAclId" xml:"networkAclId"`
	PortRange    *PortRange       `ec2:"PortRange" xml:"portRange"`
	Protocol     aws.StringValue  `ec2:"Protocol" xml:"protocol"`
	RuleAction   aws.StringValue  `ec2:"RuleAction" xml:"ruleAction"`
	RuleNumber   aws.IntegerValue `ec2:"RuleNumber" xml:"ruleNumber"`
}

func (v *ReplaceNetworkACLEntryRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CIDRBlock"); err != nil {
		errors["CIDRBlock"] = append(errors["CIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "Egress"); err != nil {
		errors["Egress"] = append(errors["Egress"], err)
	}

	if err := model.ValidateRequired(v, "NetworkACLID"); err != nil {
		errors["NetworkACLID"] = append(errors["NetworkACLID"], err)
	}

	if err := model.ValidateRequired(v, "Protocol"); err != nil {
		errors["Protocol"] = append(errors["Protocol"], err)
	}

	if err := model.ValidateRequired(v, "RuleAction"); err != nil {
		errors["RuleAction"] = append(errors["RuleAction"], err)
	}

	RuleActionEnum := []string{
		RuleActionAllow,
		RuleActionDeny,
	}
	if err := model.ValidateEnum(v, "RuleAction", RuleActionEnum); err != nil {
		errors["RuleAction"] = append(errors["RuleAction"], err)
	}

	if err := model.ValidateRequired(v, "RuleNumber"); err != nil {
		errors["RuleNumber"] = append(errors["RuleNumber"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReplaceRouteRequest is undocumented.
type ReplaceRouteRequest struct {
	DestinationCIDRBlock   aws.StringValue  `ec2:"DestinationCidrBlock" xml:"destinationCidrBlock"`
	DryRun                 aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	GatewayID              aws.StringValue  `ec2:"GatewayId" xml:"gatewayId"`
	InstanceID             aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
	NetworkInterfaceID     aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	RouteTableID           aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
	VPCPeeringConnectionID aws.StringValue  `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *ReplaceRouteRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DestinationCIDRBlock"); err != nil {
		errors["DestinationCIDRBlock"] = append(errors["DestinationCIDRBlock"], err)
	}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReplaceRouteTableAssociationRequest is undocumented.
type ReplaceRouteTableAssociationRequest struct {
	AssociationID aws.StringValue  `ec2:"AssociationId" xml:"associationId"`
	DryRun        aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	RouteTableID  aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
}

func (v *ReplaceRouteTableAssociationRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AssociationID"); err != nil {
		errors["AssociationID"] = append(errors["AssociationID"], err)
	}

	if err := model.ValidateRequired(v, "RouteTableID"); err != nil {
		errors["RouteTableID"] = append(errors["RouteTableID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReplaceRouteTableAssociationResult is undocumented.
type ReplaceRouteTableAssociationResult struct {
	NewAssociationID aws.StringValue `ec2:"NewAssociationId" xml:"newAssociationId"`
}

func (v *ReplaceRouteTableAssociationResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ReportInstanceReasonCodesInstanceStuckInState     = "instance-stuck-in-state"
	ReportInstanceReasonCodesNotAcceptingCredentials  = "not-accepting-credentials"
	ReportInstanceReasonCodesOther                    = "other"
	ReportInstanceReasonCodesPasswordNotAvailable     = "password-not-available"
	ReportInstanceReasonCodesPerformanceEBSVolume     = "performance-ebs-volume"
	ReportInstanceReasonCodesPerformanceInstanceStore = "performance-instance-store"
	ReportInstanceReasonCodesPerformanceNetwork       = "performance-network"
	ReportInstanceReasonCodesPerformanceOther         = "performance-other"
	ReportInstanceReasonCodesUnresponsive             = "unresponsive"
)

// ReportInstanceStatusRequest is undocumented.
type ReportInstanceStatusRequest struct {
	Description aws.StringValue  `ec2:"Description" xml:"description"`
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	EndTime     time.Time        `ec2:"EndTime" xml:"endTime"`
	Instances   []string         `ec2:"Instances" xml:"instanceId>InstanceId"`
	ReasonCodes []string         `ec2:"ReasonCodes" xml:"reasonCode>item"`
	StartTime   time.Time        `ec2:"StartTime" xml:"startTime"`
	Status      aws.StringValue  `ec2:"Status" xml:"status"`
}

func (v *ReportInstanceStatusRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Instances"); err != nil {
		errors["Instances"] = append(errors["Instances"], err)
	}

	if err := model.ValidateRequired(v, "ReasonCodes"); err != nil {
		errors["ReasonCodes"] = append(errors["ReasonCodes"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	StatusEnum := []string{
		ReportStatusTypeImpaired,
		ReportStatusTypeOK,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ReportStatusTypeImpaired = "impaired"
	ReportStatusTypeOK       = "ok"
)

// RequestSpotInstancesRequest is undocumented.
type RequestSpotInstancesRequest struct {
	AvailabilityZoneGroup aws.StringValue                 `ec2:"AvailabilityZoneGroup" xml:"availabilityZoneGroup"`
	DryRun                aws.BooleanValue                `ec2:"DryRun" xml:"dryRun"`
	InstanceCount         aws.IntegerValue                `ec2:"InstanceCount" xml:"instanceCount"`
	LaunchGroup           aws.StringValue                 `ec2:"LaunchGroup" xml:"launchGroup"`
	LaunchSpecification   *RequestSpotLaunchSpecification `ec2:"LaunchSpecification" xml:"LaunchSpecification"`
	SpotPrice             aws.StringValue                 `ec2:"SpotPrice" xml:"spotPrice"`
	Type                  aws.StringValue                 `ec2:"Type" xml:"type"`
	ValidFrom             time.Time                       `ec2:"ValidFrom" xml:"validFrom"`
	ValidUntil            time.Time                       `ec2:"ValidUntil" xml:"validUntil"`
}

func (v *RequestSpotInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SpotPrice"); err != nil {
		errors["SpotPrice"] = append(errors["SpotPrice"], err)
	}

	TypeEnum := []string{
		SpotInstanceTypeOneTime,
		SpotInstanceTypePersistent,
	}
	if err := model.ValidateEnum(v, "Type", TypeEnum); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RequestSpotInstancesResult is undocumented.
type RequestSpotInstancesResult struct {
	SpotInstanceRequests []SpotInstanceRequest `ec2:"SpotInstanceRequests" xml:"spotInstanceRequestSet>item"`
}

func (v *RequestSpotInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RequestSpotLaunchSpecification is undocumented.
type RequestSpotLaunchSpecification struct {
	AddressingType      aws.StringValue                         `ec2:"AddressingType" xml:"addressingType"`
	BlockDeviceMappings []BlockDeviceMapping                    `ec2:"BlockDeviceMappings" xml:"blockDeviceMapping>item"`
	EBSOptimized        aws.BooleanValue                        `ec2:"EbsOptimized" xml:"ebsOptimized"`
	IAMInstanceProfile  *IAMInstanceProfileSpecification        `ec2:"IamInstanceProfile" xml:"iamInstanceProfile"`
	ImageID             aws.StringValue                         `ec2:"ImageId" xml:"imageId"`
	InstanceType        aws.StringValue                         `ec2:"InstanceType" xml:"instanceType"`
	KernelID            aws.StringValue                         `ec2:"KernelId" xml:"kernelId"`
	KeyName             aws.StringValue                         `ec2:"KeyName" xml:"keyName"`
	Monitoring          *RunInstancesMonitoringEnabled          `ec2:"Monitoring" xml:"monitoring"`
	NetworkInterfaces   []InstanceNetworkInterfaceSpecification `ec2:"NetworkInterface" xml:"NetworkInterface>item"`
	Placement           *SpotPlacement                          `ec2:"Placement" xml:"placement"`
	RAMDiskID           aws.StringValue                         `ec2:"RamdiskId" xml:"ramdiskId"`
	SecurityGroupIDs    []string                                `ec2:"SecurityGroupId" xml:"SecurityGroupId>item"`
	SecurityGroups      []string                                `ec2:"SecurityGroup" xml:"SecurityGroup>item"`
	SubnetID            aws.StringValue                         `ec2:"SubnetId" xml:"subnetId"`
	UserData            aws.StringValue                         `ec2:"UserData" xml:"userData"`
}

func (v *RequestSpotLaunchSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Reservation is undocumented.
type Reservation struct {
	Groups        []GroupIdentifier `ec2:"Groups" xml:"groupSet>item"`
	Instances     []Instance        `ec2:"Instances" xml:"instancesSet>item"`
	OwnerID       aws.StringValue   `ec2:"OwnerId" xml:"ownerId"`
	RequesterID   aws.StringValue   `ec2:"RequesterId" xml:"requesterId"`
	ReservationID aws.StringValue   `ec2:"ReservationId" xml:"reservationId"`
}

func (v *Reservation) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstanceLimitPrice is undocumented.
type ReservedInstanceLimitPrice struct {
	Amount       aws.DoubleValue `ec2:"Amount" xml:"amount"`
	CurrencyCode aws.StringValue `ec2:"CurrencyCode" xml:"currencyCode"`
}

func (v *ReservedInstanceLimitPrice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	CurrencyCodeEnum := []string{
		CurrencyCodeValuesUsd,
	}
	if err := model.ValidateEnum(v, "CurrencyCode", CurrencyCodeEnum); err != nil {
		errors["CurrencyCode"] = append(errors["CurrencyCode"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ReservedInstanceStateActive         = "active"
	ReservedInstanceStatePaymentFailed  = "payment-failed"
	ReservedInstanceStatePaymentPending = "payment-pending"
	ReservedInstanceStateRetired        = "retired"
)

// ReservedInstances is undocumented.
type ReservedInstances struct {
	AvailabilityZone    aws.StringValue   `ec2:"AvailabilityZone" xml:"availabilityZone"`
	CurrencyCode        aws.StringValue   `ec2:"CurrencyCode" xml:"currencyCode"`
	Duration            aws.LongValue     `ec2:"Duration" xml:"duration"`
	End                 time.Time         `ec2:"End" xml:"end"`
	FixedPrice          aws.FloatValue    `ec2:"FixedPrice" xml:"fixedPrice"`
	InstanceCount       aws.IntegerValue  `ec2:"InstanceCount" xml:"instanceCount"`
	InstanceTenancy     aws.StringValue   `ec2:"InstanceTenancy" xml:"instanceTenancy"`
	InstanceType        aws.StringValue   `ec2:"InstanceType" xml:"instanceType"`
	OfferingType        aws.StringValue   `ec2:"OfferingType" xml:"offeringType"`
	ProductDescription  aws.StringValue   `ec2:"ProductDescription" xml:"productDescription"`
	RecurringCharges    []RecurringCharge `ec2:"RecurringCharges" xml:"recurringCharges>item"`
	ReservedInstancesID aws.StringValue   `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
	Start               time.Time         `ec2:"Start" xml:"start"`
	State               aws.StringValue   `ec2:"State" xml:"state"`
	Tags                []Tag             `ec2:"Tags" xml:"tagSet>item"`
	UsagePrice          aws.FloatValue    `ec2:"UsagePrice" xml:"usagePrice"`
}

func (v *ReservedInstances) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	CurrencyCodeEnum := []string{
		CurrencyCodeValuesUsd,
	}
	if err := model.ValidateEnum(v, "CurrencyCode", CurrencyCodeEnum); err != nil {
		errors["CurrencyCode"] = append(errors["CurrencyCode"], err)
	}

	InstanceTenancyEnum := []string{
		TenancyDedicated,
		TenancyDefault,
	}
	if err := model.ValidateEnum(v, "InstanceTenancy", InstanceTenancyEnum); err != nil {
		errors["InstanceTenancy"] = append(errors["InstanceTenancy"], err)
	}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	OfferingTypeEnum := []string{
		OfferingTypeValuesHeavyUtilization,
		OfferingTypeValuesLightUtilization,
		OfferingTypeValuesMediumUtilization,
	}
	if err := model.ValidateEnum(v, "OfferingType", OfferingTypeEnum); err != nil {
		errors["OfferingType"] = append(errors["OfferingType"], err)
	}

	ProductDescriptionEnum := []string{
		RIProductDescriptionLinuxUnix,
		RIProductDescriptionLinuxUnixamazonVPC,
		RIProductDescriptionWindows,
		RIProductDescriptionWindowsAmazonVPC,
	}
	if err := model.ValidateEnum(v, "ProductDescription", ProductDescriptionEnum); err != nil {
		errors["ProductDescription"] = append(errors["ProductDescription"], err)
	}

	StateEnum := []string{
		ReservedInstanceStateActive,
		ReservedInstanceStatePaymentFailed,
		ReservedInstanceStatePaymentPending,
		ReservedInstanceStateRetired,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstancesConfiguration is undocumented.
type ReservedInstancesConfiguration struct {
	AvailabilityZone aws.StringValue  `ec2:"AvailabilityZone" xml:"availabilityZone"`
	InstanceCount    aws.IntegerValue `ec2:"InstanceCount" xml:"instanceCount"`
	InstanceType     aws.StringValue  `ec2:"InstanceType" xml:"instanceType"`
	Platform         aws.StringValue  `ec2:"Platform" xml:"platform"`
}

func (v *ReservedInstancesConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstancesID is undocumented.
type ReservedInstancesID struct {
	ReservedInstancesID aws.StringValue `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
}

func (v *ReservedInstancesID) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstancesListing is undocumented.
type ReservedInstancesListing struct {
	ClientToken                aws.StringValue `ec2:"ClientToken" xml:"clientToken"`
	CreateDate                 time.Time       `ec2:"CreateDate" xml:"createDate"`
	InstanceCounts             []InstanceCount `ec2:"InstanceCounts" xml:"instanceCounts>item"`
	PriceSchedules             []PriceSchedule `ec2:"PriceSchedules" xml:"priceSchedules>item"`
	ReservedInstancesID        aws.StringValue `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
	ReservedInstancesListingID aws.StringValue `ec2:"ReservedInstancesListingId" xml:"reservedInstancesListingId"`
	Status                     aws.StringValue `ec2:"Status" xml:"status"`
	StatusMessage              aws.StringValue `ec2:"StatusMessage" xml:"statusMessage"`
	Tags                       []Tag           `ec2:"Tags" xml:"tagSet>item"`
	UpdateDate                 time.Time       `ec2:"UpdateDate" xml:"updateDate"`
}

func (v *ReservedInstancesListing) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		ListingStatusActive,
		ListingStatusCancelled,
		ListingStatusClosed,
		ListingStatusPending,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstancesModification is undocumented.
type ReservedInstancesModification struct {
	ClientToken                     aws.StringValue                       `ec2:"ClientToken" xml:"clientToken"`
	CreateDate                      time.Time                             `ec2:"CreateDate" xml:"createDate"`
	EffectiveDate                   time.Time                             `ec2:"EffectiveDate" xml:"effectiveDate"`
	ModificationResults             []ReservedInstancesModificationResult `ec2:"ModificationResults" xml:"modificationResultSet>item"`
	ReservedInstancesIDs            []ReservedInstancesID                 `ec2:"ReservedInstancesIds" xml:"reservedInstancesSet>item"`
	ReservedInstancesModificationID aws.StringValue                       `ec2:"ReservedInstancesModificationId" xml:"reservedInstancesModificationId"`
	Status                          aws.StringValue                       `ec2:"Status" xml:"status"`
	StatusMessage                   aws.StringValue                       `ec2:"StatusMessage" xml:"statusMessage"`
	UpdateDate                      time.Time                             `ec2:"UpdateDate" xml:"updateDate"`
}

func (v *ReservedInstancesModification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstancesModificationResult is undocumented.
type ReservedInstancesModificationResult struct {
	ReservedInstancesID aws.StringValue                 `ec2:"ReservedInstancesId" xml:"reservedInstancesId"`
	TargetConfiguration *ReservedInstancesConfiguration `ec2:"TargetConfiguration" xml:"targetConfiguration"`
}

func (v *ReservedInstancesModificationResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedInstancesOffering is undocumented.
type ReservedInstancesOffering struct {
	AvailabilityZone            aws.StringValue   `ec2:"AvailabilityZone" xml:"availabilityZone"`
	CurrencyCode                aws.StringValue   `ec2:"CurrencyCode" xml:"currencyCode"`
	Duration                    aws.LongValue     `ec2:"Duration" xml:"duration"`
	FixedPrice                  aws.FloatValue    `ec2:"FixedPrice" xml:"fixedPrice"`
	InstanceTenancy             aws.StringValue   `ec2:"InstanceTenancy" xml:"instanceTenancy"`
	InstanceType                aws.StringValue   `ec2:"InstanceType" xml:"instanceType"`
	Marketplace                 aws.BooleanValue  `ec2:"Marketplace" xml:"marketplace"`
	OfferingType                aws.StringValue   `ec2:"OfferingType" xml:"offeringType"`
	PricingDetails              []PricingDetail   `ec2:"PricingDetails" xml:"pricingDetailsSet>item"`
	ProductDescription          aws.StringValue   `ec2:"ProductDescription" xml:"productDescription"`
	RecurringCharges            []RecurringCharge `ec2:"RecurringCharges" xml:"recurringCharges>item"`
	ReservedInstancesOfferingID aws.StringValue   `ec2:"ReservedInstancesOfferingId" xml:"reservedInstancesOfferingId"`
	UsagePrice                  aws.FloatValue    `ec2:"UsagePrice" xml:"usagePrice"`
}

func (v *ReservedInstancesOffering) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	CurrencyCodeEnum := []string{
		CurrencyCodeValuesUsd,
	}
	if err := model.ValidateEnum(v, "CurrencyCode", CurrencyCodeEnum); err != nil {
		errors["CurrencyCode"] = append(errors["CurrencyCode"], err)
	}

	InstanceTenancyEnum := []string{
		TenancyDedicated,
		TenancyDefault,
	}
	if err := model.ValidateEnum(v, "InstanceTenancy", InstanceTenancyEnum); err != nil {
		errors["InstanceTenancy"] = append(errors["InstanceTenancy"], err)
	}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	OfferingTypeEnum := []string{
		OfferingTypeValuesHeavyUtilization,
		OfferingTypeValuesLightUtilization,
		OfferingTypeValuesMediumUtilization,
	}
	if err := model.ValidateEnum(v, "OfferingType", OfferingTypeEnum); err != nil {
		errors["OfferingType"] = append(errors["OfferingType"], err)
	}

	ProductDescriptionEnum := []string{
		RIProductDescriptionLinuxUnix,
		RIProductDescriptionLinuxUnixamazonVPC,
		RIProductDescriptionWindows,
		RIProductDescriptionWindowsAmazonVPC,
	}
	if err := model.ValidateEnum(v, "ProductDescription", ProductDescriptionEnum); err != nil {
		errors["ProductDescription"] = append(errors["ProductDescription"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ResetImageAttributeNameLaunchPermission = "launchPermission"
)

// ResetImageAttributeRequest is undocumented.
type ResetImageAttributeRequest struct {
	Attribute aws.StringValue  `ec2:"Attribute" xml:"Attribute"`
	DryRun    aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	ImageID   aws.StringValue  `ec2:"ImageId" xml:"ImageId"`
}

func (v *ResetImageAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Attribute"); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	AttributeEnum := []string{
		ResetImageAttributeNameLaunchPermission,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "ImageID"); err != nil {
		errors["ImageID"] = append(errors["ImageID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ResetInstanceAttributeRequest is undocumented.
type ResetInstanceAttributeRequest struct {
	Attribute  aws.StringValue  `ec2:"Attribute" xml:"attribute"`
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceID aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
}

func (v *ResetInstanceAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Attribute"); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	AttributeEnum := []string{
		InstanceAttributeNameBlockDeviceMapping,
		InstanceAttributeNameDisableAPITermination,
		InstanceAttributeNameEBSOptimized,
		InstanceAttributeNameGroupSet,
		InstanceAttributeNameInstanceInitiatedShutdownBehavior,
		InstanceAttributeNameInstanceType,
		InstanceAttributeNameKernel,
		InstanceAttributeNameProductCodes,
		InstanceAttributeNameRAMDisk,
		InstanceAttributeNameRootDeviceName,
		InstanceAttributeNameSRIOVNetSupport,
		InstanceAttributeNameSourceDestCheck,
		InstanceAttributeNameUserData,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "InstanceID"); err != nil {
		errors["InstanceID"] = append(errors["InstanceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ResetNetworkInterfaceAttributeRequest is undocumented.
type ResetNetworkInterfaceAttributeRequest struct {
	DryRun             aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	NetworkInterfaceID aws.StringValue  `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	SourceDestCheck    aws.StringValue  `ec2:"SourceDestCheck" xml:"sourceDestCheck"`
}

func (v *ResetNetworkInterfaceAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ResetSnapshotAttributeRequest is undocumented.
type ResetSnapshotAttributeRequest struct {
	Attribute  aws.StringValue  `ec2:"Attribute" xml:"Attribute"`
	DryRun     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	SnapshotID aws.StringValue  `ec2:"SnapshotId" xml:"SnapshotId"`
}

func (v *ResetSnapshotAttributeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Attribute"); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	AttributeEnum := []string{
		SnapshotAttributeNameCreateVolumePermission,
		SnapshotAttributeNameProductCodes,
	}
	if err := model.ValidateEnum(v, "Attribute", AttributeEnum); err != nil {
		errors["Attribute"] = append(errors["Attribute"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotID"); err != nil {
		errors["SnapshotID"] = append(errors["SnapshotID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ResourceTypeCustomerGateway      = "customer-gateway"
	ResourceTypeDHCPOptions          = "dhcp-options"
	ResourceTypeImage                = "image"
	ResourceTypeInstance             = "instance"
	ResourceTypeInternetGateway      = "internet-gateway"
	ResourceTypeNetworkACL           = "network-acl"
	ResourceTypeNetworkInterface     = "network-interface"
	ResourceTypeReservedInstances    = "reserved-instances"
	ResourceTypeRouteTable           = "route-table"
	ResourceTypeSecurityGroup        = "security-group"
	ResourceTypeSnapshot             = "snapshot"
	ResourceTypeSpotInstancesRequest = "spot-instances-request"
	ResourceTypeSubnet               = "subnet"
	ResourceTypeVPC                  = "vpc"
	ResourceTypeVPNConnection        = "vpn-connection"
	ResourceTypeVPNGateway           = "vpn-gateway"
	ResourceTypeVolume               = "volume"
)

// RevokeSecurityGroupEgressRequest is undocumented.
type RevokeSecurityGroupEgressRequest struct {
	CIDRIP                     aws.StringValue  `ec2:"CidrIp" xml:"cidrIp"`
	DryRun                     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	FromPort                   aws.IntegerValue `ec2:"FromPort" xml:"fromPort"`
	GroupID                    aws.StringValue  `ec2:"GroupId" xml:"groupId"`
	IPPermissions              []IPPermission   `ec2:"IpPermissions" xml:"ipPermissions>item"`
	IPProtocol                 aws.StringValue  `ec2:"IpProtocol" xml:"ipProtocol"`
	SourceSecurityGroupName    aws.StringValue  `ec2:"SourceSecurityGroupName" xml:"sourceSecurityGroupName"`
	SourceSecurityGroupOwnerID aws.StringValue  `ec2:"SourceSecurityGroupOwnerId" xml:"sourceSecurityGroupOwnerId"`
	ToPort                     aws.IntegerValue `ec2:"ToPort" xml:"toPort"`
}

func (v *RevokeSecurityGroupEgressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupID"); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RevokeSecurityGroupIngressRequest is undocumented.
type RevokeSecurityGroupIngressRequest struct {
	CIDRIP                     aws.StringValue  `ec2:"CidrIp" xml:"CidrIp"`
	DryRun                     aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	FromPort                   aws.IntegerValue `ec2:"FromPort" xml:"FromPort"`
	GroupID                    aws.StringValue  `ec2:"GroupId" xml:"GroupId"`
	GroupName                  aws.StringValue  `ec2:"GroupName" xml:"GroupName"`
	IPPermissions              []IPPermission   `ec2:"IpPermissions" xml:"IpPermissions>item"`
	IPProtocol                 aws.StringValue  `ec2:"IpProtocol" xml:"IpProtocol"`
	SourceSecurityGroupName    aws.StringValue  `ec2:"SourceSecurityGroupName" xml:"SourceSecurityGroupName"`
	SourceSecurityGroupOwnerID aws.StringValue  `ec2:"SourceSecurityGroupOwnerId" xml:"SourceSecurityGroupOwnerId"`
	ToPort                     aws.IntegerValue `ec2:"ToPort" xml:"ToPort"`
}

func (v *RevokeSecurityGroupIngressRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Route is undocumented.
type Route struct {
	DestinationCIDRBlock   aws.StringValue `ec2:"DestinationCidrBlock" xml:"destinationCidrBlock"`
	GatewayID              aws.StringValue `ec2:"GatewayId" xml:"gatewayId"`
	InstanceID             aws.StringValue `ec2:"InstanceId" xml:"instanceId"`
	InstanceOwnerID        aws.StringValue `ec2:"InstanceOwnerId" xml:"instanceOwnerId"`
	NetworkInterfaceID     aws.StringValue `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	Origin                 aws.StringValue `ec2:"Origin" xml:"origin"`
	State                  aws.StringValue `ec2:"State" xml:"state"`
	VPCPeeringConnectionID aws.StringValue `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *Route) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	OriginEnum := []string{
		RouteOriginCreateRoute,
		RouteOriginCreateRouteTable,
		RouteOriginEnableVGWRoutePropagation,
	}
	if err := model.ValidateEnum(v, "Origin", OriginEnum); err != nil {
		errors["Origin"] = append(errors["Origin"], err)
	}

	StateEnum := []string{
		RouteStateActive,
		RouteStateBlackhole,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	RouteOriginCreateRoute               = "CreateRoute"
	RouteOriginCreateRouteTable          = "CreateRouteTable"
	RouteOriginEnableVGWRoutePropagation = "EnableVgwRoutePropagation"
)

// Possible values for EC2.
const (
	RouteStateActive    = "active"
	RouteStateBlackhole = "blackhole"
)

// RouteTable is undocumented.
type RouteTable struct {
	Associations    []RouteTableAssociation `ec2:"Associations" xml:"associationSet>item"`
	PropagatingVGWs []PropagatingVGW        `ec2:"PropagatingVgws" xml:"propagatingVgwSet>item"`
	RouteTableID    aws.StringValue         `ec2:"RouteTableId" xml:"routeTableId"`
	Routes          []Route                 `ec2:"Routes" xml:"routeSet>item"`
	Tags            []Tag                   `ec2:"Tags" xml:"tagSet>item"`
	VPCID           aws.StringValue         `ec2:"VpcId" xml:"vpcId"`
}

func (v *RouteTable) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RouteTableAssociation is undocumented.
type RouteTableAssociation struct {
	Main                    aws.BooleanValue `ec2:"Main" xml:"main"`
	RouteTableAssociationID aws.StringValue  `ec2:"RouteTableAssociationId" xml:"routeTableAssociationId"`
	RouteTableID            aws.StringValue  `ec2:"RouteTableId" xml:"routeTableId"`
	SubnetID                aws.StringValue  `ec2:"SubnetId" xml:"subnetId"`
}

func (v *RouteTableAssociation) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	RuleActionAllow = "allow"
	RuleActionDeny  = "deny"
)

// RunInstancesMonitoringEnabled is undocumented.
type RunInstancesMonitoringEnabled struct {
	Enabled aws.BooleanValue `ec2:"Enabled" xml:"enabled"`
}

func (v *RunInstancesMonitoringEnabled) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Enabled"); err != nil {
		errors["Enabled"] = append(errors["Enabled"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RunInstancesRequest is undocumented.
type RunInstancesRequest struct {
	AdditionalInfo                    aws.StringValue                         `ec2:"AdditionalInfo" xml:"additionalInfo"`
	BlockDeviceMappings               []BlockDeviceMapping                    `ec2:"BlockDeviceMapping" xml:"BlockDeviceMapping>BlockDeviceMapping"`
	ClientToken                       aws.StringValue                         `ec2:"ClientToken" xml:"clientToken"`
	DisableAPITermination             aws.BooleanValue                        `ec2:"DisableApiTermination" xml:"disableApiTermination"`
	DryRun                            aws.BooleanValue                        `ec2:"DryRun" xml:"dryRun"`
	EBSOptimized                      aws.BooleanValue                        `ec2:"EbsOptimized" xml:"ebsOptimized"`
	IAMInstanceProfile                *IAMInstanceProfileSpecification        `ec2:"IamInstanceProfile" xml:"iamInstanceProfile"`
	ImageID                           aws.StringValue                         `ec2:"ImageId" xml:"ImageId"`
	InstanceInitiatedShutdownBehavior aws.StringValue                         `ec2:"InstanceInitiatedShutdownBehavior" xml:"instanceInitiatedShutdownBehavior"`
	InstanceType                      aws.StringValue                         `ec2:"InstanceType" xml:"InstanceType"`
	KernelID                          aws.StringValue                         `ec2:"KernelId" xml:"KernelId"`
	KeyName                           aws.StringValue                         `ec2:"KeyName" xml:"KeyName"`
	MaxCount                          aws.IntegerValue                        `ec2:"MaxCount" xml:"MaxCount"`
	MinCount                          aws.IntegerValue                        `ec2:"MinCount" xml:"MinCount"`
	Monitoring                        *RunInstancesMonitoringEnabled          `ec2:"Monitoring" xml:"Monitoring"`
	NetworkInterfaces                 []InstanceNetworkInterfaceSpecification `ec2:"NetworkInterfaces" xml:"networkInterface>item"`
	Placement                         *Placement                              `ec2:"Placement" xml:"Placement"`
	PrivateIPAddress                  aws.StringValue                         `ec2:"PrivateIpAddress" xml:"privateIpAddress"`
	RAMDiskID                         aws.StringValue                         `ec2:"RamdiskId" xml:"RamdiskId"`
	SecurityGroupIDs                  []string                                `ec2:"SecurityGroupId" xml:"SecurityGroupId>SecurityGroupId"`
	SecurityGroups                    []string                                `ec2:"SecurityGroup" xml:"SecurityGroup>SecurityGroup"`
	SubnetID                          aws.StringValue                         `ec2:"SubnetId" xml:"SubnetId"`
	UserData                          aws.StringValue                         `ec2:"UserData" xml:"UserData"`
}

func (v *RunInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ImageID"); err != nil {
		errors["ImageID"] = append(errors["ImageID"], err)
	}

	InstanceInitiatedShutdownBehaviorEnum := []string{
		ShutdownBehaviorStop,
		ShutdownBehaviorTerminate,
	}
	if err := model.ValidateEnum(v, "InstanceInitiatedShutdownBehavior", InstanceInitiatedShutdownBehaviorEnum); err != nil {
		errors["InstanceInitiatedShutdownBehavior"] = append(errors["InstanceInitiatedShutdownBehavior"], err)
	}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	if err := model.ValidateRequired(v, "MaxCount"); err != nil {
		errors["MaxCount"] = append(errors["MaxCount"], err)
	}

	if err := model.ValidateRequired(v, "MinCount"); err != nil {
		errors["MinCount"] = append(errors["MinCount"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// S3Storage is undocumented.
type S3Storage struct {
	AWSAccessKeyID        aws.StringValue `ec2:"AWSAccessKeyId" xml:"AWSAccessKeyId"`
	Bucket                aws.StringValue `ec2:"Bucket" xml:"bucket"`
	Prefix                aws.StringValue `ec2:"Prefix" xml:"prefix"`
	UploadPolicy          []byte          `ec2:"UploadPolicy" xml:"uploadPolicy"`
	UploadPolicySignature aws.StringValue `ec2:"UploadPolicySignature" xml:"uploadPolicySignature"`
}

func (v *S3Storage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SecurityGroup is undocumented.
type SecurityGroup struct {
	Description         aws.StringValue `ec2:"Description" xml:"groupDescription"`
	GroupID             aws.StringValue `ec2:"GroupId" xml:"groupId"`
	GroupName           aws.StringValue `ec2:"GroupName" xml:"groupName"`
	IPPermissions       []IPPermission  `ec2:"IpPermissions" xml:"ipPermissions>item"`
	IPPermissionsEgress []IPPermission  `ec2:"IpPermissionsEgress" xml:"ipPermissionsEgress>item"`
	OwnerID             aws.StringValue `ec2:"OwnerId" xml:"ownerId"`
	Tags                []Tag           `ec2:"Tags" xml:"tagSet>item"`
	VPCID               aws.StringValue `ec2:"VpcId" xml:"vpcId"`
}

func (v *SecurityGroup) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	ShutdownBehaviorStop      = "stop"
	ShutdownBehaviorTerminate = "terminate"
)

// Snapshot is undocumented.
type Snapshot struct {
	Description aws.StringValue  `ec2:"Description" xml:"description"`
	Encrypted   aws.BooleanValue `ec2:"Encrypted" xml:"encrypted"`
	KMSKeyID    aws.StringValue  `ec2:"KmsKeyId" xml:"kmsKeyId"`
	OwnerAlias  aws.StringValue  `ec2:"OwnerAlias" xml:"ownerAlias"`
	OwnerID     aws.StringValue  `ec2:"OwnerId" xml:"ownerId"`
	Progress    aws.StringValue  `ec2:"Progress" xml:"progress"`
	SnapshotID  aws.StringValue  `ec2:"SnapshotId" xml:"snapshotId"`
	StartTime   time.Time        `ec2:"StartTime" xml:"startTime"`
	State       aws.StringValue  `ec2:"State" xml:"status"`
	Tags        []Tag            `ec2:"Tags" xml:"tagSet>item"`
	VolumeID    aws.StringValue  `ec2:"VolumeId" xml:"volumeId"`
	VolumeSize  aws.IntegerValue `ec2:"VolumeSize" xml:"volumeSize"`
}

func (v *Snapshot) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		SnapshotStateCompleted,
		SnapshotStateError,
		SnapshotStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	SnapshotAttributeNameCreateVolumePermission = "createVolumePermission"
	SnapshotAttributeNameProductCodes           = "productCodes"
)

// Possible values for EC2.
const (
	SnapshotStateCompleted = "completed"
	SnapshotStateError     = "error"
	SnapshotStatePending   = "pending"
)

// SpotDatafeedSubscription is undocumented.
type SpotDatafeedSubscription struct {
	Bucket  aws.StringValue         `ec2:"Bucket" xml:"bucket"`
	Fault   *SpotInstanceStateFault `ec2:"Fault" xml:"fault"`
	OwnerID aws.StringValue         `ec2:"OwnerId" xml:"ownerId"`
	Prefix  aws.StringValue         `ec2:"Prefix" xml:"prefix"`
	State   aws.StringValue         `ec2:"State" xml:"state"`
}

func (v *SpotDatafeedSubscription) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		DatafeedSubscriptionStateActive,
		DatafeedSubscriptionStateInactive,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SpotInstanceRequest is undocumented.
type SpotInstanceRequest struct {
	AvailabilityZoneGroup    aws.StringValue         `ec2:"AvailabilityZoneGroup" xml:"availabilityZoneGroup"`
	CreateTime               time.Time               `ec2:"CreateTime" xml:"createTime"`
	Fault                    *SpotInstanceStateFault `ec2:"Fault" xml:"fault"`
	InstanceID               aws.StringValue         `ec2:"InstanceId" xml:"instanceId"`
	LaunchGroup              aws.StringValue         `ec2:"LaunchGroup" xml:"launchGroup"`
	LaunchSpecification      *LaunchSpecification    `ec2:"LaunchSpecification" xml:"launchSpecification"`
	LaunchedAvailabilityZone aws.StringValue         `ec2:"LaunchedAvailabilityZone" xml:"launchedAvailabilityZone"`
	ProductDescription       aws.StringValue         `ec2:"ProductDescription" xml:"productDescription"`
	SpotInstanceRequestID    aws.StringValue         `ec2:"SpotInstanceRequestId" xml:"spotInstanceRequestId"`
	SpotPrice                aws.StringValue         `ec2:"SpotPrice" xml:"spotPrice"`
	State                    aws.StringValue         `ec2:"State" xml:"state"`
	Status                   *SpotInstanceStatus     `ec2:"Status" xml:"status"`
	Tags                     []Tag                   `ec2:"Tags" xml:"tagSet>item"`
	Type                     aws.StringValue         `ec2:"Type" xml:"type"`
	ValidFrom                time.Time               `ec2:"ValidFrom" xml:"validFrom"`
	ValidUntil               time.Time               `ec2:"ValidUntil" xml:"validUntil"`
}

func (v *SpotInstanceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ProductDescriptionEnum := []string{
		RIProductDescriptionLinuxUnix,
		RIProductDescriptionLinuxUnixamazonVPC,
		RIProductDescriptionWindows,
		RIProductDescriptionWindowsAmazonVPC,
	}
	if err := model.ValidateEnum(v, "ProductDescription", ProductDescriptionEnum); err != nil {
		errors["ProductDescription"] = append(errors["ProductDescription"], err)
	}

	StateEnum := []string{
		SpotInstanceStateActive,
		SpotInstanceStateCancelled,
		SpotInstanceStateClosed,
		SpotInstanceStateFailed,
		SpotInstanceStateOpen,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	TypeEnum := []string{
		SpotInstanceTypeOneTime,
		SpotInstanceTypePersistent,
	}
	if err := model.ValidateEnum(v, "Type", TypeEnum); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	SpotInstanceStateActive    = "active"
	SpotInstanceStateCancelled = "cancelled"
	SpotInstanceStateClosed    = "closed"
	SpotInstanceStateFailed    = "failed"
	SpotInstanceStateOpen      = "open"
)

// SpotInstanceStateFault is undocumented.
type SpotInstanceStateFault struct {
	Code    aws.StringValue `ec2:"Code" xml:"code"`
	Message aws.StringValue `ec2:"Message" xml:"message"`
}

func (v *SpotInstanceStateFault) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SpotInstanceStatus is undocumented.
type SpotInstanceStatus struct {
	Code       aws.StringValue `ec2:"Code" xml:"code"`
	Message    aws.StringValue `ec2:"Message" xml:"message"`
	UpdateTime time.Time       `ec2:"UpdateTime" xml:"updateTime"`
}

func (v *SpotInstanceStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	SpotInstanceTypeOneTime    = "one-time"
	SpotInstanceTypePersistent = "persistent"
)

// SpotPlacement is undocumented.
type SpotPlacement struct {
	AvailabilityZone aws.StringValue `ec2:"AvailabilityZone" xml:"availabilityZone"`
	GroupName        aws.StringValue `ec2:"GroupName" xml:"groupName"`
}

func (v *SpotPlacement) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SpotPrice is undocumented.
type SpotPrice struct {
	AvailabilityZone   aws.StringValue `ec2:"AvailabilityZone" xml:"availabilityZone"`
	InstanceType       aws.StringValue `ec2:"InstanceType" xml:"instanceType"`
	ProductDescription aws.StringValue `ec2:"ProductDescription" xml:"productDescription"`
	SpotPrice          aws.StringValue `ec2:"SpotPrice" xml:"spotPrice"`
	Timestamp          time.Time       `ec2:"Timestamp" xml:"timestamp"`
}

func (v *SpotPrice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	InstanceTypeEnum := []string{
		InstanceTypeC1Medium,
		InstanceTypeC1Xlarge,
		InstanceTypeC32xlarge,
		InstanceTypeC34xlarge,
		InstanceTypeC38xlarge,
		InstanceTypeC3Large,
		InstanceTypeC3Xlarge,
		InstanceTypeCc14xlarge,
		InstanceTypeCc28xlarge,
		InstanceTypeCg14xlarge,
		InstanceTypeCr18xlarge,
		InstanceTypeG22xlarge,
		InstanceTypeHi14xlarge,
		InstanceTypeHs18xlarge,
		InstanceTypeI22xlarge,
		InstanceTypeI24xlarge,
		InstanceTypeI28xlarge,
		InstanceTypeI2Xlarge,
		InstanceTypeM1Large,
		InstanceTypeM1Medium,
		InstanceTypeM1Small,
		InstanceTypeM1Xlarge,
		InstanceTypeM22xlarge,
		InstanceTypeM24xlarge,
		InstanceTypeM2Xlarge,
		InstanceTypeM32xlarge,
		InstanceTypeM3Large,
		InstanceTypeM3Medium,
		InstanceTypeM3Xlarge,
		InstanceTypeR32xlarge,
		InstanceTypeR34xlarge,
		InstanceTypeR38xlarge,
		InstanceTypeR3Large,
		InstanceTypeR3Xlarge,
		InstanceTypeT1Micro,
		InstanceTypeT2Medium,
		InstanceTypeT2Micro,
		InstanceTypeT2Small,
	}
	if err := model.ValidateEnum(v, "InstanceType", InstanceTypeEnum); err != nil {
		errors["InstanceType"] = append(errors["InstanceType"], err)
	}

	ProductDescriptionEnum := []string{
		RIProductDescriptionLinuxUnix,
		RIProductDescriptionLinuxUnixamazonVPC,
		RIProductDescriptionWindows,
		RIProductDescriptionWindowsAmazonVPC,
	}
	if err := model.ValidateEnum(v, "ProductDescription", ProductDescriptionEnum); err != nil {
		errors["ProductDescription"] = append(errors["ProductDescription"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartInstancesRequest is undocumented.
type StartInstancesRequest struct {
	AdditionalInfo aws.StringValue  `ec2:"AdditionalInfo" xml:"additionalInfo"`
	DryRun         aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceIDs    []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
}

func (v *StartInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceIDs"); err != nil {
		errors["InstanceIDs"] = append(errors["InstanceIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartInstancesResult is undocumented.
type StartInstancesResult struct {
	StartingInstances []InstanceStateChange `ec2:"StartingInstances" xml:"instancesSet>item"`
}

func (v *StartInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StateReason is undocumented.
type StateReason struct {
	Code    aws.StringValue `ec2:"Code" xml:"code"`
	Message aws.StringValue `ec2:"Message" xml:"message"`
}

func (v *StateReason) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	StatusNameReachability = "reachability"
)

// Possible values for EC2.
const (
	StatusTypeFailed           = "failed"
	StatusTypeInsufficientData = "insufficient-data"
	StatusTypePassed           = "passed"
)

// StopInstancesRequest is undocumented.
type StopInstancesRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	Force       aws.BooleanValue `ec2:"Force" xml:"force"`
	InstanceIDs []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
}

func (v *StopInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceIDs"); err != nil {
		errors["InstanceIDs"] = append(errors["InstanceIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StopInstancesResult is undocumented.
type StopInstancesResult struct {
	StoppingInstances []InstanceStateChange `ec2:"StoppingInstances" xml:"instancesSet>item"`
}

func (v *StopInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Storage is undocumented.
type Storage struct {
	S3 *S3Storage `ec2:"S3" xml:"S3"`
}

func (v *Storage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Subnet is undocumented.
type Subnet struct {
	AvailabilityZone        aws.StringValue  `ec2:"AvailabilityZone" xml:"availabilityZone"`
	AvailableIPAddressCount aws.IntegerValue `ec2:"AvailableIpAddressCount" xml:"availableIpAddressCount"`
	CIDRBlock               aws.StringValue  `ec2:"CidrBlock" xml:"cidrBlock"`
	DefaultForAz            aws.BooleanValue `ec2:"DefaultForAz" xml:"defaultForAz"`
	MapPublicIPOnLaunch     aws.BooleanValue `ec2:"MapPublicIpOnLaunch" xml:"mapPublicIpOnLaunch"`
	State                   aws.StringValue  `ec2:"State" xml:"state"`
	SubnetID                aws.StringValue  `ec2:"SubnetId" xml:"subnetId"`
	Tags                    []Tag            `ec2:"Tags" xml:"tagSet>item"`
	VPCID                   aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *Subnet) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		SubnetStateAvailable,
		SubnetStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	SubnetStateAvailable = "available"
	SubnetStatePending   = "pending"
)

// Possible values for EC2.
const (
	SummaryStatusImpaired         = "impaired"
	SummaryStatusInsufficientData = "insufficient-data"
	SummaryStatusNotApplicable    = "not-applicable"
	SummaryStatusOK               = "ok"
)

// Tag is undocumented.
type Tag struct {
	Key   aws.StringValue `ec2:"Key" xml:"key"`
	Value aws.StringValue `ec2:"Value" xml:"value"`
}

func (v *Tag) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TagDescription is undocumented.
type TagDescription struct {
	Key          aws.StringValue `ec2:"Key" xml:"key"`
	ResourceID   aws.StringValue `ec2:"ResourceId" xml:"resourceId"`
	ResourceType aws.StringValue `ec2:"ResourceType" xml:"resourceType"`
	Value        aws.StringValue `ec2:"Value" xml:"value"`
}

func (v *TagDescription) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ResourceTypeEnum := []string{
		ResourceTypeCustomerGateway,
		ResourceTypeDHCPOptions,
		ResourceTypeImage,
		ResourceTypeInstance,
		ResourceTypeInternetGateway,
		ResourceTypeNetworkACL,
		ResourceTypeNetworkInterface,
		ResourceTypeReservedInstances,
		ResourceTypeRouteTable,
		ResourceTypeSecurityGroup,
		ResourceTypeSnapshot,
		ResourceTypeSpotInstancesRequest,
		ResourceTypeSubnet,
		ResourceTypeVPC,
		ResourceTypeVPNConnection,
		ResourceTypeVPNGateway,
		ResourceTypeVolume,
	}
	if err := model.ValidateEnum(v, "ResourceType", ResourceTypeEnum); err != nil {
		errors["ResourceType"] = append(errors["ResourceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	TelemetryStatusDown = "DOWN"
	TelemetryStatusUp   = "UP"
)

// Possible values for EC2.
const (
	TenancyDedicated = "dedicated"
	TenancyDefault   = "default"
)

// TerminateInstancesRequest is undocumented.
type TerminateInstancesRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceIDs []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
}

func (v *TerminateInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceIDs"); err != nil {
		errors["InstanceIDs"] = append(errors["InstanceIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TerminateInstancesResult is undocumented.
type TerminateInstancesResult struct {
	TerminatingInstances []InstanceStateChange `ec2:"TerminatingInstances" xml:"instancesSet>item"`
}

func (v *TerminateInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UnassignPrivateIPAddressesRequest is undocumented.
type UnassignPrivateIPAddressesRequest struct {
	NetworkInterfaceID aws.StringValue `ec2:"NetworkInterfaceId" xml:"networkInterfaceId"`
	PrivateIPAddresses []string        `ec2:"PrivateIpAddresses" xml:"privateIpAddress>PrivateIpAddress"`
}

func (v *UnassignPrivateIPAddressesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NetworkInterfaceID"); err != nil {
		errors["NetworkInterfaceID"] = append(errors["NetworkInterfaceID"], err)
	}

	if err := model.ValidateRequired(v, "PrivateIPAddresses"); err != nil {
		errors["PrivateIPAddresses"] = append(errors["PrivateIPAddresses"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UnmonitorInstancesRequest is undocumented.
type UnmonitorInstancesRequest struct {
	DryRun      aws.BooleanValue `ec2:"DryRun" xml:"dryRun"`
	InstanceIDs []string         `ec2:"InstanceId" xml:"InstanceId>InstanceId"`
}

func (v *UnmonitorInstancesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceIDs"); err != nil {
		errors["InstanceIDs"] = append(errors["InstanceIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UnmonitorInstancesResult is undocumented.
type UnmonitorInstancesResult struct {
	InstanceMonitorings []InstanceMonitoring `ec2:"InstanceMonitorings" xml:"instancesSet>item"`
}

func (v *UnmonitorInstancesResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UserIDGroupPair is undocumented.
type UserIDGroupPair struct {
	GroupID   aws.StringValue `ec2:"GroupId" xml:"groupId"`
	GroupName aws.StringValue `ec2:"GroupName" xml:"groupName"`
	UserID    aws.StringValue `ec2:"UserId" xml:"userId"`
}

func (v *UserIDGroupPair) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VGWTelemetry is undocumented.
type VGWTelemetry struct {
	AcceptedRouteCount aws.IntegerValue `ec2:"AcceptedRouteCount" xml:"acceptedRouteCount"`
	LastStatusChange   time.Time        `ec2:"LastStatusChange" xml:"lastStatusChange"`
	OutsideIPAddress   aws.StringValue  `ec2:"OutsideIpAddress" xml:"outsideIpAddress"`
	Status             aws.StringValue  `ec2:"Status" xml:"status"`
	StatusMessage      aws.StringValue  `ec2:"StatusMessage" xml:"statusMessage"`
}

func (v *VGWTelemetry) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		TelemetryStatusDown,
		TelemetryStatusUp,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VirtualizationTypeHVM         = "hvm"
	VirtualizationTypeParavirtual = "paravirtual"
)

// Volume is undocumented.
type Volume struct {
	Attachments      []VolumeAttachment `ec2:"Attachments" xml:"attachmentSet>item"`
	AvailabilityZone aws.StringValue    `ec2:"AvailabilityZone" xml:"availabilityZone"`
	CreateTime       time.Time          `ec2:"CreateTime" xml:"createTime"`
	Encrypted        aws.BooleanValue   `ec2:"Encrypted" xml:"encrypted"`
	IOPS             aws.IntegerValue   `ec2:"Iops" xml:"iops"`
	KMSKeyID         aws.StringValue    `ec2:"KmsKeyId" xml:"kmsKeyId"`
	Size             aws.IntegerValue   `ec2:"Size" xml:"size"`
	SnapshotID       aws.StringValue    `ec2:"SnapshotId" xml:"snapshotId"`
	State            aws.StringValue    `ec2:"State" xml:"status"`
	Tags             []Tag              `ec2:"Tags" xml:"tagSet>item"`
	VolumeID         aws.StringValue    `ec2:"VolumeId" xml:"volumeId"`
	VolumeType       aws.StringValue    `ec2:"VolumeType" xml:"volumeType"`
}

func (v *Volume) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		VolumeStateAvailable,
		VolumeStateCreating,
		VolumeStateDeleted,
		VolumeStateDeleting,
		VolumeStateError,
		VolumeStateInUse,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	VolumeTypeEnum := []string{
		VolumeTypeGp2,
		VolumeTypeIo1,
		VolumeTypeStandard,
	}
	if err := model.ValidateEnum(v, "VolumeType", VolumeTypeEnum); err != nil {
		errors["VolumeType"] = append(errors["VolumeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeAttachment is undocumented.
type VolumeAttachment struct {
	AttachTime          time.Time        `ec2:"AttachTime" xml:"attachTime"`
	DeleteOnTermination aws.BooleanValue `ec2:"DeleteOnTermination" xml:"deleteOnTermination"`
	Device              aws.StringValue  `ec2:"Device" xml:"device"`
	InstanceID          aws.StringValue  `ec2:"InstanceId" xml:"instanceId"`
	State               aws.StringValue  `ec2:"State" xml:"status"`
	VolumeID            aws.StringValue  `ec2:"VolumeId" xml:"volumeId"`
}

func (v *VolumeAttachment) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		VolumeAttachmentStateAttached,
		VolumeAttachmentStateAttaching,
		VolumeAttachmentStateDetached,
		VolumeAttachmentStateDetaching,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VolumeAttachmentStateAttached  = "attached"
	VolumeAttachmentStateAttaching = "attaching"
	VolumeAttachmentStateDetached  = "detached"
	VolumeAttachmentStateDetaching = "detaching"
)

// Possible values for EC2.
const (
	VolumeAttributeNameAutoEnableIo = "autoEnableIO"
	VolumeAttributeNameProductCodes = "productCodes"
)

// VolumeDetail is undocumented.
type VolumeDetail struct {
	Size aws.LongValue `ec2:"Size" xml:"size"`
}

func (v *VolumeDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Size"); err != nil {
		errors["Size"] = append(errors["Size"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VolumeStateAvailable = "available"
	VolumeStateCreating  = "creating"
	VolumeStateDeleted   = "deleted"
	VolumeStateDeleting  = "deleting"
	VolumeStateError     = "error"
	VolumeStateInUse     = "in-use"
)

// VolumeStatusAction is undocumented.
type VolumeStatusAction struct {
	Code        aws.StringValue `ec2:"Code" xml:"code"`
	Description aws.StringValue `ec2:"Description" xml:"description"`
	EventID     aws.StringValue `ec2:"EventId" xml:"eventId"`
	EventType   aws.StringValue `ec2:"EventType" xml:"eventType"`
}

func (v *VolumeStatusAction) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeStatusDetails is undocumented.
type VolumeStatusDetails struct {
	Name   aws.StringValue `ec2:"Name" xml:"name"`
	Status aws.StringValue `ec2:"Status" xml:"status"`
}

func (v *VolumeStatusDetails) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	NameEnum := []string{
		VolumeStatusNameIoEnabled,
		VolumeStatusNameIoPerformance,
	}
	if err := model.ValidateEnum(v, "Name", NameEnum); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeStatusEvent is undocumented.
type VolumeStatusEvent struct {
	Description aws.StringValue `ec2:"Description" xml:"description"`
	EventID     aws.StringValue `ec2:"EventId" xml:"eventId"`
	EventType   aws.StringValue `ec2:"EventType" xml:"eventType"`
	NotAfter    time.Time       `ec2:"NotAfter" xml:"notAfter"`
	NotBefore   time.Time       `ec2:"NotBefore" xml:"notBefore"`
}

func (v *VolumeStatusEvent) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VolumeStatusInfo is undocumented.
type VolumeStatusInfo struct {
	Details []VolumeStatusDetails `ec2:"Details" xml:"details>item"`
	Status  aws.StringValue       `ec2:"Status" xml:"status"`
}

func (v *VolumeStatusInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StatusEnum := []string{
		VolumeStatusInfoStatusImpaired,
		VolumeStatusInfoStatusInsufficientData,
		VolumeStatusInfoStatusOK,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VolumeStatusInfoStatusImpaired         = "impaired"
	VolumeStatusInfoStatusInsufficientData = "insufficient-data"
	VolumeStatusInfoStatusOK               = "ok"
)

// VolumeStatusItem is undocumented.
type VolumeStatusItem struct {
	Actions          []VolumeStatusAction `ec2:"Actions" xml:"actionsSet>item"`
	AvailabilityZone aws.StringValue      `ec2:"AvailabilityZone" xml:"availabilityZone"`
	Events           []VolumeStatusEvent  `ec2:"Events" xml:"eventsSet>item"`
	VolumeID         aws.StringValue      `ec2:"VolumeId" xml:"volumeId"`
	VolumeStatus     *VolumeStatusInfo    `ec2:"VolumeStatus" xml:"volumeStatus"`
}

func (v *VolumeStatusItem) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VolumeStatusNameIoEnabled     = "io-enabled"
	VolumeStatusNameIoPerformance = "io-performance"
)

// Possible values for EC2.
const (
	VolumeTypeGp2      = "gp2"
	VolumeTypeIo1      = "io1"
	VolumeTypeStandard = "standard"
)

// VPC is undocumented.
type VPC struct {
	CIDRBlock       aws.StringValue  `ec2:"CidrBlock" xml:"cidrBlock"`
	DHCPOptionsID   aws.StringValue  `ec2:"DhcpOptionsId" xml:"dhcpOptionsId"`
	InstanceTenancy aws.StringValue  `ec2:"InstanceTenancy" xml:"instanceTenancy"`
	IsDefault       aws.BooleanValue `ec2:"IsDefault" xml:"isDefault"`
	State           aws.StringValue  `ec2:"State" xml:"state"`
	Tags            []Tag            `ec2:"Tags" xml:"tagSet>item"`
	VPCID           aws.StringValue  `ec2:"VpcId" xml:"vpcId"`
}

func (v *VPC) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	InstanceTenancyEnum := []string{
		TenancyDedicated,
		TenancyDefault,
	}
	if err := model.ValidateEnum(v, "InstanceTenancy", InstanceTenancyEnum); err != nil {
		errors["InstanceTenancy"] = append(errors["InstanceTenancy"], err)
	}

	StateEnum := []string{
		VPCStateAvailable,
		VPCStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPCAttachment is undocumented.
type VPCAttachment struct {
	State aws.StringValue `ec2:"State" xml:"state"`
	VPCID aws.StringValue `ec2:"VpcId" xml:"vpcId"`
}

func (v *VPCAttachment) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		AttachmentStatusAttached,
		AttachmentStatusAttaching,
		AttachmentStatusDetached,
		AttachmentStatusDetaching,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VPCAttributeNameEnableDNSHostnames = "enableDnsHostnames"
	VPCAttributeNameEnableDNSSupport   = "enableDnsSupport"
)

// VPCPeeringConnection is undocumented.
type VPCPeeringConnection struct {
	AccepterVPCInfo        *VPCPeeringConnectionVPCInfo     `ec2:"AccepterVpcInfo" xml:"accepterVpcInfo"`
	ExpirationTime         time.Time                        `ec2:"ExpirationTime" xml:"expirationTime"`
	RequesterVPCInfo       *VPCPeeringConnectionVPCInfo     `ec2:"RequesterVpcInfo" xml:"requesterVpcInfo"`
	Status                 *VPCPeeringConnectionStateReason `ec2:"Status" xml:"status"`
	Tags                   []Tag                            `ec2:"Tags" xml:"tagSet>item"`
	VPCPeeringConnectionID aws.StringValue                  `ec2:"VpcPeeringConnectionId" xml:"vpcPeeringConnectionId"`
}

func (v *VPCPeeringConnection) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPCPeeringConnectionStateReason is undocumented.
type VPCPeeringConnectionStateReason struct {
	Code    aws.StringValue `ec2:"Code" xml:"code"`
	Message aws.StringValue `ec2:"Message" xml:"message"`
}

func (v *VPCPeeringConnectionStateReason) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPCPeeringConnectionVPCInfo is undocumented.
type VPCPeeringConnectionVPCInfo struct {
	CIDRBlock aws.StringValue `ec2:"CidrBlock" xml:"cidrBlock"`
	OwnerID   aws.StringValue `ec2:"OwnerId" xml:"ownerId"`
	VPCID     aws.StringValue `ec2:"VpcId" xml:"vpcId"`
}

func (v *VPCPeeringConnectionVPCInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VPCStateAvailable = "available"
	VPCStatePending   = "pending"
)

// VPNConnection is undocumented.
type VPNConnection struct {
	CustomerGatewayConfiguration aws.StringValue       `ec2:"CustomerGatewayConfiguration" xml:"customerGatewayConfiguration"`
	CustomerGatewayID            aws.StringValue       `ec2:"CustomerGatewayId" xml:"customerGatewayId"`
	Options                      *VPNConnectionOptions `ec2:"Options" xml:"options"`
	Routes                       []VPNStaticRoute      `ec2:"Routes" xml:"routes>item"`
	State                        aws.StringValue       `ec2:"State" xml:"state"`
	Tags                         []Tag                 `ec2:"Tags" xml:"tagSet>item"`
	Type                         aws.StringValue       `ec2:"Type" xml:"type"`
	VGWTelemetry                 []VGWTelemetry        `ec2:"VgwTelemetry" xml:"vgwTelemetry>item"`
	VPNConnectionID              aws.StringValue       `ec2:"VpnConnectionId" xml:"vpnConnectionId"`
	VPNGatewayID                 aws.StringValue       `ec2:"VpnGatewayId" xml:"vpnGatewayId"`
}

func (v *VPNConnection) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		VPNStateAvailable,
		VPNStateDeleted,
		VPNStateDeleting,
		VPNStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	TypeEnum := []string{
		GatewayTypeIPsec1,
	}
	if err := model.ValidateEnum(v, "Type", TypeEnum); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPNConnectionOptions is undocumented.
type VPNConnectionOptions struct {
	StaticRoutesOnly aws.BooleanValue `ec2:"StaticRoutesOnly" xml:"staticRoutesOnly"`
}

func (v *VPNConnectionOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPNConnectionOptionsSpecification is undocumented.
type VPNConnectionOptionsSpecification struct {
	StaticRoutesOnly aws.BooleanValue `ec2:"StaticRoutesOnly" xml:"staticRoutesOnly"`
}

func (v *VPNConnectionOptionsSpecification) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPNGateway is undocumented.
type VPNGateway struct {
	AvailabilityZone aws.StringValue `ec2:"AvailabilityZone" xml:"availabilityZone"`
	State            aws.StringValue `ec2:"State" xml:"state"`
	Tags             []Tag           `ec2:"Tags" xml:"tagSet>item"`
	Type             aws.StringValue `ec2:"Type" xml:"type"`
	VPCAttachments   []VPCAttachment `ec2:"VpcAttachments" xml:"attachments>item"`
	VPNGatewayID     aws.StringValue `ec2:"VpnGatewayId" xml:"vpnGatewayId"`
}

func (v *VPNGateway) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		VPNStateAvailable,
		VPNStateDeleted,
		VPNStateDeleting,
		VPNStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	TypeEnum := []string{
		GatewayTypeIPsec1,
	}
	if err := model.ValidateEnum(v, "Type", TypeEnum); err != nil {
		errors["Type"] = append(errors["Type"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VPNStateAvailable = "available"
	VPNStateDeleted   = "deleted"
	VPNStateDeleting  = "deleting"
	VPNStatePending   = "pending"
)

// VPNStaticRoute is undocumented.
type VPNStaticRoute struct {
	DestinationCIDRBlock aws.StringValue `ec2:"DestinationCidrBlock" xml:"destinationCidrBlock"`
	Source               aws.StringValue `ec2:"Source" xml:"source"`
	State                aws.StringValue `ec2:"State" xml:"state"`
}

func (v *VPNStaticRoute) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	SourceEnum := []string{
		VPNStaticRouteSourceStatic,
	}
	if err := model.ValidateEnum(v, "Source", SourceEnum); err != nil {
		errors["Source"] = append(errors["Source"], err)
	}

	StateEnum := []string{
		VPNStateAvailable,
		VPNStateDeleted,
		VPNStateDeleting,
		VPNStatePending,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for EC2.
const (
	VPNStaticRouteSourceStatic = "Static"
)

// avoid errors if the packages aren't referenced
var _ time.Time
