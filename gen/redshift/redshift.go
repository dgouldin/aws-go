// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package redshift provides a client for Amazon Redshift.
package redshift

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

// RedShift is a client for Amazon Redshift.
type RedShift struct {
	client *aws.QueryClient
}

// New returns a new RedShift client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *RedShift {
	if client == nil {
		client = http.DefaultClient
	}

	service := "redshift"
	endpoint, service, region := endpoints.Lookup("redshift", region)

	return &RedShift{
		client: &aws.QueryClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2012-12-01",
		},
	}
}

// AuthorizeClusterSecurityGroupIngress adds an inbound (ingress) rule to
// an Amazon Redshift security group. Depending on whether the application
// accessing your cluster is running on the Internet or an EC2 instance,
// you can authorize inbound access to either a Classless Interdomain
// Routing IP address range or an EC2 security group. You can add as many
// as 20 ingress rules to an Amazon Redshift security group. The EC2
// security group must be defined in the AWS region where the cluster
// resides. For an overview of blocks, see the Wikipedia article on
// Classless Inter-Domain Routing . You must also associate the security
// group with a cluster so that clients running on these IP addresses or
// the EC2 instance are authorized to connect to the cluster. For
// information about managing security groups, go to Working with Security
// Groups in the Amazon Redshift Cluster Management Guide
func (c *RedShift) AuthorizeClusterSecurityGroupIngress(req *AuthorizeClusterSecurityGroupIngressMessage) (resp *AuthorizeClusterSecurityGroupIngressResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AuthorizeClusterSecurityGroupIngressResult{}
	err = c.client.Do("AuthorizeClusterSecurityGroupIngress", "POST", "/", req, resp)
	return
}

// AuthorizeSnapshotAccess authorizes the specified AWS customer account to
// restore the specified snapshot. For more information about working with
// snapshots, go to Amazon Redshift Snapshots in the Amazon Redshift
// Cluster Management Guide .
func (c *RedShift) AuthorizeSnapshotAccess(req *AuthorizeSnapshotAccessMessage) (resp *AuthorizeSnapshotAccessResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &AuthorizeSnapshotAccessResult{}
	err = c.client.Do("AuthorizeSnapshotAccess", "POST", "/", req, resp)
	return
}

// CopyClusterSnapshot copies the specified automated cluster snapshot to a
// new manual cluster snapshot. The source must be an automated snapshot
// and it must be in the available state. When you delete a cluster, Amazon
// Redshift deletes any automated snapshots of the cluster. Also, when the
// retention period of the snapshot expires, Amazon Redshift automatically
// deletes it. If you want to keep an automated snapshot for a longer
// period, you can make a manual copy of the snapshot. Manual snapshots are
// retained until you delete them. For more information about working with
// snapshots, go to Amazon Redshift Snapshots in the Amazon Redshift
// Cluster Management Guide .
func (c *RedShift) CopyClusterSnapshot(req *CopyClusterSnapshotMessage) (resp *CopyClusterSnapshotResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CopyClusterSnapshotResult{}
	err = c.client.Do("CopyClusterSnapshot", "POST", "/", req, resp)
	return
}

// CreateCluster creates a new cluster. To create the cluster in virtual
// private cloud you must provide cluster subnet group name. If you don't
// provide a cluster subnet group name or the cluster security group
// parameter, Amazon Redshift creates a non-VPC cluster, it associates the
// default cluster security group with the cluster. For more information
// about managing clusters, go to Amazon Redshift Clusters in the Amazon
// Redshift Cluster Management Guide .
func (c *RedShift) CreateCluster(req *CreateClusterMessage) (resp *CreateClusterResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateClusterResult{}
	err = c.client.Do("CreateCluster", "POST", "/", req, resp)
	return
}

// CreateClusterParameterGroup creates an Amazon Redshift parameter group.
// Creating parameter groups is independent of creating clusters. You can
// associate a cluster with a parameter group when you create the cluster.
// You can also associate an existing cluster with a parameter group after
// the cluster is created by using ModifyCluster . Parameters in the
// parameter group define specific behavior that applies to the databases
// you create on the cluster. For more information about managing parameter
// groups, go to Amazon Redshift Parameter Groups in the Amazon Redshift
// Cluster Management Guide .
func (c *RedShift) CreateClusterParameterGroup(req *CreateClusterParameterGroupMessage) (resp *CreateClusterParameterGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateClusterParameterGroupResult{}
	err = c.client.Do("CreateClusterParameterGroup", "POST", "/", req, resp)
	return
}

// CreateClusterSecurityGroup creates a new Amazon Redshift security group.
// You use security groups to control access to non-VPC clusters. For
// information about managing security groups, go to Amazon Redshift
// Cluster Security Groups in the Amazon Redshift Cluster Management Guide
// .
func (c *RedShift) CreateClusterSecurityGroup(req *CreateClusterSecurityGroupMessage) (resp *CreateClusterSecurityGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateClusterSecurityGroupResult{}
	err = c.client.Do("CreateClusterSecurityGroup", "POST", "/", req, resp)
	return
}

// CreateClusterSnapshot creates a manual snapshot of the specified
// cluster. The cluster must be in the available state. For more
// information about working with snapshots, go to Amazon Redshift
// Snapshots in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) CreateClusterSnapshot(req *CreateClusterSnapshotMessage) (resp *CreateClusterSnapshotResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateClusterSnapshotResult{}
	err = c.client.Do("CreateClusterSnapshot", "POST", "/", req, resp)
	return
}

// CreateClusterSubnetGroup creates a new Amazon Redshift subnet group. You
// must provide a list of one or more subnets in your existing Amazon
// Virtual Private Cloud (Amazon when creating Amazon Redshift subnet
// group. For information about subnet groups, go to Amazon Redshift
// Cluster Subnet Groups in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) CreateClusterSubnetGroup(req *CreateClusterSubnetGroupMessage) (resp *CreateClusterSubnetGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateClusterSubnetGroupResult{}
	err = c.client.Do("CreateClusterSubnetGroup", "POST", "/", req, resp)
	return
}

// CreateEventSubscription creates an Amazon Redshift event notification
// subscription. This action requires an ARN (Amazon Resource Name) of an
// Amazon SNS topic created by either the Amazon Redshift console, the
// Amazon SNS console, or the Amazon SNS To obtain an ARN with Amazon you
// must create a topic in Amazon SNS and subscribe to the topic. The ARN is
// displayed in the SNS console. You can specify the source type, and lists
// of Amazon Redshift source IDs, event categories, and event severities.
// Notifications will be sent for all events you want that match those
// criteria. For example, you can specify source type = cluster, source ID
// = my-cluster-1 and mycluster2, event categories = Availability, Backup,
// and severity = The subscription will only send notifications for those
// events in the Availability and Backup categories for the specified
// clusters. If you specify both the source type and source IDs, such as
// source type = cluster and source identifier = my-cluster-1,
// notifications will be sent for all the cluster events for my-cluster-1.
// If you specify a source type but do not specify a source identifier, you
// will receive notice of the events for the objects of that type in your
// AWS account. If you do not specify either the SourceType nor the
// SourceIdentifier, you will be notified of events generated from all
// Amazon Redshift sources belonging to your AWS account. You must specify
// a source type if you specify a source ID.
func (c *RedShift) CreateEventSubscription(req *CreateEventSubscriptionMessage) (resp *CreateEventSubscriptionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateEventSubscriptionResult{}
	err = c.client.Do("CreateEventSubscription", "POST", "/", req, resp)
	return
}

// CreateHSMClientCertificate creates an HSM client certificate that an
// Amazon Redshift cluster will use to connect to the client's HSM in order
// to store and retrieve the keys used to encrypt the cluster databases.
// The command returns a public key, which you must store in the In
// addition to creating the HSM certificate, you must create an Amazon
// Redshift HSM configuration that provides a cluster the information
// needed to store and use encryption keys in the For more information, go
// to Hardware Security Modules in the Amazon Redshift Cluster Management
// Guide.
func (c *RedShift) CreateHSMClientCertificate(req *CreateHSMClientCertificateMessage) (resp *CreateHSMClientCertificateResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateHSMClientCertificateResult{}
	err = c.client.Do("CreateHsmClientCertificate", "POST", "/", req, resp)
	return
}

// CreateHSMConfiguration creates an HSM configuration that contains the
// information required by an Amazon Redshift cluster to store and use
// database encryption keys in a Hardware Security Module After creating
// the HSM configuration, you can specify it as a parameter when creating a
// cluster. The cluster will then store its encryption keys in the In
// addition to creating an HSM configuration, you must also create an HSM
// client certificate. For more information, go to Hardware Security
// Modules in the Amazon Redshift Cluster Management Guide.
func (c *RedShift) CreateHSMConfiguration(req *CreateHSMConfigurationMessage) (resp *CreateHSMConfigurationResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateHSMConfigurationResult{}
	err = c.client.Do("CreateHsmConfiguration", "POST", "/", req, resp)
	return
}

// CreateTags adds one or more tags to a specified resource. A resource can
// have up to 10 tags. If you try to create more than 10 tags for a
// resource, you will receive an error and the attempt will fail. If you
// specify a key that already exists for the resource, the value for that
// key will be updated with the new value.
func (c *RedShift) CreateTags(req *CreateTagsMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreateTags", "POST", "/", req, nil)
	return
}

// DeleteCluster deletes a previously provisioned cluster. A successful
// response from the web service indicates that the request was received
// correctly. Use DescribeClusters to monitor the status of the deletion.
// The delete operation cannot be canceled or reverted once submitted. For
// more information about managing clusters, go to Amazon Redshift Clusters
// in the Amazon Redshift Cluster Management Guide . If you want to shut
// down the cluster and retain it for future use, set
// SkipFinalClusterSnapshot to false and specify a name for
// FinalClusterSnapshotIdentifier . You can later restore this snapshot to
// resume using the cluster. If a final cluster snapshot is requested, the
// status of the cluster will be "final-snapshot" while the snapshot is
// being taken, then it's "deleting" once Amazon Redshift begins deleting
// the cluster. For more information about managing clusters, go to Amazon
// Redshift Clusters in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) DeleteCluster(req *DeleteClusterMessage) (resp *DeleteClusterResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteClusterResult{}
	err = c.client.Do("DeleteCluster", "POST", "/", req, resp)
	return
}

// DeleteClusterParameterGroup deletes a specified Amazon Redshift
// parameter group. You cannot delete a parameter group if it is associated
// with a cluster.
func (c *RedShift) DeleteClusterParameterGroup(req *DeleteClusterParameterGroupMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteClusterParameterGroup", "POST", "/", req, nil)
	return
}

// DeleteClusterSecurityGroup deletes an Amazon Redshift security group.
// You cannot delete a security group that is associated with any clusters.
// You cannot delete the default security group. For information about
// managing security groups, go to Amazon Redshift Cluster Security Groups
// in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) DeleteClusterSecurityGroup(req *DeleteClusterSecurityGroupMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteClusterSecurityGroup", "POST", "/", req, nil)
	return
}

// DeleteClusterSnapshot deletes the specified manual snapshot. The
// snapshot must be in the available state, with no other users authorized
// to access the snapshot. Unlike automated snapshots, manual snapshots are
// retained even after you delete your cluster. Amazon Redshift does not
// delete your manual snapshots. You must delete manual snapshot explicitly
// to avoid getting charged. If other accounts are authorized to access the
// snapshot, you must revoke all of the authorizations before you can
// delete the snapshot.
func (c *RedShift) DeleteClusterSnapshot(req *DeleteClusterSnapshotMessage) (resp *DeleteClusterSnapshotResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteClusterSnapshotResult{}
	err = c.client.Do("DeleteClusterSnapshot", "POST", "/", req, resp)
	return
}

// DeleteClusterSubnetGroup is undocumented.
func (c *RedShift) DeleteClusterSubnetGroup(req *DeleteClusterSubnetGroupMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteClusterSubnetGroup", "POST", "/", req, nil)
	return
}

// DeleteEventSubscription deletes an Amazon Redshift event notification
// subscription.
func (c *RedShift) DeleteEventSubscription(req *DeleteEventSubscriptionMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteEventSubscription", "POST", "/", req, nil)
	return
}

// DeleteHSMClientCertificate is undocumented.
func (c *RedShift) DeleteHSMClientCertificate(req *DeleteHSMClientCertificateMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteHsmClientCertificate", "POST", "/", req, nil)
	return
}

// DeleteHSMConfiguration deletes the specified Amazon Redshift HSM
// configuration.
func (c *RedShift) DeleteHSMConfiguration(req *DeleteHSMConfigurationMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteHsmConfiguration", "POST", "/", req, nil)
	return
}

// DeleteTags deletes a tag or tags from a resource. You must provide the
// ARN of the resource from which you want to delete the tag or tags.
func (c *RedShift) DeleteTags(req *DeleteTagsMessage) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteTags", "POST", "/", req, nil)
	return
}

// DescribeClusterParameterGroups returns a list of Amazon Redshift
// parameter groups, including parameter groups you created and the default
// parameter group. For each parameter group, the response includes the
// parameter group name, description, and parameter group family name. You
// can optionally specify a name to retrieve the description of a specific
// parameter group. For more information about managing parameter groups,
// go to Amazon Redshift Parameter Groups in the Amazon Redshift Cluster
// Management Guide . If you specify both tag keys and tag values in the
// same request, Amazon Redshift returns all parameter groups that match
// any combination of the specified keys and values. For example, if you
// have owner and environment for tag keys, and admin and test for tag
// values, all parameter groups that have any combination of those values
// are returned. If both tag keys and values are omitted from the request,
// parameter groups are returned regardless of whether they have tag keys
// or values associated with them.
func (c *RedShift) DescribeClusterParameterGroups(req *DescribeClusterParameterGroupsMessage) (resp *DescribeClusterParameterGroupsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClusterParameterGroupsResult{}
	err = c.client.Do("DescribeClusterParameterGroups", "POST", "/", req, resp)
	return
}

// DescribeClusterParameters returns a detailed list of parameters
// contained within the specified Amazon Redshift parameter group. For each
// parameter the response includes information such as parameter name,
// description, data type, value, whether the parameter value is
// modifiable, and so on. You can specify source filter to retrieve
// parameters of only specific type. For example, to retrieve parameters
// that were modified by a user action such as from
// ModifyClusterParameterGroup , you can specify source equal to user For
// more information about managing parameter groups, go to Amazon Redshift
// Parameter Groups in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) DescribeClusterParameters(req *DescribeClusterParametersMessage) (resp *DescribeClusterParametersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClusterParametersResult{}
	err = c.client.Do("DescribeClusterParameters", "POST", "/", req, resp)
	return
}

// DescribeClusterSecurityGroups returns information about Amazon Redshift
// security groups. If the name of a security group is specified, the
// response will contain only information about only that security group.
// For information about managing security groups, go to Amazon Redshift
// Cluster Security Groups in the Amazon Redshift Cluster Management Guide
// . If you specify both tag keys and tag values in the same request,
// Amazon Redshift returns all security groups that match any combination
// of the specified keys and values. For example, if you have owner and
// environment for tag keys, and admin and test for tag values, all
// security groups that have any combination of those values are returned.
// If both tag keys and values are omitted from the request, security
// groups are returned regardless of whether they have tag keys or values
// associated with them.
func (c *RedShift) DescribeClusterSecurityGroups(req *DescribeClusterSecurityGroupsMessage) (resp *DescribeClusterSecurityGroupsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClusterSecurityGroupsResult{}
	err = c.client.Do("DescribeClusterSecurityGroups", "POST", "/", req, resp)
	return
}

// DescribeClusterSnapshots returns one or more snapshot objects, which
// contain metadata about your cluster snapshots. By default, this
// operation returns information about all snapshots of all clusters that
// are owned by you AWS customer account. No information is returned for
// snapshots owned by inactive AWS customer accounts. If you specify both
// tag keys and tag values in the same request, Amazon Redshift returns all
// snapshots that match any combination of the specified keys and values.
// For example, if you have owner and environment for tag keys, and admin
// and test for tag values, all snapshots that have any combination of
// those values are returned. Only snapshots that you own are returned in
// the response; shared snapshots are not returned with the tag key and tag
// value request parameters. If both tag keys and values are omitted from
// the request, snapshots are returned regardless of whether they have tag
// keys or values associated with them.
func (c *RedShift) DescribeClusterSnapshots(req *DescribeClusterSnapshotsMessage) (resp *DescribeClusterSnapshotsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClusterSnapshotsResult{}
	err = c.client.Do("DescribeClusterSnapshots", "POST", "/", req, resp)
	return
}

// DescribeClusterSubnetGroups returns one or more cluster subnet group
// objects, which contain metadata about your cluster subnet groups. By
// default, this operation returns information about all cluster subnet
// groups that are defined in you AWS account. If you specify both tag keys
// and tag values in the same request, Amazon Redshift returns all subnet
// groups that match any combination of the specified keys and values. For
// example, if you have owner and environment for tag keys, and admin and
// test for tag values, all subnet groups that have any combination of
// those values are returned. If both tag keys and values are omitted from
// the request, subnet groups are returned regardless of whether they have
// tag keys or values associated with them.
func (c *RedShift) DescribeClusterSubnetGroups(req *DescribeClusterSubnetGroupsMessage) (resp *DescribeClusterSubnetGroupsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClusterSubnetGroupsResult{}
	err = c.client.Do("DescribeClusterSubnetGroups", "POST", "/", req, resp)
	return
}

// DescribeClusterVersions returns descriptions of the available Amazon
// Redshift cluster versions. You can call this operation even before
// creating any clusters to learn more about the Amazon Redshift versions.
// For more information about managing clusters, go to Amazon Redshift
// Clusters in the Amazon Redshift Cluster Management Guide
func (c *RedShift) DescribeClusterVersions(req *DescribeClusterVersionsMessage) (resp *DescribeClusterVersionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClusterVersionsResult{}
	err = c.client.Do("DescribeClusterVersions", "POST", "/", req, resp)
	return
}

// DescribeClusters returns properties of provisioned clusters including
// general cluster properties, cluster database properties, maintenance and
// backup properties, and security and access properties. This operation
// supports pagination. For more information about managing clusters, go to
// Amazon Redshift Clusters in the Amazon Redshift Cluster Management Guide
// . If you specify both tag keys and tag values in the same request,
// Amazon Redshift returns all clusters that match any combination of the
// specified keys and values. For example, if you have owner and
// environment for tag keys, and admin and test for tag values, all
// clusters that have any combination of those values are returned. If both
// tag keys and values are omitted from the request, clusters are returned
// regardless of whether they have tag keys or values associated with them.
func (c *RedShift) DescribeClusters(req *DescribeClustersMessage) (resp *DescribeClustersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeClustersResult{}
	err = c.client.Do("DescribeClusters", "POST", "/", req, resp)
	return
}

// DescribeDefaultClusterParameters returns a list of parameter settings
// for the specified parameter group family. For more information about
// managing parameter groups, go to Amazon Redshift Parameter Groups in the
// Amazon Redshift Cluster Management Guide .
func (c *RedShift) DescribeDefaultClusterParameters(req *DescribeDefaultClusterParametersMessage) (resp *DescribeDefaultClusterParametersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeDefaultClusterParametersResult{}
	err = c.client.Do("DescribeDefaultClusterParameters", "POST", "/", req, resp)
	return
}

// DescribeEventCategories displays a list of event categories for all
// event source types, or for a specified source type. For a list of the
// event categories and source types, go to Amazon Redshift Event
// Notifications
func (c *RedShift) DescribeEventCategories(req *DescribeEventCategoriesMessage) (resp *DescribeEventCategoriesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeEventCategoriesResult{}
	err = c.client.Do("DescribeEventCategories", "POST", "/", req, resp)
	return
}

// DescribeEventSubscriptions lists descriptions of all the Amazon Redshift
// event notifications subscription for a customer account. If you specify
// a subscription name, lists the description for that subscription.
func (c *RedShift) DescribeEventSubscriptions(req *DescribeEventSubscriptionsMessage) (resp *DescribeEventSubscriptionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeEventSubscriptionsResult{}
	err = c.client.Do("DescribeEventSubscriptions", "POST", "/", req, resp)
	return
}

// DescribeEvents returns events related to clusters, security groups,
// snapshots, and parameter groups for the past 14 days. Events specific to
// a particular cluster, security group, snapshot or parameter group can be
// obtained by providing the name as a parameter. By default, the past hour
// of events are returned.
func (c *RedShift) DescribeEvents(req *DescribeEventsMessage) (resp *DescribeEventsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeEventsResult{}
	err = c.client.Do("DescribeEvents", "POST", "/", req, resp)
	return
}

// DescribeHSMClientCertificates returns information about the specified
// HSM client certificate. If no certificate ID is specified, returns
// information about all the HSM certificates owned by your AWS customer
// account. If you specify both tag keys and tag values in the same
// request, Amazon Redshift returns all HSM client certificates that match
// any combination of the specified keys and values. For example, if you
// have owner and environment for tag keys, and admin and test for tag
// values, all HSM client certificates that have any combination of those
// values are returned. If both tag keys and values are omitted from the
// request, HSM client certificates are returned regardless of whether they
// have tag keys or values associated with them.
func (c *RedShift) DescribeHSMClientCertificates(req *DescribeHSMClientCertificatesMessage) (resp *DescribeHSMClientCertificatesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeHSMClientCertificatesResult{}
	err = c.client.Do("DescribeHsmClientCertificates", "POST", "/", req, resp)
	return
}

// DescribeHSMConfigurations returns information about the specified Amazon
// Redshift HSM configuration. If no configuration ID is specified, returns
// information about all the HSM configurations owned by your AWS customer
// account. If you specify both tag keys and tag values in the same
// request, Amazon Redshift returns all HSM connections that match any
// combination of the specified keys and values. For example, if you have
// owner and environment for tag keys, and admin and test for tag values,
// all HSM connections that have any combination of those values are
// returned. If both tag keys and values are omitted from the request, HSM
// connections are returned regardless of whether they have tag keys or
// values associated with them.
func (c *RedShift) DescribeHSMConfigurations(req *DescribeHSMConfigurationsMessage) (resp *DescribeHSMConfigurationsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeHSMConfigurationsResult{}
	err = c.client.Do("DescribeHsmConfigurations", "POST", "/", req, resp)
	return
}

// DescribeLoggingStatus describes whether information, such as queries and
// connection attempts, is being logged for the specified Amazon Redshift
// cluster.
func (c *RedShift) DescribeLoggingStatus(req *DescribeLoggingStatusMessage) (resp *DescribeLoggingStatusResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeLoggingStatusResult{}
	err = c.client.Do("DescribeLoggingStatus", "POST", "/", req, resp)
	return
}

// DescribeOrderableClusterOptions returns a list of orderable cluster
// options. Before you create a new cluster you can use this operation to
// find what options are available, such as the EC2 Availability Zones in
// the specific AWS region that you can specify, and the node types you can
// request. The node types differ by available storage, memory, CPU and
// price. With the cost involved you might want to obtain a list of cluster
// options in the specific region and specify values when creating a
// cluster. For more information about managing clusters, go to Amazon
// Redshift Clusters in the Amazon Redshift Cluster Management Guide
func (c *RedShift) DescribeOrderableClusterOptions(req *DescribeOrderableClusterOptionsMessage) (resp *DescribeOrderableClusterOptionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeOrderableClusterOptionsResult{}
	err = c.client.Do("DescribeOrderableClusterOptions", "POST", "/", req, resp)
	return
}

// DescribeReservedNodeOfferings returns a list of the available reserved
// node offerings by Amazon Redshift with their descriptions including the
// node type, the fixed and recurring costs of reserving the node and
// duration the node will be reserved for you. These descriptions help you
// determine which reserve node offering you want to purchase. You then use
// the unique offering ID in you call to PurchaseReservedNodeOffering to
// reserve one or more nodes for your Amazon Redshift cluster. For more
// information about managing parameter groups, go to Purchasing Reserved
// Nodes in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) DescribeReservedNodeOfferings(req *DescribeReservedNodeOfferingsMessage) (resp *DescribeReservedNodeOfferingsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeReservedNodeOfferingsResult{}
	err = c.client.Do("DescribeReservedNodeOfferings", "POST", "/", req, resp)
	return
}

// DescribeReservedNodes is undocumented.
func (c *RedShift) DescribeReservedNodes(req *DescribeReservedNodesMessage) (resp *DescribeReservedNodesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeReservedNodesResult{}
	err = c.client.Do("DescribeReservedNodes", "POST", "/", req, resp)
	return
}

// DescribeResize returns information about the last resize operation for
// the specified cluster. If no resize operation has ever been initiated
// for the specified cluster, a 404 error is returned. If a resize
// operation was initiated and completed, the status of the resize remains
// as until the next resize. A resize operation can be requested using
// ModifyCluster and specifying a different number or type of nodes for the
// cluster.
func (c *RedShift) DescribeResize(req *DescribeResizeMessage) (resp *DescribeResizeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeResizeResult{}
	err = c.client.Do("DescribeResize", "POST", "/", req, resp)
	return
}

// DescribeTags returns a list of tags. You can return tags from a specific
// resource by specifying an or you can return all tags for a given type of
// resource, such as clusters, snapshots, and so on. The following are
// limitations for DescribeTags : You cannot specify an ARN and a
// resource-type value together in the same request. You cannot use the
// MaxRecords and Marker parameters together with the ARN parameter. The
// MaxRecords parameter can be a range from 10 to 50 results to return in a
// request. If you specify both tag keys and tag values in the same
// request, Amazon Redshift returns all resources that match any
// combination of the specified keys and values. For example, if you have
// owner and environment for tag keys, and admin and test for tag values,
// all resources that have any combination of those values are returned. If
// both tag keys and values are omitted from the request, resources are
// returned regardless of whether they have tag keys or values associated
// with them.
func (c *RedShift) DescribeTags(req *DescribeTagsMessage) (resp *DescribeTagsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeTagsResult{}
	err = c.client.Do("DescribeTags", "POST", "/", req, resp)
	return
}

// DisableLogging stops logging information, such as queries and connection
// attempts, for the specified Amazon Redshift cluster.
func (c *RedShift) DisableLogging(req *DisableLoggingMessage) (resp *DisableLoggingResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DisableLoggingResult{}
	err = c.client.Do("DisableLogging", "POST", "/", req, resp)
	return
}

// DisableSnapshotCopy disables the automatic copying of snapshots from one
// region to another region for a specified cluster.
func (c *RedShift) DisableSnapshotCopy(req *DisableSnapshotCopyMessage) (resp *DisableSnapshotCopyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DisableSnapshotCopyResult{}
	err = c.client.Do("DisableSnapshotCopy", "POST", "/", req, resp)
	return
}

// EnableLogging starts logging information, such as queries and connection
// attempts, for the specified Amazon Redshift cluster.
func (c *RedShift) EnableLogging(req *EnableLoggingMessage) (resp *EnableLoggingResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &EnableLoggingResult{}
	err = c.client.Do("EnableLogging", "POST", "/", req, resp)
	return
}

// EnableSnapshotCopy enables the automatic copy of snapshots from one
// region to another region for a specified cluster.
func (c *RedShift) EnableSnapshotCopy(req *EnableSnapshotCopyMessage) (resp *EnableSnapshotCopyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &EnableSnapshotCopyResult{}
	err = c.client.Do("EnableSnapshotCopy", "POST", "/", req, resp)
	return
}

// ModifyCluster modifies the settings for a cluster. For example, you can
// add another security or parameter group, update the preferred
// maintenance window, or change the master user password. Resetting a
// cluster password or modifying the security groups associated with a
// cluster do not need a reboot. However, modifying a parameter group
// requires a reboot for parameters to take effect. For more information
// about managing clusters, go to Amazon Redshift Clusters in the Amazon
// Redshift Cluster Management Guide . You can also change node type and
// the number of nodes to scale up or down the cluster. When resizing a
// cluster, you must specify both the number of nodes and the node type
// even if one of the parameters does not change.
func (c *RedShift) ModifyCluster(req *ModifyClusterMessage) (resp *ModifyClusterResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ModifyClusterResult{}
	err = c.client.Do("ModifyCluster", "POST", "/", req, resp)
	return
}

// ModifyClusterParameterGroup modifies the parameters of a parameter
// group. For more information about managing parameter groups, go to
// Amazon Redshift Parameter Groups in the Amazon Redshift Cluster
// Management Guide .
func (c *RedShift) ModifyClusterParameterGroup(req *ModifyClusterParameterGroupMessage) (resp *ModifyClusterParameterGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ModifyClusterParameterGroupResult{}
	err = c.client.Do("ModifyClusterParameterGroup", "POST", "/", req, resp)
	return
}

// ModifyClusterSubnetGroup modifies a cluster subnet group to include the
// specified list of VPC subnets. The operation replaces the existing list
// of subnets with the new list of subnets.
func (c *RedShift) ModifyClusterSubnetGroup(req *ModifyClusterSubnetGroupMessage) (resp *ModifyClusterSubnetGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ModifyClusterSubnetGroupResult{}
	err = c.client.Do("ModifyClusterSubnetGroup", "POST", "/", req, resp)
	return
}

// ModifyEventSubscription modifies an existing Amazon Redshift event
// notification subscription.
func (c *RedShift) ModifyEventSubscription(req *ModifyEventSubscriptionMessage) (resp *ModifyEventSubscriptionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ModifyEventSubscriptionResult{}
	err = c.client.Do("ModifyEventSubscription", "POST", "/", req, resp)
	return
}

// ModifySnapshotCopyRetentionPeriod modifies the number of days to retain
// automated snapshots in the destination region after they are copied from
// the source region.
func (c *RedShift) ModifySnapshotCopyRetentionPeriod(req *ModifySnapshotCopyRetentionPeriodMessage) (resp *ModifySnapshotCopyRetentionPeriodResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ModifySnapshotCopyRetentionPeriodResult{}
	err = c.client.Do("ModifySnapshotCopyRetentionPeriod", "POST", "/", req, resp)
	return
}

// PurchaseReservedNodeOffering allows you to purchase reserved nodes.
// Amazon Redshift offers a predefined set of reserved node offerings. You
// can purchase one of the offerings. You can call the
// DescribeReservedNodeOfferings API to obtain the available reserved node
// offerings. You can call this API by providing a specific reserved node
// offering and the number of nodes you want to reserve. For more
// information about managing parameter groups, go to Purchasing Reserved
// Nodes in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) PurchaseReservedNodeOffering(req *PurchaseReservedNodeOfferingMessage) (resp *PurchaseReservedNodeOfferingResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &PurchaseReservedNodeOfferingResult{}
	err = c.client.Do("PurchaseReservedNodeOffering", "POST", "/", req, resp)
	return
}

// RebootCluster reboots a cluster. This action is taken as soon as
// possible. It results in a momentary outage to the cluster, during which
// the cluster status is set to rebooting . A cluster event is created when
// the reboot is completed. Any pending cluster modifications (see
// ModifyCluster ) are applied at this reboot. For more information about
// managing clusters, go to Amazon Redshift Clusters in the Amazon Redshift
// Cluster Management Guide
func (c *RedShift) RebootCluster(req *RebootClusterMessage) (resp *RebootClusterResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RebootClusterResult{}
	err = c.client.Do("RebootCluster", "POST", "/", req, resp)
	return
}

// ResetClusterParameterGroup sets one or more parameters of the specified
// parameter group to their default values and sets the source values of
// the parameters to "engine-default". To reset the entire parameter group
// specify the ResetAllParameters parameter. For parameter changes to take
// effect you must reboot any associated clusters.
func (c *RedShift) ResetClusterParameterGroup(req *ResetClusterParameterGroupMessage) (resp *ResetClusterParameterGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ResetClusterParameterGroupResult{}
	err = c.client.Do("ResetClusterParameterGroup", "POST", "/", req, resp)
	return
}

// RestoreFromClusterSnapshot creates a new cluster from a snapshot. Amazon
// Redshift creates the resulting cluster with the same configuration as
// the original cluster from which the snapshot was created, except that
// the new cluster is created with the default cluster security and
// parameter group. After Amazon Redshift creates the cluster you can use
// the ModifyCluster API to associate a different security group and
// different parameter group with the restored cluster. If you restore a
// cluster into a you must provide a cluster subnet group where you want
// the cluster restored. For more information about working with snapshots,
// go to Amazon Redshift Snapshots in the Amazon Redshift Cluster
// Management Guide .
func (c *RedShift) RestoreFromClusterSnapshot(req *RestoreFromClusterSnapshotMessage) (resp *RestoreFromClusterSnapshotResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RestoreFromClusterSnapshotResult{}
	err = c.client.Do("RestoreFromClusterSnapshot", "POST", "/", req, resp)
	return
}

// RevokeClusterSecurityGroupIngress revokes an ingress rule in an Amazon
// Redshift security group for a previously authorized IP range or Amazon
// EC2 security group. To add an ingress rule, see
// AuthorizeClusterSecurityGroupIngress . For information about managing
// security groups, go to Amazon Redshift Cluster Security Groups in the
// Amazon Redshift Cluster Management Guide .
func (c *RedShift) RevokeClusterSecurityGroupIngress(req *RevokeClusterSecurityGroupIngressMessage) (resp *RevokeClusterSecurityGroupIngressResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RevokeClusterSecurityGroupIngressResult{}
	err = c.client.Do("RevokeClusterSecurityGroupIngress", "POST", "/", req, resp)
	return
}

// RevokeSnapshotAccess removes the ability of the specified AWS customer
// account to restore the specified snapshot. If the account is currently
// restoring the snapshot, the restore will run to completion. For more
// information about working with snapshots, go to Amazon Redshift
// Snapshots in the Amazon Redshift Cluster Management Guide .
func (c *RedShift) RevokeSnapshotAccess(req *RevokeSnapshotAccessMessage) (resp *RevokeSnapshotAccessResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RevokeSnapshotAccessResult{}
	err = c.client.Do("RevokeSnapshotAccess", "POST", "/", req, resp)
	return
}

// RotateEncryptionKey is undocumented.
func (c *RedShift) RotateEncryptionKey(req *RotateEncryptionKeyMessage) (resp *RotateEncryptionKeyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &RotateEncryptionKeyResult{}
	err = c.client.Do("RotateEncryptionKey", "POST", "/", req, resp)
	return
}

// AccountWithRestoreAccess is undocumented.
type AccountWithRestoreAccess struct {
	AccountID aws.StringValue `xml:"AccountId"`
}

func (v *AccountWithRestoreAccess) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AuthorizeClusterSecurityGroupIngressMessage is undocumented.
type AuthorizeClusterSecurityGroupIngressMessage struct {
	CIDRIP                   aws.StringValue `xml:"CIDRIP"`
	ClusterSecurityGroupName aws.StringValue `xml:"ClusterSecurityGroupName"`
	EC2SecurityGroupName     aws.StringValue `xml:"EC2SecurityGroupName"`
	EC2SecurityGroupOwnerID  aws.StringValue `xml:"EC2SecurityGroupOwnerId"`
}

func (v *AuthorizeClusterSecurityGroupIngressMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSecurityGroupName"); err != nil {
		errors["ClusterSecurityGroupName"] = append(errors["ClusterSecurityGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AuthorizeClusterSecurityGroupIngressResult is undocumented.
type AuthorizeClusterSecurityGroupIngressResult struct {
	ClusterSecurityGroup *ClusterSecurityGroup `xml:"AuthorizeClusterSecurityGroupIngressResult>ClusterSecurityGroup"`
}

func (v *AuthorizeClusterSecurityGroupIngressResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AuthorizeSnapshotAccessMessage is undocumented.
type AuthorizeSnapshotAccessMessage struct {
	AccountWithRestoreAccess  aws.StringValue `xml:"AccountWithRestoreAccess"`
	SnapshotClusterIdentifier aws.StringValue `xml:"SnapshotClusterIdentifier"`
	SnapshotIdentifier        aws.StringValue `xml:"SnapshotIdentifier"`
}

func (v *AuthorizeSnapshotAccessMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccountWithRestoreAccess"); err != nil {
		errors["AccountWithRestoreAccess"] = append(errors["AccountWithRestoreAccess"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotIdentifier"); err != nil {
		errors["SnapshotIdentifier"] = append(errors["SnapshotIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AuthorizeSnapshotAccessResult is undocumented.
type AuthorizeSnapshotAccessResult struct {
	Snapshot *Snapshot `xml:"AuthorizeSnapshotAccessResult>Snapshot"`
}

func (v *AuthorizeSnapshotAccessResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AvailabilityZone is undocumented.
type AvailabilityZone struct {
	Name aws.StringValue `xml:"Name"`
}

func (v *AvailabilityZone) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Cluster is undocumented.
type Cluster struct {
	AllowVersionUpgrade              aws.BooleanValue                 `xml:"AllowVersionUpgrade"`
	AutomatedSnapshotRetentionPeriod aws.IntegerValue                 `xml:"AutomatedSnapshotRetentionPeriod"`
	AvailabilityZone                 aws.StringValue                  `xml:"AvailabilityZone"`
	ClusterCreateTime                time.Time                        `xml:"ClusterCreateTime"`
	ClusterIdentifier                aws.StringValue                  `xml:"ClusterIdentifier"`
	ClusterNodes                     []ClusterNode                    `xml:"ClusterNodes>member"`
	ClusterParameterGroups           []ClusterParameterGroupStatus    `xml:"ClusterParameterGroups>ClusterParameterGroup"`
	ClusterPublicKey                 aws.StringValue                  `xml:"ClusterPublicKey"`
	ClusterRevisionNumber            aws.StringValue                  `xml:"ClusterRevisionNumber"`
	ClusterSecurityGroups            []ClusterSecurityGroupMembership `xml:"ClusterSecurityGroups>ClusterSecurityGroup"`
	ClusterSnapshotCopyStatus        *ClusterSnapshotCopyStatus       `xml:"ClusterSnapshotCopyStatus"`
	ClusterStatus                    aws.StringValue                  `xml:"ClusterStatus"`
	ClusterSubnetGroupName           aws.StringValue                  `xml:"ClusterSubnetGroupName"`
	ClusterVersion                   aws.StringValue                  `xml:"ClusterVersion"`
	DBName                           aws.StringValue                  `xml:"DBName"`
	ElasticIPStatus                  *ElasticIPStatus                 `xml:"ElasticIpStatus"`
	Encrypted                        aws.BooleanValue                 `xml:"Encrypted"`
	Endpoint                         *Endpoint                        `xml:"Endpoint"`
	HSMStatus                        *HSMStatus                       `xml:"HsmStatus"`
	KMSKeyID                         aws.StringValue                  `xml:"KmsKeyId"`
	MasterUsername                   aws.StringValue                  `xml:"MasterUsername"`
	ModifyStatus                     aws.StringValue                  `xml:"ModifyStatus"`
	NodeType                         aws.StringValue                  `xml:"NodeType"`
	NumberOfNodes                    aws.IntegerValue                 `xml:"NumberOfNodes"`
	PendingModifiedValues            *PendingModifiedValues           `xml:"PendingModifiedValues"`
	PreferredMaintenanceWindow       aws.StringValue                  `xml:"PreferredMaintenanceWindow"`
	PubliclyAccessible               aws.BooleanValue                 `xml:"PubliclyAccessible"`
	RestoreStatus                    *RestoreStatus                   `xml:"RestoreStatus"`
	Tags                             []Tag                            `xml:"Tags>Tag"`
	VPCID                            aws.StringValue                  `xml:"VpcId"`
	VPCSecurityGroups                []VPCSecurityGroupMembership     `xml:"VpcSecurityGroups>VpcSecurityGroup"`
}

func (v *Cluster) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterNode is undocumented.
type ClusterNode struct {
	NodeRole         aws.StringValue `xml:"NodeRole"`
	PrivateIPAddress aws.StringValue `xml:"PrivateIPAddress"`
	PublicIPAddress  aws.StringValue `xml:"PublicIPAddress"`
}

func (v *ClusterNode) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterParameterGroup is undocumented.
type ClusterParameterGroup struct {
	Description          aws.StringValue `xml:"Description"`
	ParameterGroupFamily aws.StringValue `xml:"ParameterGroupFamily"`
	ParameterGroupName   aws.StringValue `xml:"ParameterGroupName"`
	Tags                 []Tag           `xml:"Tags>Tag"`
}

func (v *ClusterParameterGroup) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterParameterGroupDetails is undocumented.
type ClusterParameterGroupDetails struct {
	Marker     aws.StringValue `xml:"DescribeClusterParametersResult>Marker"`
	Parameters []Parameter     `xml:"DescribeClusterParametersResult>Parameters>Parameter"`
}

func (v *ClusterParameterGroupDetails) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterParameterGroupNameMessage is undocumented.
type ClusterParameterGroupNameMessage struct {
	ParameterGroupName   aws.StringValue `xml:"ParameterGroupName"`
	ParameterGroupStatus aws.StringValue `xml:"ParameterGroupStatus"`
}

func (v *ClusterParameterGroupNameMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterParameterGroupStatus is undocumented.
type ClusterParameterGroupStatus struct {
	ParameterApplyStatus aws.StringValue `xml:"ParameterApplyStatus"`
	ParameterGroupName   aws.StringValue `xml:"ParameterGroupName"`
}

func (v *ClusterParameterGroupStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterParameterGroupsMessage is undocumented.
type ClusterParameterGroupsMessage struct {
	Marker          aws.StringValue         `xml:"DescribeClusterParameterGroupsResult>Marker"`
	ParameterGroups []ClusterParameterGroup `xml:"DescribeClusterParameterGroupsResult>ParameterGroups>ClusterParameterGroup"`
}

func (v *ClusterParameterGroupsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterSecurityGroup is undocumented.
type ClusterSecurityGroup struct {
	ClusterSecurityGroupName aws.StringValue    `xml:"ClusterSecurityGroupName"`
	Description              aws.StringValue    `xml:"Description"`
	EC2SecurityGroups        []EC2SecurityGroup `xml:"EC2SecurityGroups>EC2SecurityGroup"`
	IPRanges                 []IPRange          `xml:"IPRanges>IPRange"`
	Tags                     []Tag              `xml:"Tags>Tag"`
}

func (v *ClusterSecurityGroup) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterSecurityGroupMembership is undocumented.
type ClusterSecurityGroupMembership struct {
	ClusterSecurityGroupName aws.StringValue `xml:"ClusterSecurityGroupName"`
	Status                   aws.StringValue `xml:"Status"`
}

func (v *ClusterSecurityGroupMembership) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterSecurityGroupMessage is undocumented.
type ClusterSecurityGroupMessage struct {
	ClusterSecurityGroups []ClusterSecurityGroup `xml:"DescribeClusterSecurityGroupsResult>ClusterSecurityGroups>ClusterSecurityGroup"`
	Marker                aws.StringValue        `xml:"DescribeClusterSecurityGroupsResult>Marker"`
}

func (v *ClusterSecurityGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterSnapshotCopyStatus is undocumented.
type ClusterSnapshotCopyStatus struct {
	DestinationRegion aws.StringValue `xml:"DestinationRegion"`
	RetentionPeriod   aws.LongValue   `xml:"RetentionPeriod"`
}

func (v *ClusterSnapshotCopyStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterSubnetGroup is undocumented.
type ClusterSubnetGroup struct {
	ClusterSubnetGroupName aws.StringValue `xml:"ClusterSubnetGroupName"`
	Description            aws.StringValue `xml:"Description"`
	SubnetGroupStatus      aws.StringValue `xml:"SubnetGroupStatus"`
	Subnets                []Subnet        `xml:"Subnets>Subnet"`
	Tags                   []Tag           `xml:"Tags>Tag"`
	VPCID                  aws.StringValue `xml:"VpcId"`
}

func (v *ClusterSubnetGroup) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterSubnetGroupMessage is undocumented.
type ClusterSubnetGroupMessage struct {
	ClusterSubnetGroups []ClusterSubnetGroup `xml:"DescribeClusterSubnetGroupsResult>ClusterSubnetGroups>ClusterSubnetGroup"`
	Marker              aws.StringValue      `xml:"DescribeClusterSubnetGroupsResult>Marker"`
}

func (v *ClusterSubnetGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterVersion is undocumented.
type ClusterVersion struct {
	ClusterParameterGroupFamily aws.StringValue `xml:"ClusterParameterGroupFamily"`
	ClusterVersion              aws.StringValue `xml:"ClusterVersion"`
	Description                 aws.StringValue `xml:"Description"`
}

func (v *ClusterVersion) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClusterVersionsMessage is undocumented.
type ClusterVersionsMessage struct {
	ClusterVersions []ClusterVersion `xml:"DescribeClusterVersionsResult>ClusterVersions>ClusterVersion"`
	Marker          aws.StringValue  `xml:"DescribeClusterVersionsResult>Marker"`
}

func (v *ClusterVersionsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ClustersMessage is undocumented.
type ClustersMessage struct {
	Clusters []Cluster       `xml:"DescribeClustersResult>Clusters>Cluster"`
	Marker   aws.StringValue `xml:"DescribeClustersResult>Marker"`
}

func (v *ClustersMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CopyClusterSnapshotMessage is undocumented.
type CopyClusterSnapshotMessage struct {
	SourceSnapshotClusterIdentifier aws.StringValue `xml:"SourceSnapshotClusterIdentifier"`
	SourceSnapshotIdentifier        aws.StringValue `xml:"SourceSnapshotIdentifier"`
	TargetSnapshotIdentifier        aws.StringValue `xml:"TargetSnapshotIdentifier"`
}

func (v *CopyClusterSnapshotMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SourceSnapshotIdentifier"); err != nil {
		errors["SourceSnapshotIdentifier"] = append(errors["SourceSnapshotIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "TargetSnapshotIdentifier"); err != nil {
		errors["TargetSnapshotIdentifier"] = append(errors["TargetSnapshotIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CopyClusterSnapshotResult is undocumented.
type CopyClusterSnapshotResult struct {
	Snapshot *Snapshot `xml:"CopyClusterSnapshotResult>Snapshot"`
}

func (v *CopyClusterSnapshotResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterMessage is undocumented.
type CreateClusterMessage struct {
	AllowVersionUpgrade              aws.BooleanValue `xml:"AllowVersionUpgrade"`
	AutomatedSnapshotRetentionPeriod aws.IntegerValue `xml:"AutomatedSnapshotRetentionPeriod"`
	AvailabilityZone                 aws.StringValue  `xml:"AvailabilityZone"`
	ClusterIdentifier                aws.StringValue  `xml:"ClusterIdentifier"`
	ClusterParameterGroupName        aws.StringValue  `xml:"ClusterParameterGroupName"`
	ClusterSecurityGroups            []string         `xml:"ClusterSecurityGroups>ClusterSecurityGroupName"`
	ClusterSubnetGroupName           aws.StringValue  `xml:"ClusterSubnetGroupName"`
	ClusterType                      aws.StringValue  `xml:"ClusterType"`
	ClusterVersion                   aws.StringValue  `xml:"ClusterVersion"`
	DBName                           aws.StringValue  `xml:"DBName"`
	ElasticIP                        aws.StringValue  `xml:"ElasticIp"`
	Encrypted                        aws.BooleanValue `xml:"Encrypted"`
	HSMClientCertificateIdentifier   aws.StringValue  `xml:"HsmClientCertificateIdentifier"`
	HSMConfigurationIdentifier       aws.StringValue  `xml:"HsmConfigurationIdentifier"`
	KMSKeyID                         aws.StringValue  `xml:"KmsKeyId"`
	MasterUserPassword               aws.StringValue  `xml:"MasterUserPassword"`
	MasterUsername                   aws.StringValue  `xml:"MasterUsername"`
	NodeType                         aws.StringValue  `xml:"NodeType"`
	NumberOfNodes                    aws.IntegerValue `xml:"NumberOfNodes"`
	Port                             aws.IntegerValue `xml:"Port"`
	PreferredMaintenanceWindow       aws.StringValue  `xml:"PreferredMaintenanceWindow"`
	PubliclyAccessible               aws.BooleanValue `xml:"PubliclyAccessible"`
	Tags                             []Tag            `xml:"Tags>Tag"`
	VPCSecurityGroupIDs              []string         `xml:"VpcSecurityGroupIds>VpcSecurityGroupId"`
}

func (v *CreateClusterMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "MasterUserPassword"); err != nil {
		errors["MasterUserPassword"] = append(errors["MasterUserPassword"], err)
	}

	if err := model.ValidateRequired(v, "MasterUsername"); err != nil {
		errors["MasterUsername"] = append(errors["MasterUsername"], err)
	}

	if err := model.ValidateRequired(v, "NodeType"); err != nil {
		errors["NodeType"] = append(errors["NodeType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterParameterGroupMessage is undocumented.
type CreateClusterParameterGroupMessage struct {
	Description          aws.StringValue `xml:"Description"`
	ParameterGroupFamily aws.StringValue `xml:"ParameterGroupFamily"`
	ParameterGroupName   aws.StringValue `xml:"ParameterGroupName"`
	Tags                 []Tag           `xml:"Tags>Tag"`
}

func (v *CreateClusterParameterGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Description"); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "ParameterGroupFamily"); err != nil {
		errors["ParameterGroupFamily"] = append(errors["ParameterGroupFamily"], err)
	}

	if err := model.ValidateRequired(v, "ParameterGroupName"); err != nil {
		errors["ParameterGroupName"] = append(errors["ParameterGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterParameterGroupResult is undocumented.
type CreateClusterParameterGroupResult struct {
	ClusterParameterGroup *ClusterParameterGroup `xml:"CreateClusterParameterGroupResult>ClusterParameterGroup"`
}

func (v *CreateClusterParameterGroupResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterResult is undocumented.
type CreateClusterResult struct {
	Cluster *Cluster `xml:"CreateClusterResult>Cluster"`
}

func (v *CreateClusterResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterSecurityGroupMessage is undocumented.
type CreateClusterSecurityGroupMessage struct {
	ClusterSecurityGroupName aws.StringValue `xml:"ClusterSecurityGroupName"`
	Description              aws.StringValue `xml:"Description"`
	Tags                     []Tag           `xml:"Tags>Tag"`
}

func (v *CreateClusterSecurityGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSecurityGroupName"); err != nil {
		errors["ClusterSecurityGroupName"] = append(errors["ClusterSecurityGroupName"], err)
	}

	if err := model.ValidateRequired(v, "Description"); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterSecurityGroupResult is undocumented.
type CreateClusterSecurityGroupResult struct {
	ClusterSecurityGroup *ClusterSecurityGroup `xml:"CreateClusterSecurityGroupResult>ClusterSecurityGroup"`
}

func (v *CreateClusterSecurityGroupResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterSnapshotMessage is undocumented.
type CreateClusterSnapshotMessage struct {
	ClusterIdentifier  aws.StringValue `xml:"ClusterIdentifier"`
	SnapshotIdentifier aws.StringValue `xml:"SnapshotIdentifier"`
	Tags               []Tag           `xml:"Tags>Tag"`
}

func (v *CreateClusterSnapshotMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotIdentifier"); err != nil {
		errors["SnapshotIdentifier"] = append(errors["SnapshotIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterSnapshotResult is undocumented.
type CreateClusterSnapshotResult struct {
	Snapshot *Snapshot `xml:"CreateClusterSnapshotResult>Snapshot"`
}

func (v *CreateClusterSnapshotResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterSubnetGroupMessage is undocumented.
type CreateClusterSubnetGroupMessage struct {
	ClusterSubnetGroupName aws.StringValue `xml:"ClusterSubnetGroupName"`
	Description            aws.StringValue `xml:"Description"`
	SubnetIDs              []string        `xml:"SubnetIds>SubnetIdentifier"`
	Tags                   []Tag           `xml:"Tags>Tag"`
}

func (v *CreateClusterSubnetGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSubnetGroupName"); err != nil {
		errors["ClusterSubnetGroupName"] = append(errors["ClusterSubnetGroupName"], err)
	}

	if err := model.ValidateRequired(v, "Description"); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "SubnetIDs"); err != nil {
		errors["SubnetIDs"] = append(errors["SubnetIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateClusterSubnetGroupResult is undocumented.
type CreateClusterSubnetGroupResult struct {
	ClusterSubnetGroup *ClusterSubnetGroup `xml:"CreateClusterSubnetGroupResult>ClusterSubnetGroup"`
}

func (v *CreateClusterSubnetGroupResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateEventSubscriptionMessage is undocumented.
type CreateEventSubscriptionMessage struct {
	Enabled          aws.BooleanValue `xml:"Enabled"`
	EventCategories  []string         `xml:"EventCategories>EventCategory"`
	Severity         aws.StringValue  `xml:"Severity"`
	SNSTopicARN      aws.StringValue  `xml:"SnsTopicArn"`
	SourceIDs        []string         `xml:"SourceIds>SourceId"`
	SourceType       aws.StringValue  `xml:"SourceType"`
	SubscriptionName aws.StringValue  `xml:"SubscriptionName"`
	Tags             []Tag            `xml:"Tags>Tag"`
}

func (v *CreateEventSubscriptionMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SNSTopicARN"); err != nil {
		errors["SNSTopicARN"] = append(errors["SNSTopicARN"], err)
	}

	if err := model.ValidateRequired(v, "SubscriptionName"); err != nil {
		errors["SubscriptionName"] = append(errors["SubscriptionName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateEventSubscriptionResult is undocumented.
type CreateEventSubscriptionResult struct {
	EventSubscription *EventSubscription `xml:"CreateEventSubscriptionResult>EventSubscription"`
}

func (v *CreateEventSubscriptionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateHSMClientCertificateMessage is undocumented.
type CreateHSMClientCertificateMessage struct {
	HSMClientCertificateIdentifier aws.StringValue `xml:"HsmClientCertificateIdentifier"`
	Tags                           []Tag           `xml:"Tags>Tag"`
}

func (v *CreateHSMClientCertificateMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "HSMClientCertificateIdentifier"); err != nil {
		errors["HSMClientCertificateIdentifier"] = append(errors["HSMClientCertificateIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateHSMClientCertificateResult is undocumented.
type CreateHSMClientCertificateResult struct {
	HSMClientCertificate *HSMClientCertificate `xml:"CreateHsmClientCertificateResult>HsmClientCertificate"`
}

func (v *CreateHSMClientCertificateResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateHSMConfigurationMessage is undocumented.
type CreateHSMConfigurationMessage struct {
	Description                aws.StringValue `xml:"Description"`
	HSMConfigurationIdentifier aws.StringValue `xml:"HsmConfigurationIdentifier"`
	HSMIPAddress               aws.StringValue `xml:"HsmIpAddress"`
	HSMPartitionName           aws.StringValue `xml:"HsmPartitionName"`
	HSMPartitionPassword       aws.StringValue `xml:"HsmPartitionPassword"`
	HSMServerPublicCertificate aws.StringValue `xml:"HsmServerPublicCertificate"`
	Tags                       []Tag           `xml:"Tags>Tag"`
}

func (v *CreateHSMConfigurationMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Description"); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "HSMConfigurationIdentifier"); err != nil {
		errors["HSMConfigurationIdentifier"] = append(errors["HSMConfigurationIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "HSMIPAddress"); err != nil {
		errors["HSMIPAddress"] = append(errors["HSMIPAddress"], err)
	}

	if err := model.ValidateRequired(v, "HSMPartitionName"); err != nil {
		errors["HSMPartitionName"] = append(errors["HSMPartitionName"], err)
	}

	if err := model.ValidateRequired(v, "HSMPartitionPassword"); err != nil {
		errors["HSMPartitionPassword"] = append(errors["HSMPartitionPassword"], err)
	}

	if err := model.ValidateRequired(v, "HSMServerPublicCertificate"); err != nil {
		errors["HSMServerPublicCertificate"] = append(errors["HSMServerPublicCertificate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateHSMConfigurationResult is undocumented.
type CreateHSMConfigurationResult struct {
	HSMConfiguration *HSMConfiguration `xml:"CreateHsmConfigurationResult>HsmConfiguration"`
}

func (v *CreateHSMConfigurationResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateTagsMessage is undocumented.
type CreateTagsMessage struct {
	ResourceName aws.StringValue `xml:"ResourceName"`
	Tags         []Tag           `xml:"Tags>Tag"`
}

func (v *CreateTagsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ResourceName"); err != nil {
		errors["ResourceName"] = append(errors["ResourceName"], err)
	}

	if err := model.ValidateRequired(v, "Tags"); err != nil {
		errors["Tags"] = append(errors["Tags"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefaultClusterParameters is undocumented.
type DefaultClusterParameters struct {
	Marker               aws.StringValue `xml:"Marker"`
	ParameterGroupFamily aws.StringValue `xml:"ParameterGroupFamily"`
	Parameters           []Parameter     `xml:"Parameters>Parameter"`
}

func (v *DefaultClusterParameters) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterMessage is undocumented.
type DeleteClusterMessage struct {
	ClusterIdentifier              aws.StringValue  `xml:"ClusterIdentifier"`
	FinalClusterSnapshotIdentifier aws.StringValue  `xml:"FinalClusterSnapshotIdentifier"`
	SkipFinalClusterSnapshot       aws.BooleanValue `xml:"SkipFinalClusterSnapshot"`
}

func (v *DeleteClusterMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterParameterGroupMessage is undocumented.
type DeleteClusterParameterGroupMessage struct {
	ParameterGroupName aws.StringValue `xml:"ParameterGroupName"`
}

func (v *DeleteClusterParameterGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ParameterGroupName"); err != nil {
		errors["ParameterGroupName"] = append(errors["ParameterGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterResult is undocumented.
type DeleteClusterResult struct {
	Cluster *Cluster `xml:"DeleteClusterResult>Cluster"`
}

func (v *DeleteClusterResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterSecurityGroupMessage is undocumented.
type DeleteClusterSecurityGroupMessage struct {
	ClusterSecurityGroupName aws.StringValue `xml:"ClusterSecurityGroupName"`
}

func (v *DeleteClusterSecurityGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSecurityGroupName"); err != nil {
		errors["ClusterSecurityGroupName"] = append(errors["ClusterSecurityGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterSnapshotMessage is undocumented.
type DeleteClusterSnapshotMessage struct {
	SnapshotClusterIdentifier aws.StringValue `xml:"SnapshotClusterIdentifier"`
	SnapshotIdentifier        aws.StringValue `xml:"SnapshotIdentifier"`
}

func (v *DeleteClusterSnapshotMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SnapshotIdentifier"); err != nil {
		errors["SnapshotIdentifier"] = append(errors["SnapshotIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterSnapshotResult is undocumented.
type DeleteClusterSnapshotResult struct {
	Snapshot *Snapshot `xml:"DeleteClusterSnapshotResult>Snapshot"`
}

func (v *DeleteClusterSnapshotResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteClusterSubnetGroupMessage is undocumented.
type DeleteClusterSubnetGroupMessage struct {
	ClusterSubnetGroupName aws.StringValue `xml:"ClusterSubnetGroupName"`
}

func (v *DeleteClusterSubnetGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSubnetGroupName"); err != nil {
		errors["ClusterSubnetGroupName"] = append(errors["ClusterSubnetGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteEventSubscriptionMessage is undocumented.
type DeleteEventSubscriptionMessage struct {
	SubscriptionName aws.StringValue `xml:"SubscriptionName"`
}

func (v *DeleteEventSubscriptionMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SubscriptionName"); err != nil {
		errors["SubscriptionName"] = append(errors["SubscriptionName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteHSMClientCertificateMessage is undocumented.
type DeleteHSMClientCertificateMessage struct {
	HSMClientCertificateIdentifier aws.StringValue `xml:"HsmClientCertificateIdentifier"`
}

func (v *DeleteHSMClientCertificateMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "HSMClientCertificateIdentifier"); err != nil {
		errors["HSMClientCertificateIdentifier"] = append(errors["HSMClientCertificateIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteHSMConfigurationMessage is undocumented.
type DeleteHSMConfigurationMessage struct {
	HSMConfigurationIdentifier aws.StringValue `xml:"HsmConfigurationIdentifier"`
}

func (v *DeleteHSMConfigurationMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "HSMConfigurationIdentifier"); err != nil {
		errors["HSMConfigurationIdentifier"] = append(errors["HSMConfigurationIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteTagsMessage is undocumented.
type DeleteTagsMessage struct {
	ResourceName aws.StringValue `xml:"ResourceName"`
	TagKeys      []string        `xml:"TagKeys>TagKey"`
}

func (v *DeleteTagsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ResourceName"); err != nil {
		errors["ResourceName"] = append(errors["ResourceName"], err)
	}

	if err := model.ValidateRequired(v, "TagKeys"); err != nil {
		errors["TagKeys"] = append(errors["TagKeys"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterParameterGroupsMessage is undocumented.
type DescribeClusterParameterGroupsMessage struct {
	Marker             aws.StringValue  `xml:"Marker"`
	MaxRecords         aws.IntegerValue `xml:"MaxRecords"`
	ParameterGroupName aws.StringValue  `xml:"ParameterGroupName"`
	TagKeys            []string         `xml:"TagKeys>TagKey"`
	TagValues          []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeClusterParameterGroupsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterParametersMessage is undocumented.
type DescribeClusterParametersMessage struct {
	Marker             aws.StringValue  `xml:"Marker"`
	MaxRecords         aws.IntegerValue `xml:"MaxRecords"`
	ParameterGroupName aws.StringValue  `xml:"ParameterGroupName"`
	Source             aws.StringValue  `xml:"Source"`
}

func (v *DescribeClusterParametersMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ParameterGroupName"); err != nil {
		errors["ParameterGroupName"] = append(errors["ParameterGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterSecurityGroupsMessage is undocumented.
type DescribeClusterSecurityGroupsMessage struct {
	ClusterSecurityGroupName aws.StringValue  `xml:"ClusterSecurityGroupName"`
	Marker                   aws.StringValue  `xml:"Marker"`
	MaxRecords               aws.IntegerValue `xml:"MaxRecords"`
	TagKeys                  []string         `xml:"TagKeys>TagKey"`
	TagValues                []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeClusterSecurityGroupsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterSnapshotsMessage is undocumented.
type DescribeClusterSnapshotsMessage struct {
	ClusterIdentifier  aws.StringValue  `xml:"ClusterIdentifier"`
	EndTime            time.Time        `xml:"EndTime"`
	Marker             aws.StringValue  `xml:"Marker"`
	MaxRecords         aws.IntegerValue `xml:"MaxRecords"`
	OwnerAccount       aws.StringValue  `xml:"OwnerAccount"`
	SnapshotIdentifier aws.StringValue  `xml:"SnapshotIdentifier"`
	SnapshotType       aws.StringValue  `xml:"SnapshotType"`
	StartTime          time.Time        `xml:"StartTime"`
	TagKeys            []string         `xml:"TagKeys>TagKey"`
	TagValues          []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeClusterSnapshotsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterSubnetGroupsMessage is undocumented.
type DescribeClusterSubnetGroupsMessage struct {
	ClusterSubnetGroupName aws.StringValue  `xml:"ClusterSubnetGroupName"`
	Marker                 aws.StringValue  `xml:"Marker"`
	MaxRecords             aws.IntegerValue `xml:"MaxRecords"`
	TagKeys                []string         `xml:"TagKeys>TagKey"`
	TagValues              []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeClusterSubnetGroupsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterVersionsMessage is undocumented.
type DescribeClusterVersionsMessage struct {
	ClusterParameterGroupFamily aws.StringValue  `xml:"ClusterParameterGroupFamily"`
	ClusterVersion              aws.StringValue  `xml:"ClusterVersion"`
	Marker                      aws.StringValue  `xml:"Marker"`
	MaxRecords                  aws.IntegerValue `xml:"MaxRecords"`
}

func (v *DescribeClusterVersionsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClustersMessage is undocumented.
type DescribeClustersMessage struct {
	ClusterIdentifier aws.StringValue  `xml:"ClusterIdentifier"`
	Marker            aws.StringValue  `xml:"Marker"`
	MaxRecords        aws.IntegerValue `xml:"MaxRecords"`
	TagKeys           []string         `xml:"TagKeys>TagKey"`
	TagValues         []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeClustersMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDefaultClusterParametersMessage is undocumented.
type DescribeDefaultClusterParametersMessage struct {
	Marker               aws.StringValue  `xml:"Marker"`
	MaxRecords           aws.IntegerValue `xml:"MaxRecords"`
	ParameterGroupFamily aws.StringValue  `xml:"ParameterGroupFamily"`
}

func (v *DescribeDefaultClusterParametersMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ParameterGroupFamily"); err != nil {
		errors["ParameterGroupFamily"] = append(errors["ParameterGroupFamily"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDefaultClusterParametersResult is undocumented.
type DescribeDefaultClusterParametersResult struct {
	DefaultClusterParameters *DefaultClusterParameters `xml:"DescribeDefaultClusterParametersResult>DefaultClusterParameters"`
}

func (v *DescribeDefaultClusterParametersResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeEventCategoriesMessage is undocumented.
type DescribeEventCategoriesMessage struct {
	SourceType aws.StringValue `xml:"SourceType"`
}

func (v *DescribeEventCategoriesMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeEventSubscriptionsMessage is undocumented.
type DescribeEventSubscriptionsMessage struct {
	Marker           aws.StringValue  `xml:"Marker"`
	MaxRecords       aws.IntegerValue `xml:"MaxRecords"`
	SubscriptionName aws.StringValue  `xml:"SubscriptionName"`
}

func (v *DescribeEventSubscriptionsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeEventsMessage is undocumented.
type DescribeEventsMessage struct {
	Duration         aws.IntegerValue `xml:"Duration"`
	EndTime          time.Time        `xml:"EndTime"`
	Marker           aws.StringValue  `xml:"Marker"`
	MaxRecords       aws.IntegerValue `xml:"MaxRecords"`
	SourceIdentifier aws.StringValue  `xml:"SourceIdentifier"`
	SourceType       aws.StringValue  `xml:"SourceType"`
	StartTime        time.Time        `xml:"StartTime"`
}

func (v *DescribeEventsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	SourceTypeEnum := []string{
		SourceTypeCluster,
		SourceTypeClusterParameterGroup,
		SourceTypeClusterSecurityGroup,
		SourceTypeClusterSnapshot,
	}
	if err := model.ValidateEnum(v, "SourceType", SourceTypeEnum); err != nil {
		errors["SourceType"] = append(errors["SourceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeHSMClientCertificatesMessage is undocumented.
type DescribeHSMClientCertificatesMessage struct {
	HSMClientCertificateIdentifier aws.StringValue  `xml:"HsmClientCertificateIdentifier"`
	Marker                         aws.StringValue  `xml:"Marker"`
	MaxRecords                     aws.IntegerValue `xml:"MaxRecords"`
	TagKeys                        []string         `xml:"TagKeys>TagKey"`
	TagValues                      []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeHSMClientCertificatesMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeHSMConfigurationsMessage is undocumented.
type DescribeHSMConfigurationsMessage struct {
	HSMConfigurationIdentifier aws.StringValue  `xml:"HsmConfigurationIdentifier"`
	Marker                     aws.StringValue  `xml:"Marker"`
	MaxRecords                 aws.IntegerValue `xml:"MaxRecords"`
	TagKeys                    []string         `xml:"TagKeys>TagKey"`
	TagValues                  []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeHSMConfigurationsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeLoggingStatusMessage is undocumented.
type DescribeLoggingStatusMessage struct {
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
}

func (v *DescribeLoggingStatusMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeOrderableClusterOptionsMessage is undocumented.
type DescribeOrderableClusterOptionsMessage struct {
	ClusterVersion aws.StringValue  `xml:"ClusterVersion"`
	Marker         aws.StringValue  `xml:"Marker"`
	MaxRecords     aws.IntegerValue `xml:"MaxRecords"`
	NodeType       aws.StringValue  `xml:"NodeType"`
}

func (v *DescribeOrderableClusterOptionsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedNodeOfferingsMessage is undocumented.
type DescribeReservedNodeOfferingsMessage struct {
	Marker                 aws.StringValue  `xml:"Marker"`
	MaxRecords             aws.IntegerValue `xml:"MaxRecords"`
	ReservedNodeOfferingID aws.StringValue  `xml:"ReservedNodeOfferingId"`
}

func (v *DescribeReservedNodeOfferingsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeReservedNodesMessage is undocumented.
type DescribeReservedNodesMessage struct {
	Marker         aws.StringValue  `xml:"Marker"`
	MaxRecords     aws.IntegerValue `xml:"MaxRecords"`
	ReservedNodeID aws.StringValue  `xml:"ReservedNodeId"`
}

func (v *DescribeReservedNodesMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeResizeMessage is undocumented.
type DescribeResizeMessage struct {
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
}

func (v *DescribeResizeMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeTagsMessage is undocumented.
type DescribeTagsMessage struct {
	Marker       aws.StringValue  `xml:"Marker"`
	MaxRecords   aws.IntegerValue `xml:"MaxRecords"`
	ResourceName aws.StringValue  `xml:"ResourceName"`
	ResourceType aws.StringValue  `xml:"ResourceType"`
	TagKeys      []string         `xml:"TagKeys>TagKey"`
	TagValues    []string         `xml:"TagValues>TagValue"`
}

func (v *DescribeTagsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisableLoggingMessage is undocumented.
type DisableLoggingMessage struct {
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
}

func (v *DisableLoggingMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisableSnapshotCopyMessage is undocumented.
type DisableSnapshotCopyMessage struct {
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
}

func (v *DisableSnapshotCopyMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DisableSnapshotCopyResult is undocumented.
type DisableSnapshotCopyResult struct {
	Cluster *Cluster `xml:"DisableSnapshotCopyResult>Cluster"`
}

func (v *DisableSnapshotCopyResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EC2SecurityGroup is undocumented.
type EC2SecurityGroup struct {
	EC2SecurityGroupName    aws.StringValue `xml:"EC2SecurityGroupName"`
	EC2SecurityGroupOwnerID aws.StringValue `xml:"EC2SecurityGroupOwnerId"`
	Status                  aws.StringValue `xml:"Status"`
	Tags                    []Tag           `xml:"Tags>Tag"`
}

func (v *EC2SecurityGroup) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ElasticIPStatus is undocumented.
type ElasticIPStatus struct {
	ElasticIP aws.StringValue `xml:"ElasticIp"`
	Status    aws.StringValue `xml:"Status"`
}

func (v *ElasticIPStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EnableLoggingMessage is undocumented.
type EnableLoggingMessage struct {
	BucketName        aws.StringValue `xml:"BucketName"`
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
	S3KeyPrefix       aws.StringValue `xml:"S3KeyPrefix"`
}

func (v *EnableLoggingMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "BucketName"); err != nil {
		errors["BucketName"] = append(errors["BucketName"], err)
	}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EnableSnapshotCopyMessage is undocumented.
type EnableSnapshotCopyMessage struct {
	ClusterIdentifier aws.StringValue  `xml:"ClusterIdentifier"`
	DestinationRegion aws.StringValue  `xml:"DestinationRegion"`
	RetentionPeriod   aws.IntegerValue `xml:"RetentionPeriod"`
}

func (v *EnableSnapshotCopyMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "DestinationRegion"); err != nil {
		errors["DestinationRegion"] = append(errors["DestinationRegion"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EnableSnapshotCopyResult is undocumented.
type EnableSnapshotCopyResult struct {
	Cluster *Cluster `xml:"EnableSnapshotCopyResult>Cluster"`
}

func (v *EnableSnapshotCopyResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Endpoint is undocumented.
type Endpoint struct {
	Address aws.StringValue  `xml:"Address"`
	Port    aws.IntegerValue `xml:"Port"`
}

func (v *Endpoint) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Event is undocumented.
type Event struct {
	Date             time.Time       `xml:"Date"`
	EventCategories  []string        `xml:"EventCategories>EventCategory"`
	EventID          aws.StringValue `xml:"EventId"`
	Message          aws.StringValue `xml:"Message"`
	Severity         aws.StringValue `xml:"Severity"`
	SourceIdentifier aws.StringValue `xml:"SourceIdentifier"`
	SourceType       aws.StringValue `xml:"SourceType"`
}

func (v *Event) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	SourceTypeEnum := []string{
		SourceTypeCluster,
		SourceTypeClusterParameterGroup,
		SourceTypeClusterSecurityGroup,
		SourceTypeClusterSnapshot,
	}
	if err := model.ValidateEnum(v, "SourceType", SourceTypeEnum); err != nil {
		errors["SourceType"] = append(errors["SourceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EventCategoriesMap is undocumented.
type EventCategoriesMap struct {
	Events     []EventInfoMap  `xml:"Events>EventInfoMap"`
	SourceType aws.StringValue `xml:"SourceType"`
}

func (v *EventCategoriesMap) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EventCategoriesMessage is undocumented.
type EventCategoriesMessage struct {
	EventCategoriesMapList []EventCategoriesMap `xml:"DescribeEventCategoriesResult>EventCategoriesMapList>EventCategoriesMap"`
}

func (v *EventCategoriesMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EventInfoMap is undocumented.
type EventInfoMap struct {
	EventCategories  []string        `xml:"EventCategories>EventCategory"`
	EventDescription aws.StringValue `xml:"EventDescription"`
	EventID          aws.StringValue `xml:"EventId"`
	Severity         aws.StringValue `xml:"Severity"`
}

func (v *EventInfoMap) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EventSubscription is undocumented.
type EventSubscription struct {
	CustSubscriptionID       aws.StringValue  `xml:"CustSubscriptionId"`
	CustomerAWSID            aws.StringValue  `xml:"CustomerAwsId"`
	Enabled                  aws.BooleanValue `xml:"Enabled"`
	EventCategoriesList      []string         `xml:"EventCategoriesList>EventCategory"`
	Severity                 aws.StringValue  `xml:"Severity"`
	SNSTopicARN              aws.StringValue  `xml:"SnsTopicArn"`
	SourceIDsList            []string         `xml:"SourceIdsList>SourceId"`
	SourceType               aws.StringValue  `xml:"SourceType"`
	Status                   aws.StringValue  `xml:"Status"`
	SubscriptionCreationTime time.Time        `xml:"SubscriptionCreationTime"`
	Tags                     []Tag            `xml:"Tags>Tag"`
}

func (v *EventSubscription) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EventSubscriptionsMessage is undocumented.
type EventSubscriptionsMessage struct {
	EventSubscriptionsList []EventSubscription `xml:"DescribeEventSubscriptionsResult>EventSubscriptionsList>EventSubscription"`
	Marker                 aws.StringValue     `xml:"DescribeEventSubscriptionsResult>Marker"`
}

func (v *EventSubscriptionsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EventsMessage is undocumented.
type EventsMessage struct {
	Events []Event         `xml:"DescribeEventsResult>Events>Event"`
	Marker aws.StringValue `xml:"DescribeEventsResult>Marker"`
}

func (v *EventsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// HSMClientCertificate is undocumented.
type HSMClientCertificate struct {
	HSMClientCertificateIdentifier aws.StringValue `xml:"HsmClientCertificateIdentifier"`
	HSMClientCertificatePublicKey  aws.StringValue `xml:"HsmClientCertificatePublicKey"`
	Tags                           []Tag           `xml:"Tags>Tag"`
}

func (v *HSMClientCertificate) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// HSMClientCertificateMessage is undocumented.
type HSMClientCertificateMessage struct {
	HSMClientCertificates []HSMClientCertificate `xml:"DescribeHsmClientCertificatesResult>HsmClientCertificates>HsmClientCertificate"`
	Marker                aws.StringValue        `xml:"DescribeHsmClientCertificatesResult>Marker"`
}

func (v *HSMClientCertificateMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// HSMConfiguration is undocumented.
type HSMConfiguration struct {
	Description                aws.StringValue `xml:"Description"`
	HSMConfigurationIdentifier aws.StringValue `xml:"HsmConfigurationIdentifier"`
	HSMIPAddress               aws.StringValue `xml:"HsmIpAddress"`
	HSMPartitionName           aws.StringValue `xml:"HsmPartitionName"`
	Tags                       []Tag           `xml:"Tags>Tag"`
}

func (v *HSMConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// HSMConfigurationMessage is undocumented.
type HSMConfigurationMessage struct {
	HSMConfigurations []HSMConfiguration `xml:"DescribeHsmConfigurationsResult>HsmConfigurations>HsmConfiguration"`
	Marker            aws.StringValue    `xml:"DescribeHsmConfigurationsResult>Marker"`
}

func (v *HSMConfigurationMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// HSMStatus is undocumented.
type HSMStatus struct {
	HSMClientCertificateIdentifier aws.StringValue `xml:"HsmClientCertificateIdentifier"`
	HSMConfigurationIdentifier     aws.StringValue `xml:"HsmConfigurationIdentifier"`
	Status                         aws.StringValue `xml:"Status"`
}

func (v *HSMStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IPRange is undocumented.
type IPRange struct {
	CIDRIP aws.StringValue `xml:"CIDRIP"`
	Status aws.StringValue `xml:"Status"`
	Tags   []Tag           `xml:"Tags>Tag"`
}

func (v *IPRange) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LoggingStatus is undocumented.
type LoggingStatus struct {
	BucketName                 aws.StringValue  `xml:"BucketName"`
	LastFailureMessage         aws.StringValue  `xml:"LastFailureMessage"`
	LastFailureTime            time.Time        `xml:"LastFailureTime"`
	LastSuccessfulDeliveryTime time.Time        `xml:"LastSuccessfulDeliveryTime"`
	LoggingEnabled             aws.BooleanValue `xml:"LoggingEnabled"`
	S3KeyPrefix                aws.StringValue  `xml:"S3KeyPrefix"`
}

func (v *LoggingStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyClusterMessage is undocumented.
type ModifyClusterMessage struct {
	AllowVersionUpgrade              aws.BooleanValue `xml:"AllowVersionUpgrade"`
	AutomatedSnapshotRetentionPeriod aws.IntegerValue `xml:"AutomatedSnapshotRetentionPeriod"`
	ClusterIdentifier                aws.StringValue  `xml:"ClusterIdentifier"`
	ClusterParameterGroupName        aws.StringValue  `xml:"ClusterParameterGroupName"`
	ClusterSecurityGroups            []string         `xml:"ClusterSecurityGroups>ClusterSecurityGroupName"`
	ClusterType                      aws.StringValue  `xml:"ClusterType"`
	ClusterVersion                   aws.StringValue  `xml:"ClusterVersion"`
	HSMClientCertificateIdentifier   aws.StringValue  `xml:"HsmClientCertificateIdentifier"`
	HSMConfigurationIdentifier       aws.StringValue  `xml:"HsmConfigurationIdentifier"`
	MasterUserPassword               aws.StringValue  `xml:"MasterUserPassword"`
	NewClusterIdentifier             aws.StringValue  `xml:"NewClusterIdentifier"`
	NodeType                         aws.StringValue  `xml:"NodeType"`
	NumberOfNodes                    aws.IntegerValue `xml:"NumberOfNodes"`
	PreferredMaintenanceWindow       aws.StringValue  `xml:"PreferredMaintenanceWindow"`
	VPCSecurityGroupIDs              []string         `xml:"VpcSecurityGroupIds>VpcSecurityGroupId"`
}

func (v *ModifyClusterMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyClusterParameterGroupMessage is undocumented.
type ModifyClusterParameterGroupMessage struct {
	ParameterGroupName aws.StringValue `xml:"ParameterGroupName"`
	Parameters         []Parameter     `xml:"Parameters>Parameter"`
}

func (v *ModifyClusterParameterGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ParameterGroupName"); err != nil {
		errors["ParameterGroupName"] = append(errors["ParameterGroupName"], err)
	}

	if err := model.ValidateRequired(v, "Parameters"); err != nil {
		errors["Parameters"] = append(errors["Parameters"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyClusterResult is undocumented.
type ModifyClusterResult struct {
	Cluster *Cluster `xml:"ModifyClusterResult>Cluster"`
}

func (v *ModifyClusterResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyClusterSubnetGroupMessage is undocumented.
type ModifyClusterSubnetGroupMessage struct {
	ClusterSubnetGroupName aws.StringValue `xml:"ClusterSubnetGroupName"`
	Description            aws.StringValue `xml:"Description"`
	SubnetIDs              []string        `xml:"SubnetIds>SubnetIdentifier"`
}

func (v *ModifyClusterSubnetGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSubnetGroupName"); err != nil {
		errors["ClusterSubnetGroupName"] = append(errors["ClusterSubnetGroupName"], err)
	}

	if err := model.ValidateRequired(v, "SubnetIDs"); err != nil {
		errors["SubnetIDs"] = append(errors["SubnetIDs"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyClusterSubnetGroupResult is undocumented.
type ModifyClusterSubnetGroupResult struct {
	ClusterSubnetGroup *ClusterSubnetGroup `xml:"ModifyClusterSubnetGroupResult>ClusterSubnetGroup"`
}

func (v *ModifyClusterSubnetGroupResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyEventSubscriptionMessage is undocumented.
type ModifyEventSubscriptionMessage struct {
	Enabled          aws.BooleanValue `xml:"Enabled"`
	EventCategories  []string         `xml:"EventCategories>EventCategory"`
	Severity         aws.StringValue  `xml:"Severity"`
	SNSTopicARN      aws.StringValue  `xml:"SnsTopicArn"`
	SourceIDs        []string         `xml:"SourceIds>SourceId"`
	SourceType       aws.StringValue  `xml:"SourceType"`
	SubscriptionName aws.StringValue  `xml:"SubscriptionName"`
}

func (v *ModifyEventSubscriptionMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SubscriptionName"); err != nil {
		errors["SubscriptionName"] = append(errors["SubscriptionName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifyEventSubscriptionResult is undocumented.
type ModifyEventSubscriptionResult struct {
	EventSubscription *EventSubscription `xml:"ModifyEventSubscriptionResult>EventSubscription"`
}

func (v *ModifyEventSubscriptionResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifySnapshotCopyRetentionPeriodMessage is undocumented.
type ModifySnapshotCopyRetentionPeriodMessage struct {
	ClusterIdentifier aws.StringValue  `xml:"ClusterIdentifier"`
	RetentionPeriod   aws.IntegerValue `xml:"RetentionPeriod"`
}

func (v *ModifySnapshotCopyRetentionPeriodMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "RetentionPeriod"); err != nil {
		errors["RetentionPeriod"] = append(errors["RetentionPeriod"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ModifySnapshotCopyRetentionPeriodResult is undocumented.
type ModifySnapshotCopyRetentionPeriodResult struct {
	Cluster *Cluster `xml:"ModifySnapshotCopyRetentionPeriodResult>Cluster"`
}

func (v *ModifySnapshotCopyRetentionPeriodResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// OrderableClusterOption is undocumented.
type OrderableClusterOption struct {
	AvailabilityZones []AvailabilityZone `xml:"AvailabilityZones>AvailabilityZone"`
	ClusterType       aws.StringValue    `xml:"ClusterType"`
	ClusterVersion    aws.StringValue    `xml:"ClusterVersion"`
	NodeType          aws.StringValue    `xml:"NodeType"`
}

func (v *OrderableClusterOption) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// OrderableClusterOptionsMessage is undocumented.
type OrderableClusterOptionsMessage struct {
	Marker                  aws.StringValue          `xml:"DescribeOrderableClusterOptionsResult>Marker"`
	OrderableClusterOptions []OrderableClusterOption `xml:"DescribeOrderableClusterOptionsResult>OrderableClusterOptions>OrderableClusterOption"`
}

func (v *OrderableClusterOptionsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Parameter is undocumented.
type Parameter struct {
	AllowedValues        aws.StringValue  `xml:"AllowedValues"`
	DataType             aws.StringValue  `xml:"DataType"`
	Description          aws.StringValue  `xml:"Description"`
	IsModifiable         aws.BooleanValue `xml:"IsModifiable"`
	MinimumEngineVersion aws.StringValue  `xml:"MinimumEngineVersion"`
	ParameterName        aws.StringValue  `xml:"ParameterName"`
	ParameterValue       aws.StringValue  `xml:"ParameterValue"`
	Source               aws.StringValue  `xml:"Source"`
}

func (v *Parameter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PendingModifiedValues is undocumented.
type PendingModifiedValues struct {
	AutomatedSnapshotRetentionPeriod aws.IntegerValue `xml:"AutomatedSnapshotRetentionPeriod"`
	ClusterIdentifier                aws.StringValue  `xml:"ClusterIdentifier"`
	ClusterType                      aws.StringValue  `xml:"ClusterType"`
	ClusterVersion                   aws.StringValue  `xml:"ClusterVersion"`
	MasterUserPassword               aws.StringValue  `xml:"MasterUserPassword"`
	NodeType                         aws.StringValue  `xml:"NodeType"`
	NumberOfNodes                    aws.IntegerValue `xml:"NumberOfNodes"`
}

func (v *PendingModifiedValues) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PurchaseReservedNodeOfferingMessage is undocumented.
type PurchaseReservedNodeOfferingMessage struct {
	NodeCount              aws.IntegerValue `xml:"NodeCount"`
	ReservedNodeOfferingID aws.StringValue  `xml:"ReservedNodeOfferingId"`
}

func (v *PurchaseReservedNodeOfferingMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ReservedNodeOfferingID"); err != nil {
		errors["ReservedNodeOfferingID"] = append(errors["ReservedNodeOfferingID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PurchaseReservedNodeOfferingResult is undocumented.
type PurchaseReservedNodeOfferingResult struct {
	ReservedNode *ReservedNode `xml:"PurchaseReservedNodeOfferingResult>ReservedNode"`
}

func (v *PurchaseReservedNodeOfferingResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RebootClusterMessage is undocumented.
type RebootClusterMessage struct {
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
}

func (v *RebootClusterMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RebootClusterResult is undocumented.
type RebootClusterResult struct {
	Cluster *Cluster `xml:"RebootClusterResult>Cluster"`
}

func (v *RebootClusterResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RecurringCharge is undocumented.
type RecurringCharge struct {
	RecurringChargeAmount    aws.DoubleValue `xml:"RecurringChargeAmount"`
	RecurringChargeFrequency aws.StringValue `xml:"RecurringChargeFrequency"`
}

func (v *RecurringCharge) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedNode is undocumented.
type ReservedNode struct {
	CurrencyCode           aws.StringValue   `xml:"CurrencyCode"`
	Duration               aws.IntegerValue  `xml:"Duration"`
	FixedPrice             aws.DoubleValue   `xml:"FixedPrice"`
	NodeCount              aws.IntegerValue  `xml:"NodeCount"`
	NodeType               aws.StringValue   `xml:"NodeType"`
	OfferingType           aws.StringValue   `xml:"OfferingType"`
	RecurringCharges       []RecurringCharge `xml:"RecurringCharges>RecurringCharge"`
	ReservedNodeID         aws.StringValue   `xml:"ReservedNodeId"`
	ReservedNodeOfferingID aws.StringValue   `xml:"ReservedNodeOfferingId"`
	StartTime              time.Time         `xml:"StartTime"`
	State                  aws.StringValue   `xml:"State"`
	UsagePrice             aws.DoubleValue   `xml:"UsagePrice"`
}

func (v *ReservedNode) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedNodeOffering is undocumented.
type ReservedNodeOffering struct {
	CurrencyCode           aws.StringValue   `xml:"CurrencyCode"`
	Duration               aws.IntegerValue  `xml:"Duration"`
	FixedPrice             aws.DoubleValue   `xml:"FixedPrice"`
	NodeType               aws.StringValue   `xml:"NodeType"`
	OfferingType           aws.StringValue   `xml:"OfferingType"`
	RecurringCharges       []RecurringCharge `xml:"RecurringCharges>RecurringCharge"`
	ReservedNodeOfferingID aws.StringValue   `xml:"ReservedNodeOfferingId"`
	UsagePrice             aws.DoubleValue   `xml:"UsagePrice"`
}

func (v *ReservedNodeOffering) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedNodeOfferingsMessage is undocumented.
type ReservedNodeOfferingsMessage struct {
	Marker                aws.StringValue        `xml:"DescribeReservedNodeOfferingsResult>Marker"`
	ReservedNodeOfferings []ReservedNodeOffering `xml:"DescribeReservedNodeOfferingsResult>ReservedNodeOfferings>ReservedNodeOffering"`
}

func (v *ReservedNodeOfferingsMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ReservedNodesMessage is undocumented.
type ReservedNodesMessage struct {
	Marker        aws.StringValue `xml:"DescribeReservedNodesResult>Marker"`
	ReservedNodes []ReservedNode  `xml:"DescribeReservedNodesResult>ReservedNodes>ReservedNode"`
}

func (v *ReservedNodesMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ResetClusterParameterGroupMessage is undocumented.
type ResetClusterParameterGroupMessage struct {
	ParameterGroupName aws.StringValue  `xml:"ParameterGroupName"`
	Parameters         []Parameter      `xml:"Parameters>Parameter"`
	ResetAllParameters aws.BooleanValue `xml:"ResetAllParameters"`
}

func (v *ResetClusterParameterGroupMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ParameterGroupName"); err != nil {
		errors["ParameterGroupName"] = append(errors["ParameterGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ResizeProgressMessage is undocumented.
type ResizeProgressMessage struct {
	AvgResizeRateInMegaBytesPerSecond  aws.DoubleValue  `xml:"DescribeResizeResult>AvgResizeRateInMegaBytesPerSecond"`
	ElapsedTimeInSeconds               aws.LongValue    `xml:"DescribeResizeResult>ElapsedTimeInSeconds"`
	EstimatedTimeToCompletionInSeconds aws.LongValue    `xml:"DescribeResizeResult>EstimatedTimeToCompletionInSeconds"`
	ImportTablesCompleted              []string         `xml:"DescribeResizeResult>ImportTablesCompleted>member"`
	ImportTablesInProgress             []string         `xml:"DescribeResizeResult>ImportTablesInProgress>member"`
	ImportTablesNotStarted             []string         `xml:"DescribeResizeResult>ImportTablesNotStarted>member"`
	ProgressInMegaBytes                aws.LongValue    `xml:"DescribeResizeResult>ProgressInMegaBytes"`
	Status                             aws.StringValue  `xml:"DescribeResizeResult>Status"`
	TargetClusterType                  aws.StringValue  `xml:"DescribeResizeResult>TargetClusterType"`
	TargetNodeType                     aws.StringValue  `xml:"DescribeResizeResult>TargetNodeType"`
	TargetNumberOfNodes                aws.IntegerValue `xml:"DescribeResizeResult>TargetNumberOfNodes"`
	TotalResizeDataInMegaBytes         aws.LongValue    `xml:"DescribeResizeResult>TotalResizeDataInMegaBytes"`
}

func (v *ResizeProgressMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RestoreFromClusterSnapshotMessage is undocumented.
type RestoreFromClusterSnapshotMessage struct {
	AllowVersionUpgrade              aws.BooleanValue `xml:"AllowVersionUpgrade"`
	AutomatedSnapshotRetentionPeriod aws.IntegerValue `xml:"AutomatedSnapshotRetentionPeriod"`
	AvailabilityZone                 aws.StringValue  `xml:"AvailabilityZone"`
	ClusterIdentifier                aws.StringValue  `xml:"ClusterIdentifier"`
	ClusterParameterGroupName        aws.StringValue  `xml:"ClusterParameterGroupName"`
	ClusterSecurityGroups            []string         `xml:"ClusterSecurityGroups>ClusterSecurityGroupName"`
	ClusterSubnetGroupName           aws.StringValue  `xml:"ClusterSubnetGroupName"`
	ElasticIP                        aws.StringValue  `xml:"ElasticIp"`
	HSMClientCertificateIdentifier   aws.StringValue  `xml:"HsmClientCertificateIdentifier"`
	HSMConfigurationIdentifier       aws.StringValue  `xml:"HsmConfigurationIdentifier"`
	KMSKeyID                         aws.StringValue  `xml:"KmsKeyId"`
	OwnerAccount                     aws.StringValue  `xml:"OwnerAccount"`
	Port                             aws.IntegerValue `xml:"Port"`
	PreferredMaintenanceWindow       aws.StringValue  `xml:"PreferredMaintenanceWindow"`
	PubliclyAccessible               aws.BooleanValue `xml:"PubliclyAccessible"`
	SnapshotClusterIdentifier        aws.StringValue  `xml:"SnapshotClusterIdentifier"`
	SnapshotIdentifier               aws.StringValue  `xml:"SnapshotIdentifier"`
	VPCSecurityGroupIDs              []string         `xml:"VpcSecurityGroupIds>VpcSecurityGroupId"`
}

func (v *RestoreFromClusterSnapshotMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotIdentifier"); err != nil {
		errors["SnapshotIdentifier"] = append(errors["SnapshotIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RestoreFromClusterSnapshotResult is undocumented.
type RestoreFromClusterSnapshotResult struct {
	Cluster *Cluster `xml:"RestoreFromClusterSnapshotResult>Cluster"`
}

func (v *RestoreFromClusterSnapshotResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RestoreStatus is undocumented.
type RestoreStatus struct {
	CurrentRestoreRateInMegaBytesPerSecond aws.DoubleValue `xml:"CurrentRestoreRateInMegaBytesPerSecond"`
	ElapsedTimeInSeconds                   aws.LongValue   `xml:"ElapsedTimeInSeconds"`
	EstimatedTimeToCompletionInSeconds     aws.LongValue   `xml:"EstimatedTimeToCompletionInSeconds"`
	ProgressInMegaBytes                    aws.LongValue   `xml:"ProgressInMegaBytes"`
	SnapshotSizeInMegaBytes                aws.LongValue   `xml:"SnapshotSizeInMegaBytes"`
	Status                                 aws.StringValue `xml:"Status"`
}

func (v *RestoreStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RevokeClusterSecurityGroupIngressMessage is undocumented.
type RevokeClusterSecurityGroupIngressMessage struct {
	CIDRIP                   aws.StringValue `xml:"CIDRIP"`
	ClusterSecurityGroupName aws.StringValue `xml:"ClusterSecurityGroupName"`
	EC2SecurityGroupName     aws.StringValue `xml:"EC2SecurityGroupName"`
	EC2SecurityGroupOwnerID  aws.StringValue `xml:"EC2SecurityGroupOwnerId"`
}

func (v *RevokeClusterSecurityGroupIngressMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterSecurityGroupName"); err != nil {
		errors["ClusterSecurityGroupName"] = append(errors["ClusterSecurityGroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RevokeClusterSecurityGroupIngressResult is undocumented.
type RevokeClusterSecurityGroupIngressResult struct {
	ClusterSecurityGroup *ClusterSecurityGroup `xml:"RevokeClusterSecurityGroupIngressResult>ClusterSecurityGroup"`
}

func (v *RevokeClusterSecurityGroupIngressResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RevokeSnapshotAccessMessage is undocumented.
type RevokeSnapshotAccessMessage struct {
	AccountWithRestoreAccess  aws.StringValue `xml:"AccountWithRestoreAccess"`
	SnapshotClusterIdentifier aws.StringValue `xml:"SnapshotClusterIdentifier"`
	SnapshotIdentifier        aws.StringValue `xml:"SnapshotIdentifier"`
}

func (v *RevokeSnapshotAccessMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccountWithRestoreAccess"); err != nil {
		errors["AccountWithRestoreAccess"] = append(errors["AccountWithRestoreAccess"], err)
	}

	if err := model.ValidateRequired(v, "SnapshotIdentifier"); err != nil {
		errors["SnapshotIdentifier"] = append(errors["SnapshotIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RevokeSnapshotAccessResult is undocumented.
type RevokeSnapshotAccessResult struct {
	Snapshot *Snapshot `xml:"RevokeSnapshotAccessResult>Snapshot"`
}

func (v *RevokeSnapshotAccessResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RotateEncryptionKeyMessage is undocumented.
type RotateEncryptionKeyMessage struct {
	ClusterIdentifier aws.StringValue `xml:"ClusterIdentifier"`
}

func (v *RotateEncryptionKeyMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClusterIdentifier"); err != nil {
		errors["ClusterIdentifier"] = append(errors["ClusterIdentifier"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RotateEncryptionKeyResult is undocumented.
type RotateEncryptionKeyResult struct {
	Cluster *Cluster `xml:"RotateEncryptionKeyResult>Cluster"`
}

func (v *RotateEncryptionKeyResult) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Snapshot is undocumented.
type Snapshot struct {
	AccountsWithRestoreAccess              []AccountWithRestoreAccess `xml:"AccountsWithRestoreAccess>AccountWithRestoreAccess"`
	ActualIncrementalBackupSizeInMegaBytes aws.DoubleValue            `xml:"ActualIncrementalBackupSizeInMegaBytes"`
	AvailabilityZone                       aws.StringValue            `xml:"AvailabilityZone"`
	BackupProgressInMegaBytes              aws.DoubleValue            `xml:"BackupProgressInMegaBytes"`
	ClusterCreateTime                      time.Time                  `xml:"ClusterCreateTime"`
	ClusterIdentifier                      aws.StringValue            `xml:"ClusterIdentifier"`
	ClusterVersion                         aws.StringValue            `xml:"ClusterVersion"`
	CurrentBackupRateInMegaBytesPerSecond  aws.DoubleValue            `xml:"CurrentBackupRateInMegaBytesPerSecond"`
	DBName                                 aws.StringValue            `xml:"DBName"`
	ElapsedTimeInSeconds                   aws.LongValue              `xml:"ElapsedTimeInSeconds"`
	Encrypted                              aws.BooleanValue           `xml:"Encrypted"`
	EncryptedWithHSM                       aws.BooleanValue           `xml:"EncryptedWithHSM"`
	EstimatedSecondsToCompletion           aws.LongValue              `xml:"EstimatedSecondsToCompletion"`
	KMSKeyID                               aws.StringValue            `xml:"KmsKeyId"`
	MasterUsername                         aws.StringValue            `xml:"MasterUsername"`
	NodeType                               aws.StringValue            `xml:"NodeType"`
	NumberOfNodes                          aws.IntegerValue           `xml:"NumberOfNodes"`
	OwnerAccount                           aws.StringValue            `xml:"OwnerAccount"`
	Port                                   aws.IntegerValue           `xml:"Port"`
	SnapshotCreateTime                     time.Time                  `xml:"SnapshotCreateTime"`
	SnapshotIdentifier                     aws.StringValue            `xml:"SnapshotIdentifier"`
	SnapshotType                           aws.StringValue            `xml:"SnapshotType"`
	SourceRegion                           aws.StringValue            `xml:"SourceRegion"`
	Status                                 aws.StringValue            `xml:"Status"`
	Tags                                   []Tag                      `xml:"Tags>Tag"`
	TotalBackupSizeInMegaBytes             aws.DoubleValue            `xml:"TotalBackupSizeInMegaBytes"`
	VPCID                                  aws.StringValue            `xml:"VpcId"`
}

func (v *Snapshot) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SnapshotMessage is undocumented.
type SnapshotMessage struct {
	Marker    aws.StringValue `xml:"DescribeClusterSnapshotsResult>Marker"`
	Snapshots []Snapshot      `xml:"DescribeClusterSnapshotsResult>Snapshots>Snapshot"`
}

func (v *SnapshotMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for RedShift.
const (
	SourceTypeCluster               = "cluster"
	SourceTypeClusterParameterGroup = "cluster-parameter-group"
	SourceTypeClusterSecurityGroup  = "cluster-security-group"
	SourceTypeClusterSnapshot       = "cluster-snapshot"
)

// Subnet is undocumented.
type Subnet struct {
	SubnetAvailabilityZone *AvailabilityZone `xml:"SubnetAvailabilityZone"`
	SubnetIdentifier       aws.StringValue   `xml:"SubnetIdentifier"`
	SubnetStatus           aws.StringValue   `xml:"SubnetStatus"`
}

func (v *Subnet) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Tag is undocumented.
type Tag struct {
	Key   aws.StringValue `xml:"Key"`
	Value aws.StringValue `xml:"Value"`
}

func (v *Tag) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TaggedResource is undocumented.
type TaggedResource struct {
	ResourceName aws.StringValue `xml:"ResourceName"`
	ResourceType aws.StringValue `xml:"ResourceType"`
	Tag          *Tag            `xml:"Tag"`
}

func (v *TaggedResource) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TaggedResourceListMessage is undocumented.
type TaggedResourceListMessage struct {
	Marker          aws.StringValue  `xml:"DescribeTagsResult>Marker"`
	TaggedResources []TaggedResource `xml:"DescribeTagsResult>TaggedResources>TaggedResource"`
}

func (v *TaggedResourceListMessage) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VPCSecurityGroupMembership is undocumented.
type VPCSecurityGroupMembership struct {
	Status             aws.StringValue `xml:"Status"`
	VPCSecurityGroupID aws.StringValue `xml:"VpcSecurityGroupId"`
}

func (v *VPCSecurityGroupMembership) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeClusterParameterGroupsResult is a wrapper for ClusterParameterGroupsMessage.
type DescribeClusterParameterGroupsResult struct {
	Marker          aws.StringValue         `xml:"DescribeClusterParameterGroupsResult>Marker"`
	ParameterGroups []ClusterParameterGroup `xml:"DescribeClusterParameterGroupsResult>ParameterGroups>ClusterParameterGroup"`
}

// DescribeClusterParametersResult is a wrapper for ClusterParameterGroupDetails.
type DescribeClusterParametersResult struct {
	Marker     aws.StringValue `xml:"DescribeClusterParametersResult>Marker"`
	Parameters []Parameter     `xml:"DescribeClusterParametersResult>Parameters>Parameter"`
}

// DescribeClusterSecurityGroupsResult is a wrapper for ClusterSecurityGroupMessage.
type DescribeClusterSecurityGroupsResult struct {
	ClusterSecurityGroups []ClusterSecurityGroup `xml:"DescribeClusterSecurityGroupsResult>ClusterSecurityGroups>ClusterSecurityGroup"`
	Marker                aws.StringValue        `xml:"DescribeClusterSecurityGroupsResult>Marker"`
}

// DescribeClusterSnapshotsResult is a wrapper for SnapshotMessage.
type DescribeClusterSnapshotsResult struct {
	Marker    aws.StringValue `xml:"DescribeClusterSnapshotsResult>Marker"`
	Snapshots []Snapshot      `xml:"DescribeClusterSnapshotsResult>Snapshots>Snapshot"`
}

// DescribeClusterSubnetGroupsResult is a wrapper for ClusterSubnetGroupMessage.
type DescribeClusterSubnetGroupsResult struct {
	ClusterSubnetGroups []ClusterSubnetGroup `xml:"DescribeClusterSubnetGroupsResult>ClusterSubnetGroups>ClusterSubnetGroup"`
	Marker              aws.StringValue      `xml:"DescribeClusterSubnetGroupsResult>Marker"`
}

// DescribeClusterVersionsResult is a wrapper for ClusterVersionsMessage.
type DescribeClusterVersionsResult struct {
	ClusterVersions []ClusterVersion `xml:"DescribeClusterVersionsResult>ClusterVersions>ClusterVersion"`
	Marker          aws.StringValue  `xml:"DescribeClusterVersionsResult>Marker"`
}

// DescribeClustersResult is a wrapper for ClustersMessage.
type DescribeClustersResult struct {
	Clusters []Cluster       `xml:"DescribeClustersResult>Clusters>Cluster"`
	Marker   aws.StringValue `xml:"DescribeClustersResult>Marker"`
}

// DescribeEventCategoriesResult is a wrapper for EventCategoriesMessage.
type DescribeEventCategoriesResult struct {
	EventCategoriesMapList []EventCategoriesMap `xml:"DescribeEventCategoriesResult>EventCategoriesMapList>EventCategoriesMap"`
}

// DescribeEventSubscriptionsResult is a wrapper for EventSubscriptionsMessage.
type DescribeEventSubscriptionsResult struct {
	EventSubscriptionsList []EventSubscription `xml:"DescribeEventSubscriptionsResult>EventSubscriptionsList>EventSubscription"`
	Marker                 aws.StringValue     `xml:"DescribeEventSubscriptionsResult>Marker"`
}

// DescribeEventsResult is a wrapper for EventsMessage.
type DescribeEventsResult struct {
	Events []Event         `xml:"DescribeEventsResult>Events>Event"`
	Marker aws.StringValue `xml:"DescribeEventsResult>Marker"`
}

// DescribeHSMClientCertificatesResult is a wrapper for HsmClientCertificateMessage.
type DescribeHSMClientCertificatesResult struct {
	HSMClientCertificates []HSMClientCertificate `xml:"DescribeHsmClientCertificatesResult>HsmClientCertificates>HsmClientCertificate"`
	Marker                aws.StringValue        `xml:"DescribeHsmClientCertificatesResult>Marker"`
}

// DescribeHSMConfigurationsResult is a wrapper for HsmConfigurationMessage.
type DescribeHSMConfigurationsResult struct {
	HSMConfigurations []HSMConfiguration `xml:"DescribeHsmConfigurationsResult>HsmConfigurations>HsmConfiguration"`
	Marker            aws.StringValue    `xml:"DescribeHsmConfigurationsResult>Marker"`
}

// DescribeLoggingStatusResult is a wrapper for LoggingStatus.
type DescribeLoggingStatusResult struct {
	BucketName                 aws.StringValue  `xml:"DescribeLoggingStatusResult>BucketName"`
	LastFailureMessage         aws.StringValue  `xml:"DescribeLoggingStatusResult>LastFailureMessage"`
	LastFailureTime            time.Time        `xml:"DescribeLoggingStatusResult>LastFailureTime"`
	LastSuccessfulDeliveryTime time.Time        `xml:"DescribeLoggingStatusResult>LastSuccessfulDeliveryTime"`
	LoggingEnabled             aws.BooleanValue `xml:"DescribeLoggingStatusResult>LoggingEnabled"`
	S3KeyPrefix                aws.StringValue  `xml:"DescribeLoggingStatusResult>S3KeyPrefix"`
}

// DescribeOrderableClusterOptionsResult is a wrapper for OrderableClusterOptionsMessage.
type DescribeOrderableClusterOptionsResult struct {
	Marker                  aws.StringValue          `xml:"DescribeOrderableClusterOptionsResult>Marker"`
	OrderableClusterOptions []OrderableClusterOption `xml:"DescribeOrderableClusterOptionsResult>OrderableClusterOptions>OrderableClusterOption"`
}

// DescribeReservedNodeOfferingsResult is a wrapper for ReservedNodeOfferingsMessage.
type DescribeReservedNodeOfferingsResult struct {
	Marker                aws.StringValue        `xml:"DescribeReservedNodeOfferingsResult>Marker"`
	ReservedNodeOfferings []ReservedNodeOffering `xml:"DescribeReservedNodeOfferingsResult>ReservedNodeOfferings>ReservedNodeOffering"`
}

// DescribeReservedNodesResult is a wrapper for ReservedNodesMessage.
type DescribeReservedNodesResult struct {
	Marker        aws.StringValue `xml:"DescribeReservedNodesResult>Marker"`
	ReservedNodes []ReservedNode  `xml:"DescribeReservedNodesResult>ReservedNodes>ReservedNode"`
}

// DescribeResizeResult is a wrapper for ResizeProgressMessage.
type DescribeResizeResult struct {
	AvgResizeRateInMegaBytesPerSecond  aws.DoubleValue  `xml:"DescribeResizeResult>AvgResizeRateInMegaBytesPerSecond"`
	ElapsedTimeInSeconds               aws.LongValue    `xml:"DescribeResizeResult>ElapsedTimeInSeconds"`
	EstimatedTimeToCompletionInSeconds aws.LongValue    `xml:"DescribeResizeResult>EstimatedTimeToCompletionInSeconds"`
	ImportTablesCompleted              []string         `xml:"DescribeResizeResult>ImportTablesCompleted>member"`
	ImportTablesInProgress             []string         `xml:"DescribeResizeResult>ImportTablesInProgress>member"`
	ImportTablesNotStarted             []string         `xml:"DescribeResizeResult>ImportTablesNotStarted>member"`
	ProgressInMegaBytes                aws.LongValue    `xml:"DescribeResizeResult>ProgressInMegaBytes"`
	Status                             aws.StringValue  `xml:"DescribeResizeResult>Status"`
	TargetClusterType                  aws.StringValue  `xml:"DescribeResizeResult>TargetClusterType"`
	TargetNodeType                     aws.StringValue  `xml:"DescribeResizeResult>TargetNodeType"`
	TargetNumberOfNodes                aws.IntegerValue `xml:"DescribeResizeResult>TargetNumberOfNodes"`
	TotalResizeDataInMegaBytes         aws.LongValue    `xml:"DescribeResizeResult>TotalResizeDataInMegaBytes"`
}

// DescribeTagsResult is a wrapper for TaggedResourceListMessage.
type DescribeTagsResult struct {
	Marker          aws.StringValue  `xml:"DescribeTagsResult>Marker"`
	TaggedResources []TaggedResource `xml:"DescribeTagsResult>TaggedResources>TaggedResource"`
}

// DisableLoggingResult is a wrapper for LoggingStatus.
type DisableLoggingResult struct {
	BucketName                 aws.StringValue  `xml:"DisableLoggingResult>BucketName"`
	LastFailureMessage         aws.StringValue  `xml:"DisableLoggingResult>LastFailureMessage"`
	LastFailureTime            time.Time        `xml:"DisableLoggingResult>LastFailureTime"`
	LastSuccessfulDeliveryTime time.Time        `xml:"DisableLoggingResult>LastSuccessfulDeliveryTime"`
	LoggingEnabled             aws.BooleanValue `xml:"DisableLoggingResult>LoggingEnabled"`
	S3KeyPrefix                aws.StringValue  `xml:"DisableLoggingResult>S3KeyPrefix"`
}

// EnableLoggingResult is a wrapper for LoggingStatus.
type EnableLoggingResult struct {
	BucketName                 aws.StringValue  `xml:"EnableLoggingResult>BucketName"`
	LastFailureMessage         aws.StringValue  `xml:"EnableLoggingResult>LastFailureMessage"`
	LastFailureTime            time.Time        `xml:"EnableLoggingResult>LastFailureTime"`
	LastSuccessfulDeliveryTime time.Time        `xml:"EnableLoggingResult>LastSuccessfulDeliveryTime"`
	LoggingEnabled             aws.BooleanValue `xml:"EnableLoggingResult>LoggingEnabled"`
	S3KeyPrefix                aws.StringValue  `xml:"EnableLoggingResult>S3KeyPrefix"`
}

// ModifyClusterParameterGroupResult is a wrapper for ClusterParameterGroupNameMessage.
type ModifyClusterParameterGroupResult struct {
	ParameterGroupName   aws.StringValue `xml:"ModifyClusterParameterGroupResult>ParameterGroupName"`
	ParameterGroupStatus aws.StringValue `xml:"ModifyClusterParameterGroupResult>ParameterGroupStatus"`
}

// ResetClusterParameterGroupResult is a wrapper for ClusterParameterGroupNameMessage.
type ResetClusterParameterGroupResult struct {
	ParameterGroupName   aws.StringValue `xml:"ResetClusterParameterGroupResult>ParameterGroupName"`
	ParameterGroupStatus aws.StringValue `xml:"ResetClusterParameterGroupResult>ParameterGroupStatus"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
