// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package iam provides a client for AWS Identity and Access Management.
package iam

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

// IAM is a client for AWS Identity and Access Management.
type IAM struct {
	client *aws.QueryClient
}

// New returns a new IAM client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *IAM {
	if client == nil {
		client = http.DefaultClient
	}

	service := "iam"
	endpoint, service, region := endpoints.Lookup("iam", region)

	return &IAM{
		client: &aws.QueryClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2010-05-08",
		},
	}
}

// AddClientIDToOpenIDConnectProvider adds a new client ID (also known as
// audience) to the list of client IDs already registered for the specified
// IAM OpenID Connect provider. This action is idempotent; it does not fail
// or return an error if you add an existing client ID to the provider.
func (c *IAM) AddClientIDToOpenIDConnectProvider(req *AddClientIDToOpenIDConnectProviderRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AddClientIDToOpenIDConnectProvider", "POST", "/", req, nil)
	return
}

// AddRoleToInstanceProfile adds the specified role to the specified
// instance profile. For more information about roles, go to Working with
// Roles . For more information about instance profiles, go to About
// Instance Profiles .
func (c *IAM) AddRoleToInstanceProfile(req *AddRoleToInstanceProfileRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AddRoleToInstanceProfile", "POST", "/", req, nil)
	return
}

// AddUserToGroup is undocumented.
func (c *IAM) AddUserToGroup(req *AddUserToGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("AddUserToGroup", "POST", "/", req, nil)
	return
}

// ChangePassword changes the password of the IAM user who is calling this
// action. The root account password is not affected by this action. To
// change the password for a different user, see UpdateLoginProfile . For
// more information about modifying passwords, see Managing Passwords in
// the Using guide.
func (c *IAM) ChangePassword(req *ChangePasswordRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ChangePassword", "POST", "/", req, nil)
	return
}

// CreateAccessKey creates a new AWS secret access key and corresponding
// AWS access key ID for the specified user. The default status for new
// keys is Active . If you do not specify a user name, IAM determines the
// user name implicitly based on the AWS access key ID signing the request.
// Because this action works for access keys under the AWS account, you can
// use this action to manage root credentials even if the AWS account has
// no associated users. For information about limits on the number of keys
// you can create, see Limitations on IAM Entities in the Using guide. To
// ensure the security of your AWS account, the secret access key is
// accessible only during key and user creation. You must save the key (for
// example, in a text file) if you want to be able to access it again. If a
// secret key is lost, you can delete the access keys for the associated
// user and then create new keys.
func (c *IAM) CreateAccessKey(req *CreateAccessKeyRequest) (resp *CreateAccessKeyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateAccessKeyResult{}
	err = c.client.Do("CreateAccessKey", "POST", "/", req, resp)
	return
}

// CreateAccountAlias creates an alias for your AWS account. For
// information about using an AWS account alias, see Using an Alias for
// Your AWS Account in the Using guide.
func (c *IAM) CreateAccountAlias(req *CreateAccountAliasRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("CreateAccountAlias", "POST", "/", req, nil)
	return
}

// CreateGroup creates a new group. For information about the number of
// groups you can create, see Limitations on IAM Entities in the Using
// guide.
func (c *IAM) CreateGroup(req *CreateGroupRequest) (resp *CreateGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateGroupResult{}
	err = c.client.Do("CreateGroup", "POST", "/", req, resp)
	return
}

// CreateInstanceProfile creates a new instance profile. For information
// about instance profiles, go to About Instance Profiles . For information
// about the number of instance profiles you can create, see Limitations on
// IAM Entities in the Using guide.
func (c *IAM) CreateInstanceProfile(req *CreateInstanceProfileRequest) (resp *CreateInstanceProfileResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateInstanceProfileResult{}
	err = c.client.Do("CreateInstanceProfile", "POST", "/", req, resp)
	return
}

// CreateLoginProfile creates a password for the specified user, giving the
// user the ability to access AWS services through the AWS Management
// Console. For more information about managing passwords, see Managing
// Passwords in the Using guide.
func (c *IAM) CreateLoginProfile(req *CreateLoginProfileRequest) (resp *CreateLoginProfileResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateLoginProfileResult{}
	err = c.client.Do("CreateLoginProfile", "POST", "/", req, resp)
	return
}

// CreateOpenIDConnectProvider creates an IAM entity to describe an
// identity provider (IdP) that supports OpenID Connect . The provider that
// you create with this operation can be used as a principal in a role's
// trust policy to establish a trust relationship between AWS and the
// provider. When you create the IAM provider, you specify the URL of the
// identity provider (IdP) to trust, a list of client IDs (also known as
// audiences) that identify the application or applications that are
// allowed to authenticate using the provider, and a list of thumbprints of
// the server certificate(s) that the IdP uses. You get all of this
// information from the IdP that you want to use for access to Because
// trust for the provider is ultimately derived from the IAM provider that
// this action creates, it is a best practice to limit access to the
// CreateOpenIDConnectProvider action to highly-privileged users.
func (c *IAM) CreateOpenIDConnectProvider(req *CreateOpenIDConnectProviderRequest) (resp *CreateOpenIDConnectProviderResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateOpenIDConnectProviderResult{}
	err = c.client.Do("CreateOpenIDConnectProvider", "POST", "/", req, resp)
	return
}

// CreateRole creates a new role for your AWS account. For more information
// about roles, go to Working with Roles . For information about
// limitations on role names and the number of roles you can create, go to
// Limitations on IAM Entities in the Using guide. The example policy
// grants permission to an EC2 instance to assume the role. The policy is
// URL-encoded according to RFC 3986. For more information about RFC 3986,
// go to http://www.faqs.org/rfcs/rfc3986.html .
func (c *IAM) CreateRole(req *CreateRoleRequest) (resp *CreateRoleResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateRoleResult{}
	err = c.client.Do("CreateRole", "POST", "/", req, resp)
	return
}

// CreateSAMLProvider creates an IAM entity to describe an identity
// provider (IdP) that supports 2.0. The provider that you create with this
// operation can be used as a principal in a role's trust policy to
// establish a trust relationship between AWS and a identity provider. You
// can create an IAM role that supports Web-based single sign-on to the AWS
// Management Console or one that supports API access to When you create
// the provider, you upload an a metadata document that you get from your
// IdP and that includes the issuer's name, expiration information, and
// keys that can be used to validate the authentication response
// (assertions) that are received from the IdP. You must generate the
// metadata document using the identity management software that is used as
// your organization's IdP. This operation requires Signature Version 4 .
// For more information, see Giving Console Access Using and Creating
// Temporary Security Credentials for Federation in the Using Temporary
// Credentials guide.
func (c *IAM) CreateSAMLProvider(req *CreateSAMLProviderRequest) (resp *CreateSAMLProviderResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateSAMLProviderResult{}
	err = c.client.Do("CreateSAMLProvider", "POST", "/", req, resp)
	return
}

// CreateUser creates a new user for your AWS account. For information
// about limitations on the number of users you can create, see Limitations
// on IAM Entities in the Using guide.
func (c *IAM) CreateUser(req *CreateUserRequest) (resp *CreateUserResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateUserResult{}
	err = c.client.Do("CreateUser", "POST", "/", req, resp)
	return
}

// CreateVirtualMFADevice creates a new virtual MFA device for the AWS
// account. After creating the virtual use EnableMFADevice to attach the
// MFA device to an IAM user. For more information about creating and
// working with virtual MFA devices, go to Using a Virtual MFA Device in
// the Using guide. For information about limits on the number of MFA
// devices you can create, see Limitations on Entities in the Using guide.
// The seed information contained in the QR code and the Base32 string
// should be treated like any other secret access information, such as your
// AWS access keys or your passwords. After you provision your virtual
// device, you should ensure that the information is destroyed following
// secure procedures.
func (c *IAM) CreateVirtualMFADevice(req *CreateVirtualMFADeviceRequest) (resp *CreateVirtualMFADeviceResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateVirtualMFADeviceResult{}
	err = c.client.Do("CreateVirtualMFADevice", "POST", "/", req, resp)
	return
}

// DeactivateMFADevice deactivates the specified MFA device and removes it
// from association with the user name for which it was originally enabled.
// For more information about creating and working with virtual MFA
// devices, go to Using a Virtual MFA Device in the Using guide.
func (c *IAM) DeactivateMFADevice(req *DeactivateMFADeviceRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeactivateMFADevice", "POST", "/", req, nil)
	return
}

// DeleteAccessKey deletes the access key associated with the specified
// user. If you do not specify a user name, IAM determines the user name
// implicitly based on the AWS access key ID signing the request. Because
// this action works for access keys under the AWS account, you can use
// this action to manage root credentials even if the AWS account has no
// associated users.
func (c *IAM) DeleteAccessKey(req *DeleteAccessKeyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteAccessKey", "POST", "/", req, nil)
	return
}

// DeleteAccountAlias deletes the specified AWS account alias. For
// information about using an AWS account alias, see Using an Alias for
// Your AWS Account in the Using guide.
func (c *IAM) DeleteAccountAlias(req *DeleteAccountAliasRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteAccountAlias", "POST", "/", req, nil)
	return
}

// DeleteAccountPasswordPolicy is undocumented.
func (c *IAM) DeleteAccountPasswordPolicy() (err error) {
	// NRE
	err = c.client.Do("DeleteAccountPasswordPolicy", "POST", "/", nil, nil)
	return
}

// DeleteGroup deletes the specified group. The group must not contain any
// users or have any attached policies.
func (c *IAM) DeleteGroup(req *DeleteGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteGroup", "POST", "/", req, nil)
	return
}

// DeleteGroupPolicy deletes the specified policy that is associated with
// the specified group.
func (c *IAM) DeleteGroupPolicy(req *DeleteGroupPolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteGroupPolicy", "POST", "/", req, nil)
	return
}

// DeleteInstanceProfile deletes the specified instance profile. The
// instance profile must not have an associated role. Make sure you do not
// have any Amazon EC2 instances running with the instance profile you are
// about to delete. Deleting a role or instance profile that is associated
// with a running instance will break any applications running on the
// instance. For more information about instance profiles, go to About
// Instance Profiles .
func (c *IAM) DeleteInstanceProfile(req *DeleteInstanceProfileRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteInstanceProfile", "POST", "/", req, nil)
	return
}

// DeleteLoginProfile deletes the password for the specified user, which
// terminates the user's ability to access AWS services through the AWS
// Management Console. Deleting a user's password does not prevent a user
// from accessing IAM through the command line interface or the To prevent
// all user access you must also either make the access key inactive or
// delete it. For more information about making keys inactive or deleting
// them, see UpdateAccessKey and DeleteAccessKey .
func (c *IAM) DeleteLoginProfile(req *DeleteLoginProfileRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteLoginProfile", "POST", "/", req, nil)
	return
}

// DeleteOpenIDConnectProvider deletes an IAM OpenID Connect identity
// provider. Deleting an provider does not update any roles that reference
// the provider as a principal in their trust policies. Any attempt to
// assume a role that references a provider that has been deleted will
// fail. This action is idempotent; it does not fail or return an error if
// you call the action for a provider that was already deleted.
func (c *IAM) DeleteOpenIDConnectProvider(req *DeleteOpenIDConnectProviderRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteOpenIDConnectProvider", "POST", "/", req, nil)
	return
}

// DeleteRole deletes the specified role. The role must not have any
// policies attached. For more information about roles, go to Working with
// Roles . Make sure you do not have any Amazon EC2 instances running with
// the role you are about to delete. Deleting a role or instance profile
// that is associated with a running instance will break any applications
// running on the instance.
func (c *IAM) DeleteRole(req *DeleteRoleRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteRole", "POST", "/", req, nil)
	return
}

// DeleteRolePolicy deletes the specified policy associated with the
// specified role.
func (c *IAM) DeleteRolePolicy(req *DeleteRolePolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteRolePolicy", "POST", "/", req, nil)
	return
}

// DeleteSAMLProvider deletes a provider. Deleting the provider does not
// update any roles that reference the provider as a principal in their
// trust policies. Any attempt to assume a role that references a provider
// that has been deleted will fail. This operation requires Signature
// Version 4 .
func (c *IAM) DeleteSAMLProvider(req *DeleteSAMLProviderRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteSAMLProvider", "POST", "/", req, nil)
	return
}

// DeleteServerCertificate deletes the specified server certificate. If you
// are using a server certificate with Elastic Load Balancing, deleting the
// certificate could have implications for your application. If Elastic
// Load Balancing doesn't detect the deletion of bound certificates, it may
// continue to use the certificates. This could cause Elastic Load
// Balancing to stop accepting traffic. We recommend that you remove the
// reference to the certificate from Elastic Load Balancing before using
// this command to delete the certificate. For more information, go to
// DeleteLoadBalancerListeners in the Elastic Load Balancing API Reference
// .
func (c *IAM) DeleteServerCertificate(req *DeleteServerCertificateRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteServerCertificate", "POST", "/", req, nil)
	return
}

// DeleteSigningCertificate deletes the specified signing certificate
// associated with the specified user. If you do not specify a user name,
// IAM determines the user name implicitly based on the AWS access key ID
// signing the request. Because this action works for access keys under the
// AWS account, you can use this action to manage root credentials even if
// the AWS account has no associated users.
func (c *IAM) DeleteSigningCertificate(req *DeleteSigningCertificateRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteSigningCertificate", "POST", "/", req, nil)
	return
}

// DeleteUser deletes the specified user. The user must not belong to any
// groups, have any keys or signing certificates, or have any attached
// policies.
func (c *IAM) DeleteUser(req *DeleteUserRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteUser", "POST", "/", req, nil)
	return
}

// DeleteUserPolicy deletes the specified policy associated with the
// specified user.
func (c *IAM) DeleteUserPolicy(req *DeleteUserPolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteUserPolicy", "POST", "/", req, nil)
	return
}

// DeleteVirtualMFADevice deletes a virtual MFA device. You must deactivate
// a user's virtual MFA device before you can delete it. For information
// about deactivating MFA devices, see DeactivateMFADevice .
func (c *IAM) DeleteVirtualMFADevice(req *DeleteVirtualMFADeviceRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeleteVirtualMFADevice", "POST", "/", req, nil)
	return
}

// EnableMFADevice enables the specified MFA device and associates it with
// the specified user name. When enabled, the MFA device is required for
// every subsequent login by the user name associated with the device.
func (c *IAM) EnableMFADevice(req *EnableMFADeviceRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("EnableMFADevice", "POST", "/", req, nil)
	return
}

// GenerateCredentialReport generates a credential report for the AWS
// account. For more information about the credential report, see Getting
// Credential Reports in the Using guide.
func (c *IAM) GenerateCredentialReport() (resp *GenerateCredentialReportResult, err error) {
	resp = &GenerateCredentialReportResult{}
	err = c.client.Do("GenerateCredentialReport", "POST", "/", nil, resp)
	return
}

// GetAccountAuthorizationDetails retrieves information about all IAM
// users, groups, and roles in your account, including their relationships
// to one another and their attached policies. Use this API to obtain a
// snapshot of the configuration of IAM permissions (users, groups, roles,
// and policies) in your account. You can optionally filter the results
// using the Filter parameter. You can paginate the results using the
// MaxItems and Marker parameters.
func (c *IAM) GetAccountAuthorizationDetails(req *GetAccountAuthorizationDetailsRequest) (resp *GetAccountAuthorizationDetailsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetAccountAuthorizationDetailsResult{}
	err = c.client.Do("GetAccountAuthorizationDetails", "POST", "/", req, resp)
	return
}

// GetAccountPasswordPolicy retrieves the password policy for the AWS
// account. For more information about using a password policy, go to
// Managing an IAM Password Policy .
func (c *IAM) GetAccountPasswordPolicy() (resp *GetAccountPasswordPolicyResult, err error) {
	resp = &GetAccountPasswordPolicyResult{}
	err = c.client.Do("GetAccountPasswordPolicy", "POST", "/", nil, resp)
	return
}

// GetAccountSummary retrieves account level information about account
// entity usage and IAM quotas. For information about limitations on IAM
// entities, see Limitations on IAM Entities in the Using guide.
func (c *IAM) GetAccountSummary() (resp *GetAccountSummaryResult, err error) {
	resp = &GetAccountSummaryResult{}
	err = c.client.Do("GetAccountSummary", "POST", "/", nil, resp)
	return
}

// GetCredentialReport retrieves a credential report for the AWS account.
// For more information about the credential report, see Getting Credential
// Reports in the Using guide.
func (c *IAM) GetCredentialReport() (resp *GetCredentialReportResult, err error) {
	resp = &GetCredentialReportResult{}
	err = c.client.Do("GetCredentialReport", "POST", "/", nil, resp)
	return
}

// GetGroup returns a list of users that are in the specified group. You
// can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) GetGroup(req *GetGroupRequest) (resp *GetGroupResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetGroupResult{}
	err = c.client.Do("GetGroup", "POST", "/", req, resp)
	return
}

// GetGroupPolicy retrieves the specified policy document for the specified
// group. The returned policy is URL-encoded according to RFC 3986. For
// more information about RFC 3986, go to
// http://www.faqs.org/rfcs/rfc3986.html .
func (c *IAM) GetGroupPolicy(req *GetGroupPolicyRequest) (resp *GetGroupPolicyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetGroupPolicyResult{}
	err = c.client.Do("GetGroupPolicy", "POST", "/", req, resp)
	return
}

// GetInstanceProfile retrieves information about the specified instance
// profile, including the instance profile's path, and role. For more
// information about instance profiles, go to About Instance Profiles . For
// more information about ARNs, go to ARNs .
func (c *IAM) GetInstanceProfile(req *GetInstanceProfileRequest) (resp *GetInstanceProfileResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetInstanceProfileResult{}
	err = c.client.Do("GetInstanceProfile", "POST", "/", req, resp)
	return
}

// GetLoginProfile retrieves the user name and password-creation date for
// the specified user. If the user has not been assigned a password, the
// action returns a 404 NoSuchEntity ) error.
func (c *IAM) GetLoginProfile(req *GetLoginProfileRequest) (resp *GetLoginProfileResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetLoginProfileResult{}
	err = c.client.Do("GetLoginProfile", "POST", "/", req, resp)
	return
}

// GetOpenIDConnectProvider returns information about the specified OpenID
// Connect provider.
func (c *IAM) GetOpenIDConnectProvider(req *GetOpenIDConnectProviderRequest) (resp *GetOpenIDConnectProviderResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetOpenIDConnectProviderResult{}
	err = c.client.Do("GetOpenIDConnectProvider", "POST", "/", req, resp)
	return
}

// GetRole retrieves information about the specified role, including the
// role's path, and the policy granting permission to assume the role. For
// more information about ARNs, go to ARNs . For more information about
// roles, go to Working with Roles . The returned policy is URL-encoded
// according to RFC 3986. For more information about RFC 3986, go to
// http://www.faqs.org/rfcs/rfc3986.html .
func (c *IAM) GetRole(req *GetRoleRequest) (resp *GetRoleResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetRoleResult{}
	err = c.client.Do("GetRole", "POST", "/", req, resp)
	return
}

// GetRolePolicy retrieves the specified policy document for the specified
// role. For more information about roles, go to Working with Roles . The
// returned policy is URL-encoded according to RFC 3986. For more
// information about RFC 3986, go to http://www.faqs.org/rfcs/rfc3986.html
// .
func (c *IAM) GetRolePolicy(req *GetRolePolicyRequest) (resp *GetRolePolicyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetRolePolicyResult{}
	err = c.client.Do("GetRolePolicy", "POST", "/", req, resp)
	return
}

// GetSAMLProvider returns the provider metadocument that was uploaded when
// the provider was created or updated. This operation requires Signature
// Version 4 .
func (c *IAM) GetSAMLProvider(req *GetSAMLProviderRequest) (resp *GetSAMLProviderResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetSAMLProviderResult{}
	err = c.client.Do("GetSAMLProvider", "POST", "/", req, resp)
	return
}

// GetServerCertificate retrieves information about the specified server
// certificate.
func (c *IAM) GetServerCertificate(req *GetServerCertificateRequest) (resp *GetServerCertificateResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetServerCertificateResult{}
	err = c.client.Do("GetServerCertificate", "POST", "/", req, resp)
	return
}

// GetUser retrieves information about the specified user, including the
// user's creation date, path, unique ID, and If you do not specify a user
// name, IAM determines the user name implicitly based on the AWS access
// key ID used to sign the request.
func (c *IAM) GetUser(req *GetUserRequest) (resp *GetUserResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetUserResult{}
	err = c.client.Do("GetUser", "POST", "/", req, resp)
	return
}

// GetUserPolicy retrieves the specified policy document for the specified
// user. The returned policy is URL-encoded according to RFC 3986. For more
// information about RFC 3986, go to http://www.faqs.org/rfcs/rfc3986.html
// .
func (c *IAM) GetUserPolicy(req *GetUserPolicyRequest) (resp *GetUserPolicyResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &GetUserPolicyResult{}
	err = c.client.Do("GetUserPolicy", "POST", "/", req, resp)
	return
}

// ListAccessKeys returns information about the access key IDs associated
// with the specified user. If there are none, the action returns an empty
// list. Although each user is limited to a small number of keys, you can
// still paginate the results using the MaxItems and Marker parameters. If
// the UserName field is not specified, the UserName is determined
// implicitly based on the AWS access key ID used to sign the request.
// Because this action works for access keys under the AWS account, you can
// use this action to manage root credentials even if the AWS account has
// no associated users. To ensure the security of your AWS account, the
// secret access key is accessible only during key and user creation.
func (c *IAM) ListAccessKeys(req *ListAccessKeysRequest) (resp *ListAccessKeysResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListAccessKeysResult{}
	err = c.client.Do("ListAccessKeys", "POST", "/", req, resp)
	return
}

// ListAccountAliases lists the account aliases associated with the
// account. For information about using an AWS account alias, see Using an
// Alias for Your AWS Account in the Using guide. You can paginate the
// results using the MaxItems and Marker parameters.
func (c *IAM) ListAccountAliases(req *ListAccountAliasesRequest) (resp *ListAccountAliasesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListAccountAliasesResult{}
	err = c.client.Do("ListAccountAliases", "POST", "/", req, resp)
	return
}

// ListGroupPolicies lists the names of the policies associated with the
// specified group. If there are none, the action returns an empty list.
// You can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListGroupPolicies(req *ListGroupPoliciesRequest) (resp *ListGroupPoliciesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListGroupPoliciesResult{}
	err = c.client.Do("ListGroupPolicies", "POST", "/", req, resp)
	return
}

// ListGroups lists the groups that have the specified path prefix. You can
// paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListGroups(req *ListGroupsRequest) (resp *ListGroupsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListGroupsResult{}
	err = c.client.Do("ListGroups", "POST", "/", req, resp)
	return
}

// ListGroupsForUser lists the groups the specified user belongs to. You
// can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListGroupsForUser(req *ListGroupsForUserRequest) (resp *ListGroupsForUserResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListGroupsForUserResult{}
	err = c.client.Do("ListGroupsForUser", "POST", "/", req, resp)
	return
}

// ListInstanceProfiles lists the instance profiles that have the specified
// path prefix. If there are none, the action returns an empty list. For
// more information about instance profiles, go to About Instance Profiles
// . You can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListInstanceProfiles(req *ListInstanceProfilesRequest) (resp *ListInstanceProfilesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListInstanceProfilesResult{}
	err = c.client.Do("ListInstanceProfiles", "POST", "/", req, resp)
	return
}

// ListInstanceProfilesForRole lists the instance profiles that have the
// specified associated role. If there are none, the action returns an
// empty list. For more information about instance profiles, go to About
// Instance Profiles . You can paginate the results using the MaxItems and
// Marker parameters.
func (c *IAM) ListInstanceProfilesForRole(req *ListInstanceProfilesForRoleRequest) (resp *ListInstanceProfilesForRoleResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListInstanceProfilesForRoleResult{}
	err = c.client.Do("ListInstanceProfilesForRole", "POST", "/", req, resp)
	return
}

// ListMFADevices lists the MFA devices. If the request includes the user
// name, then this action lists all the MFA devices associated with the
// specified user name. If you do not specify a user name, IAM determines
// the user name implicitly based on the AWS access key ID signing the
// request. You can paginate the results using the MaxItems and Marker
// parameters.
func (c *IAM) ListMFADevices(req *ListMFADevicesRequest) (resp *ListMFADevicesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListMFADevicesResult{}
	err = c.client.Do("ListMFADevices", "POST", "/", req, resp)
	return
}

// ListOpenIDConnectProviders lists information about the OpenID Connect
// providers in the AWS account.
func (c *IAM) ListOpenIDConnectProviders(req *ListOpenIDConnectProvidersRequest) (resp *ListOpenIDConnectProvidersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListOpenIDConnectProvidersResult{}
	err = c.client.Do("ListOpenIDConnectProviders", "POST", "/", req, resp)
	return
}

// ListRolePolicies lists the names of the policies associated with the
// specified role. If there are none, the action returns an empty list. You
// can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListRolePolicies(req *ListRolePoliciesRequest) (resp *ListRolePoliciesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListRolePoliciesResult{}
	err = c.client.Do("ListRolePolicies", "POST", "/", req, resp)
	return
}

// ListRoles lists the roles that have the specified path prefix. If there
// are none, the action returns an empty list. For more information about
// roles, go to Working with Roles . You can paginate the results using the
// MaxItems and Marker parameters. The returned policy is URL-encoded
// according to RFC 3986. For more information about RFC 3986, go to
// http://www.faqs.org/rfcs/rfc3986.html .
func (c *IAM) ListRoles(req *ListRolesRequest) (resp *ListRolesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListRolesResult{}
	err = c.client.Do("ListRoles", "POST", "/", req, resp)
	return
}

// ListSAMLProviders is undocumented.
func (c *IAM) ListSAMLProviders(req *ListSAMLProvidersRequest) (resp *ListSAMLProvidersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListSAMLProvidersResult{}
	err = c.client.Do("ListSAMLProviders", "POST", "/", req, resp)
	return
}

// ListServerCertificates lists the server certificates that have the
// specified path prefix. If none exist, the action returns an empty list.
// You can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListServerCertificates(req *ListServerCertificatesRequest) (resp *ListServerCertificatesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListServerCertificatesResult{}
	err = c.client.Do("ListServerCertificates", "POST", "/", req, resp)
	return
}

// ListSigningCertificates returns information about the signing
// certificates associated with the specified user. If there are none, the
// action returns an empty list. Although each user is limited to a small
// number of signing certificates, you can still paginate the results using
// the MaxItems and Marker parameters. If the UserName field is not
// specified, the user name is determined implicitly based on the AWS
// access key ID used to sign the request. Because this action works for
// access keys under the AWS account, you can use this action to manage
// root credentials even if the AWS account has no associated users.
func (c *IAM) ListSigningCertificates(req *ListSigningCertificatesRequest) (resp *ListSigningCertificatesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListSigningCertificatesResult{}
	err = c.client.Do("ListSigningCertificates", "POST", "/", req, resp)
	return
}

// ListUserPolicies lists the names of the policies associated with the
// specified user. If there are none, the action returns an empty list. You
// can paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListUserPolicies(req *ListUserPoliciesRequest) (resp *ListUserPoliciesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListUserPoliciesResult{}
	err = c.client.Do("ListUserPolicies", "POST", "/", req, resp)
	return
}

// ListUsers lists the IAM users that have the specified path prefix. If no
// path prefix is specified, the action returns all users in the AWS
// account. If there are none, the action returns an empty list. You can
// paginate the results using the MaxItems and Marker parameters.
func (c *IAM) ListUsers(req *ListUsersRequest) (resp *ListUsersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListUsersResult{}
	err = c.client.Do("ListUsers", "POST", "/", req, resp)
	return
}

// ListVirtualMFADevices lists the virtual MFA devices under the AWS
// account by assignment status. If you do not specify an assignment
// status, the action returns a list of all virtual MFA devices. Assignment
// status can be Assigned , Unassigned , or Any . You can paginate the
// results using the MaxItems and Marker parameters.
func (c *IAM) ListVirtualMFADevices(req *ListVirtualMFADevicesRequest) (resp *ListVirtualMFADevicesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ListVirtualMFADevicesResult{}
	err = c.client.Do("ListVirtualMFADevices", "POST", "/", req, resp)
	return
}

// PutGroupPolicy adds (or updates) a policy document associated with the
// specified group. For information about policies, refer to Overview of
// Policies in the Using guide. For information about limits on the number
// of policies you can associate with a group, see Limitations on IAM
// Entities in the Using guide. Because policy documents can be large, you
// should use rather than GET when calling PutGroupPolicy . For information
// about setting up signatures and authorization through the go to Signing
// AWS API Requests in the AWS General Reference . For general information
// about using the Query API with go to Making Query Requests in the Using
// guide.
func (c *IAM) PutGroupPolicy(req *PutGroupPolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("PutGroupPolicy", "POST", "/", req, nil)
	return
}

// PutRolePolicy adds (or updates) a policy document associated with the
// specified role. For information about policies, go to Overview of
// Policies in the Using guide. For information about limits on the
// policies you can associate with a role, see Limitations on IAM Entities
// in the Using guide. Because policy documents can be large, you should
// use rather than GET when calling PutRolePolicy . For information about
// setting up signatures and authorization through the go to Signing AWS
// API Requests in the AWS General Reference . For general information
// about using the Query API with go to Making Query Requests in the Using
// guide.
func (c *IAM) PutRolePolicy(req *PutRolePolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("PutRolePolicy", "POST", "/", req, nil)
	return
}

// PutUserPolicy adds (or updates) a policy document associated with the
// specified user. For information about policies, refer to Overview of
// Policies in the Using guide. For information about limits on the number
// of policies you can associate with a user, see Limitations on IAM
// Entities in the Using guide. Because policy documents can be large, you
// should use rather than GET when calling PutUserPolicy . For information
// about setting up signatures and authorization through the go to Signing
// AWS API Requests in the AWS General Reference . For general information
// about using the Query API with go to Making Query Requests in the Using
// guide.
func (c *IAM) PutUserPolicy(req *PutUserPolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("PutUserPolicy", "POST", "/", req, nil)
	return
}

// RemoveClientIDFromOpenIDConnectProvider removes the specified client ID
// (also known as audience) from the list of client IDs registered for the
// specified IAM OpenID Connect provider. This action is idempotent; it
// does not fail or return an error if you try to remove a client ID that
// was removed previously.
func (c *IAM) RemoveClientIDFromOpenIDConnectProvider(req *RemoveClientIDFromOpenIDConnectProviderRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RemoveClientIDFromOpenIDConnectProvider", "POST", "/", req, nil)
	return
}

// RemoveRoleFromInstanceProfile removes the specified role from the
// specified instance profile. Make sure you do not have any Amazon EC2
// instances running with the role you are about to remove from the
// instance profile. Removing a role from an instance profile that is
// associated with a running instance will break any applications running
// on the instance. For more information about roles, go to Working with
// Roles . For more information about instance profiles, go to About
// Instance Profiles .
func (c *IAM) RemoveRoleFromInstanceProfile(req *RemoveRoleFromInstanceProfileRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RemoveRoleFromInstanceProfile", "POST", "/", req, nil)
	return
}

// RemoveUserFromGroup removes the specified user from the specified group.
func (c *IAM) RemoveUserFromGroup(req *RemoveUserFromGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RemoveUserFromGroup", "POST", "/", req, nil)
	return
}

// ResyncMFADevice synchronizes the specified MFA device with AWS servers.
// For more information about creating and working with virtual MFA
// devices, go to Using a Virtual MFA Device in the Using guide.
func (c *IAM) ResyncMFADevice(req *ResyncMFADeviceRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("ResyncMFADevice", "POST", "/", req, nil)
	return
}

// UpdateAccessKey changes the status of the specified access key from
// Active to Inactive, or vice versa. This action can be used to disable a
// user's key as part of a key rotation work flow. If the UserName field is
// not specified, the UserName is determined implicitly based on the AWS
// access key ID used to sign the request. Because this action works for
// access keys under the AWS account, you can use this action to manage
// root credentials even if the AWS account has no associated users. For
// information about rotating keys, see Managing Keys and Certificates in
// the Using guide.
func (c *IAM) UpdateAccessKey(req *UpdateAccessKeyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateAccessKey", "POST", "/", req, nil)
	return
}

// UpdateAccountPasswordPolicy updates the password policy settings for the
// AWS account. This action does not support partial updates. No parameters
// are required, but if you do not specify a parameter, that parameter's
// value reverts to its default value. See the Request Parameters section
// for each parameter's default value. For more information about using a
// password policy, see Managing an IAM Password Policy in the Using guide.
func (c *IAM) UpdateAccountPasswordPolicy(req *UpdateAccountPasswordPolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateAccountPasswordPolicy", "POST", "/", req, nil)
	return
}

// UpdateAssumeRolePolicy updates the policy that grants an entity
// permission to assume a role. For more information about roles, go to
// Working with Roles .
func (c *IAM) UpdateAssumeRolePolicy(req *UpdateAssumeRolePolicyRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateAssumeRolePolicy", "POST", "/", req, nil)
	return
}

// UpdateGroup updates the name and/or the path of the specified group. You
// should understand the implications of changing a group's path or name.
// For more information, see Renaming Users and Groups in the Using guide.
// To change a group name the requester must have appropriate permissions
// on both the source object and the target object. For example, to change
// Managers to MGRs, the entity making the request must have permission on
// Managers and MGRs, or must have permission on all For more information
// about permissions, see Permissions and Policies .
func (c *IAM) UpdateGroup(req *UpdateGroupRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateGroup", "POST", "/", req, nil)
	return
}

// UpdateLoginProfile changes the password for the specified user. Users
// can change their own passwords by calling ChangePassword . For more
// information about modifying passwords, see Managing Passwords in the
// Using guide.
func (c *IAM) UpdateLoginProfile(req *UpdateLoginProfileRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateLoginProfile", "POST", "/", req, nil)
	return
}

// UpdateOpenIDConnectProviderThumbprint replaces the existing list of
// server certificate thumbprints with a new list. The list that you pass
// with this action completely replaces the existing list of thumbprints.
// (The lists are not merged.) Typically, you need to update a thumbprint
// only when the identity provider's certificate changes, which occurs
// rarely. However, if the provider's certificate does change, any attempt
// to assume an IAM role that specifies the IAM provider as a principal
// will fail until the certificate thumbprint is updated. Because trust for
// the OpenID Connect provider is ultimately derived from the provider's
// certificate and is validated by the thumbprint, it is a best practice to
// limit access to the UpdateOpenIDConnectProviderThumbprint action to
// highly-privileged users.
func (c *IAM) UpdateOpenIDConnectProviderThumbprint(req *UpdateOpenIDConnectProviderThumbprintRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateOpenIDConnectProviderThumbprint", "POST", "/", req, nil)
	return
}

// UpdateSAMLProvider updates the metadata document for an existing
// provider. This operation requires Signature Version 4 .
func (c *IAM) UpdateSAMLProvider(req *UpdateSAMLProviderRequest) (resp *UpdateSAMLProviderResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateSAMLProviderResult{}
	err = c.client.Do("UpdateSAMLProvider", "POST", "/", req, resp)
	return
}

// UpdateServerCertificate updates the name and/or the path of the
// specified server certificate. You should understand the implications of
// changing a server certificate's path or name. For more information, see
// Managing Server Certificates in the Using guide. To change a server
// certificate name the requester must have appropriate permissions on both
// the source object and the target object. For example, to change the name
// from ProductionCert to ProdCert, the entity making the request must have
// permission on ProductionCert and ProdCert, or must have permission on
// all For more information about permissions, see Permissions and Policies
// .
func (c *IAM) UpdateServerCertificate(req *UpdateServerCertificateRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateServerCertificate", "POST", "/", req, nil)
	return
}

// UpdateSigningCertificate changes the status of the specified signing
// certificate from active to disabled, or vice versa. This action can be
// used to disable a user's signing certificate as part of a certificate
// rotation work flow. If the UserName field is not specified, the UserName
// is determined implicitly based on the AWS access key ID used to sign the
// request. Because this action works for access keys under the AWS
// account, you can use this action to manage root credentials even if the
// AWS account has no associated users. For information about rotating
// certificates, see Managing Keys and Certificates in the Using guide.
func (c *IAM) UpdateSigningCertificate(req *UpdateSigningCertificateRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateSigningCertificate", "POST", "/", req, nil)
	return
}

// UpdateUser updates the name and/or the path of the specified user. You
// should understand the implications of changing a user's path or name.
// For more information, see Renaming Users and Groups in the Using guide.
// To change a user name the requester must have appropriate permissions on
// both the source object and the target object. For example, to change Bob
// to Robert, the entity making the request must have permission on Bob and
// Robert, or must have permission on all For more information about
// permissions, see Permissions and Policies .
func (c *IAM) UpdateUser(req *UpdateUserRequest) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("UpdateUser", "POST", "/", req, nil)
	return
}

// UploadServerCertificate uploads a server certificate entity for the AWS
// account. The server certificate entity includes a public key
// certificate, a private key, and an optional certificate chain, which
// should all be PEM-encoded. For information about the number of server
// certificates you can upload, see Limitations on IAM Entities in the
// Using guide. Because the body of the public key certificate, private
// key, and the certificate chain can be large, you should use rather than
// GET when calling UploadServerCertificate . For information about setting
// up signatures and authorization through the go to Signing AWS API
// Requests in the AWS General Reference . For general information about
// using the Query API with go to Making Query Requests in the Using guide.
func (c *IAM) UploadServerCertificate(req *UploadServerCertificateRequest) (resp *UploadServerCertificateResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UploadServerCertificateResult{}
	err = c.client.Do("UploadServerCertificate", "POST", "/", req, resp)
	return
}

// UploadSigningCertificate uploads an X.509 signing certificate and
// associates it with the specified user. Some AWS services use X.509
// signing certificates to validate requests that are signed with a
// corresponding private key. When you upload the certificate, its default
// status is Active . If the UserName field is not specified, the user name
// is determined implicitly based on the AWS access key ID used to sign the
// request. Because this action works for access keys under the AWS
// account, you can use this action to manage root credentials even if the
// AWS account has no associated users. Because the body of a X.509
// certificate can be large, you should use rather than GET when calling
// UploadSigningCertificate . For information about setting up signatures
// and authorization through the go to Signing AWS API Requests in the AWS
// General Reference . For general information about using the Query API
// with go to Making Query Requests in the Using guide.
func (c *IAM) UploadSigningCertificate(req *UploadSigningCertificateRequest) (resp *UploadSigningCertificateResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UploadSigningCertificateResult{}
	err = c.client.Do("UploadSigningCertificate", "POST", "/", req, resp)
	return
}

// AccessKey is undocumented.
type AccessKey struct {
	AccessKeyID     aws.StringValue `xml:"AccessKeyId"`
	CreateDate      time.Time       `xml:"CreateDate"`
	SecretAccessKey aws.StringValue `xml:"SecretAccessKey"`
	Status          aws.StringValue `xml:"Status"`
	UserName        aws.StringValue `xml:"UserName"`
}

func (v *AccessKey) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessKeyID"); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMin(v, "AccessKeyID", 16); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMax(v, "AccessKeyID", 32); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidatePattern(v, "AccessKeyID", `[\w]*`); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateRequired(v, "SecretAccessKey"); err != nil {
		errors["SecretAccessKey"] = append(errors["SecretAccessKey"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	StatusEnum := []string{
		StatusTypeActive,
		StatusTypeInactive,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AccessKeyMetadata is undocumented.
type AccessKeyMetadata struct {
	AccessKeyID aws.StringValue `xml:"AccessKeyId"`
	CreateDate  time.Time       `xml:"CreateDate"`
	Status      aws.StringValue `xml:"Status"`
	UserName    aws.StringValue `xml:"UserName"`
}

func (v *AccessKeyMetadata) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "AccessKeyID", 16); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMax(v, "AccessKeyID", 32); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidatePattern(v, "AccessKeyID", `[\w]*`); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	StatusEnum := []string{
		StatusTypeActive,
		StatusTypeInactive,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddClientIDToOpenIDConnectProviderRequest is undocumented.
type AddClientIDToOpenIDConnectProviderRequest struct {
	ClientID                 aws.StringValue `xml:"ClientID"`
	OpenIDConnectProviderARN aws.StringValue `xml:"OpenIDConnectProviderArn"`
}

func (v *AddClientIDToOpenIDConnectProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClientID"); err != nil {
		errors["ClientID"] = append(errors["ClientID"], err)
	}

	if err := model.ValidateMin(v, "ClientID", 1); err != nil {
		errors["ClientID"] = append(errors["ClientID"], err)
	}

	if err := model.ValidateMax(v, "ClientID", 255); err != nil {
		errors["ClientID"] = append(errors["ClientID"], err)
	}

	if err := model.ValidateRequired(v, "OpenIDConnectProviderARN"); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMin(v, "OpenIDConnectProviderARN", 20); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMax(v, "OpenIDConnectProviderARN", 2048); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddRoleToInstanceProfileRequest is undocumented.
type AddRoleToInstanceProfileRequest struct {
	InstanceProfileName aws.StringValue `xml:"InstanceProfileName"`
	RoleName            aws.StringValue `xml:"RoleName"`
}

func (v *AddRoleToInstanceProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfileName"); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileName", 1); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileName", 128); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileName", `[\w+=,.@-]*`); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AddUserToGroupRequest is undocumented.
type AddUserToGroupRequest struct {
	GroupName aws.StringValue `xml:"GroupName"`
	UserName  aws.StringValue `xml:"UserName"`
}

func (v *AddUserToGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChangePasswordRequest is undocumented.
type ChangePasswordRequest struct {
	NewPassword aws.StringValue `xml:"NewPassword"`
	OldPassword aws.StringValue `xml:"OldPassword"`
}

func (v *ChangePasswordRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "NewPassword"); err != nil {
		errors["NewPassword"] = append(errors["NewPassword"], err)
	}

	if err := model.ValidateMin(v, "NewPassword", 1); err != nil {
		errors["NewPassword"] = append(errors["NewPassword"], err)
	}

	if err := model.ValidateMax(v, "NewPassword", 128); err != nil {
		errors["NewPassword"] = append(errors["NewPassword"], err)
	}

	if err := model.ValidatePattern(v, "NewPassword", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["NewPassword"] = append(errors["NewPassword"], err)
	}

	if err := model.ValidateRequired(v, "OldPassword"); err != nil {
		errors["OldPassword"] = append(errors["OldPassword"], err)
	}

	if err := model.ValidateMin(v, "OldPassword", 1); err != nil {
		errors["OldPassword"] = append(errors["OldPassword"], err)
	}

	if err := model.ValidateMax(v, "OldPassword", 128); err != nil {
		errors["OldPassword"] = append(errors["OldPassword"], err)
	}

	if err := model.ValidatePattern(v, "OldPassword", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["OldPassword"] = append(errors["OldPassword"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateAccessKeyRequest is undocumented.
type CreateAccessKeyRequest struct {
	UserName aws.StringValue `xml:"UserName"`
}

func (v *CreateAccessKeyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateAccessKeyResponse is undocumented.
type CreateAccessKeyResponse struct {
	AccessKey *AccessKey `xml:"CreateAccessKeyResult>AccessKey"`
}

func (v *CreateAccessKeyResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessKey"); err != nil {
		errors["AccessKey"] = append(errors["AccessKey"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateAccountAliasRequest is undocumented.
type CreateAccountAliasRequest struct {
	AccountAlias aws.StringValue `xml:"AccountAlias"`
}

func (v *CreateAccountAliasRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccountAlias"); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if err := model.ValidateMin(v, "AccountAlias", 3); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if err := model.ValidateMax(v, "AccountAlias", 63); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if err := model.ValidatePattern(v, "AccountAlias", `^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$`); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateGroupRequest is undocumented.
type CreateGroupRequest struct {
	GroupName aws.StringValue `xml:"GroupName"`
	Path      aws.StringValue `xml:"Path"`
}

func (v *CreateGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateGroupResponse is undocumented.
type CreateGroupResponse struct {
	Group *Group `xml:"CreateGroupResult>Group"`
}

func (v *CreateGroupResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Group"); err != nil {
		errors["Group"] = append(errors["Group"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInstanceProfileRequest is undocumented.
type CreateInstanceProfileRequest struct {
	InstanceProfileName aws.StringValue `xml:"InstanceProfileName"`
	Path                aws.StringValue `xml:"Path"`
}

func (v *CreateInstanceProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfileName"); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileName", 1); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileName", 128); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileName", `[\w+=,.@-]*`); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateInstanceProfileResponse is undocumented.
type CreateInstanceProfileResponse struct {
	InstanceProfile *InstanceProfile `xml:"CreateInstanceProfileResult>InstanceProfile"`
}

func (v *CreateInstanceProfileResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfile"); err != nil {
		errors["InstanceProfile"] = append(errors["InstanceProfile"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateLoginProfileRequest is undocumented.
type CreateLoginProfileRequest struct {
	Password              aws.StringValue  `xml:"Password"`
	PasswordResetRequired aws.BooleanValue `xml:"PasswordResetRequired"`
	UserName              aws.StringValue  `xml:"UserName"`
}

func (v *CreateLoginProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Password"); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidateMin(v, "Password", 1); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidateMax(v, "Password", 128); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidatePattern(v, "Password", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateLoginProfileResponse is undocumented.
type CreateLoginProfileResponse struct {
	LoginProfile *LoginProfile `xml:"CreateLoginProfileResult>LoginProfile"`
}

func (v *CreateLoginProfileResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "LoginProfile"); err != nil {
		errors["LoginProfile"] = append(errors["LoginProfile"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateOpenIDConnectProviderRequest is undocumented.
type CreateOpenIDConnectProviderRequest struct {
	ClientIDList   []string        `xml:"ClientIDList>member"`
	ThumbprintList []string        `xml:"ThumbprintList>member"`
	URL            aws.StringValue `xml:"Url"`
}

func (v *CreateOpenIDConnectProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ThumbprintList"); err != nil {
		errors["ThumbprintList"] = append(errors["ThumbprintList"], err)
	}

	if err := model.ValidateRequired(v, "URL"); err != nil {
		errors["URL"] = append(errors["URL"], err)
	}

	if err := model.ValidateMin(v, "URL", 1); err != nil {
		errors["URL"] = append(errors["URL"], err)
	}

	if err := model.ValidateMax(v, "URL", 255); err != nil {
		errors["URL"] = append(errors["URL"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateOpenIDConnectProviderResponse is undocumented.
type CreateOpenIDConnectProviderResponse struct {
	OpenIDConnectProviderARN aws.StringValue `xml:"CreateOpenIDConnectProviderResult>OpenIDConnectProviderArn"`
}

func (v *CreateOpenIDConnectProviderResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "OpenIDConnectProviderARN", 20); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMax(v, "OpenIDConnectProviderARN", 2048); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateRoleRequest is undocumented.
type CreateRoleRequest struct {
	AssumeRolePolicyDocument aws.StringValue `xml:"AssumeRolePolicyDocument"`
	Path                     aws.StringValue `xml:"Path"`
	RoleName                 aws.StringValue `xml:"RoleName"`
}

func (v *CreateRoleRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AssumeRolePolicyDocument"); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "AssumeRolePolicyDocument", 1); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "AssumeRolePolicyDocument", 131072); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "AssumeRolePolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateRoleResponse is undocumented.
type CreateRoleResponse struct {
	Role *Role `xml:"CreateRoleResult>Role"`
}

func (v *CreateRoleResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Role"); err != nil {
		errors["Role"] = append(errors["Role"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSAMLProviderRequest is undocumented.
type CreateSAMLProviderRequest struct {
	Name                 aws.StringValue `xml:"Name"`
	SAMLMetadataDocument aws.StringValue `xml:"SAMLMetadataDocument"`
}

func (v *CreateSAMLProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 128); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidatePattern(v, "Name", `[\w._-]*`); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "SAMLMetadataDocument"); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if err := model.ValidateMin(v, "SAMLMetadataDocument", 1000); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if err := model.ValidateMax(v, "SAMLMetadataDocument", 10000000); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateSAMLProviderResponse is undocumented.
type CreateSAMLProviderResponse struct {
	SAMLProviderARN aws.StringValue `xml:"CreateSAMLProviderResult>SAMLProviderArn"`
}

func (v *CreateSAMLProviderResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "SAMLProviderARN", 20); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMax(v, "SAMLProviderARN", 2048); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateUserRequest is undocumented.
type CreateUserRequest struct {
	Path     aws.StringValue `xml:"Path"`
	UserName aws.StringValue `xml:"UserName"`
}

func (v *CreateUserRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateUserResponse is undocumented.
type CreateUserResponse struct {
	User *User `xml:"CreateUserResult>User"`
}

func (v *CreateUserResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVirtualMFADeviceRequest is undocumented.
type CreateVirtualMFADeviceRequest struct {
	Path                 aws.StringValue `xml:"Path"`
	VirtualMFADeviceName aws.StringValue `xml:"VirtualMFADeviceName"`
}

func (v *CreateVirtualMFADeviceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "VirtualMFADeviceName"); err != nil {
		errors["VirtualMFADeviceName"] = append(errors["VirtualMFADeviceName"], err)
	}

	if err := model.ValidateMin(v, "VirtualMFADeviceName", 1); err != nil {
		errors["VirtualMFADeviceName"] = append(errors["VirtualMFADeviceName"], err)
	}

	if err := model.ValidatePattern(v, "VirtualMFADeviceName", `[\w+=,.@-]*`); err != nil {
		errors["VirtualMFADeviceName"] = append(errors["VirtualMFADeviceName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateVirtualMFADeviceResponse is undocumented.
type CreateVirtualMFADeviceResponse struct {
	VirtualMFADevice *VirtualMFADevice `xml:"CreateVirtualMFADeviceResult>VirtualMFADevice"`
}

func (v *CreateVirtualMFADeviceResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "VirtualMFADevice"); err != nil {
		errors["VirtualMFADevice"] = append(errors["VirtualMFADevice"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeactivateMFADeviceRequest is undocumented.
type DeactivateMFADeviceRequest struct {
	SerialNumber aws.StringValue `xml:"SerialNumber"`
	UserName     aws.StringValue `xml:"UserName"`
}

func (v *DeactivateMFADeviceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SerialNumber"); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMin(v, "SerialNumber", 9); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMax(v, "SerialNumber", 256); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidatePattern(v, "SerialNumber", `[\w+=/:,.@-]*`); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteAccessKeyRequest is undocumented.
type DeleteAccessKeyRequest struct {
	AccessKeyID aws.StringValue `xml:"AccessKeyId"`
	UserName    aws.StringValue `xml:"UserName"`
}

func (v *DeleteAccessKeyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessKeyID"); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMin(v, "AccessKeyID", 16); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMax(v, "AccessKeyID", 32); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidatePattern(v, "AccessKeyID", `[\w]*`); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteAccountAliasRequest is undocumented.
type DeleteAccountAliasRequest struct {
	AccountAlias aws.StringValue `xml:"AccountAlias"`
}

func (v *DeleteAccountAliasRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccountAlias"); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if err := model.ValidateMin(v, "AccountAlias", 3); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if err := model.ValidateMax(v, "AccountAlias", 63); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if err := model.ValidatePattern(v, "AccountAlias", `^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$`); err != nil {
		errors["AccountAlias"] = append(errors["AccountAlias"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteGroupPolicyRequest is undocumented.
type DeleteGroupPolicyRequest struct {
	GroupName  aws.StringValue `xml:"GroupName"`
	PolicyName aws.StringValue `xml:"PolicyName"`
}

func (v *DeleteGroupPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteGroupRequest is undocumented.
type DeleteGroupRequest struct {
	GroupName aws.StringValue `xml:"GroupName"`
}

func (v *DeleteGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteInstanceProfileRequest is undocumented.
type DeleteInstanceProfileRequest struct {
	InstanceProfileName aws.StringValue `xml:"InstanceProfileName"`
}

func (v *DeleteInstanceProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfileName"); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileName", 1); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileName", 128); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileName", `[\w+=,.@-]*`); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteLoginProfileRequest is undocumented.
type DeleteLoginProfileRequest struct {
	UserName aws.StringValue `xml:"UserName"`
}

func (v *DeleteLoginProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteOpenIDConnectProviderRequest is undocumented.
type DeleteOpenIDConnectProviderRequest struct {
	OpenIDConnectProviderARN aws.StringValue `xml:"OpenIDConnectProviderArn"`
}

func (v *DeleteOpenIDConnectProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "OpenIDConnectProviderARN"); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMin(v, "OpenIDConnectProviderARN", 20); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMax(v, "OpenIDConnectProviderARN", 2048); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteRolePolicyRequest is undocumented.
type DeleteRolePolicyRequest struct {
	PolicyName aws.StringValue `xml:"PolicyName"`
	RoleName   aws.StringValue `xml:"RoleName"`
}

func (v *DeleteRolePolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteRoleRequest is undocumented.
type DeleteRoleRequest struct {
	RoleName aws.StringValue `xml:"RoleName"`
}

func (v *DeleteRoleRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSAMLProviderRequest is undocumented.
type DeleteSAMLProviderRequest struct {
	SAMLProviderARN aws.StringValue `xml:"SAMLProviderArn"`
}

func (v *DeleteSAMLProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SAMLProviderARN"); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMin(v, "SAMLProviderARN", 20); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMax(v, "SAMLProviderARN", 2048); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteServerCertificateRequest is undocumented.
type DeleteServerCertificateRequest struct {
	ServerCertificateName aws.StringValue `xml:"ServerCertificateName"`
}

func (v *DeleteServerCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ServerCertificateName"); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMin(v, "ServerCertificateName", 1); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMax(v, "ServerCertificateName", 128); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidatePattern(v, "ServerCertificateName", `[\w+=,.@-]*`); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSigningCertificateRequest is undocumented.
type DeleteSigningCertificateRequest struct {
	CertificateID aws.StringValue `xml:"CertificateId"`
	UserName      aws.StringValue `xml:"UserName"`
}

func (v *DeleteSigningCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CertificateID"); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMin(v, "CertificateID", 24); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMax(v, "CertificateID", 128); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidatePattern(v, "CertificateID", `[\w]*`); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteUserPolicyRequest is undocumented.
type DeleteUserPolicyRequest struct {
	PolicyName aws.StringValue `xml:"PolicyName"`
	UserName   aws.StringValue `xml:"UserName"`
}

func (v *DeleteUserPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteUserRequest is undocumented.
type DeleteUserRequest struct {
	UserName aws.StringValue `xml:"UserName"`
}

func (v *DeleteUserRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteVirtualMFADeviceRequest is undocumented.
type DeleteVirtualMFADeviceRequest struct {
	SerialNumber aws.StringValue `xml:"SerialNumber"`
}

func (v *DeleteVirtualMFADeviceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SerialNumber"); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMin(v, "SerialNumber", 9); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMax(v, "SerialNumber", 256); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidatePattern(v, "SerialNumber", `[\w+=/:,.@-]*`); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// EnableMFADeviceRequest is undocumented.
type EnableMFADeviceRequest struct {
	AuthenticationCode1 aws.StringValue `xml:"AuthenticationCode1"`
	AuthenticationCode2 aws.StringValue `xml:"AuthenticationCode2"`
	SerialNumber        aws.StringValue `xml:"SerialNumber"`
	UserName            aws.StringValue `xml:"UserName"`
}

func (v *EnableMFADeviceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AuthenticationCode1"); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidateMin(v, "AuthenticationCode1", 6); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidateMax(v, "AuthenticationCode1", 6); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidatePattern(v, "AuthenticationCode1", `[\d]*`); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidateRequired(v, "AuthenticationCode2"); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidateMin(v, "AuthenticationCode2", 6); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidateMax(v, "AuthenticationCode2", 6); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidatePattern(v, "AuthenticationCode2", `[\d]*`); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidateRequired(v, "SerialNumber"); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMin(v, "SerialNumber", 9); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMax(v, "SerialNumber", 256); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidatePattern(v, "SerialNumber", `[\w+=/:,.@-]*`); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for IAM.
const (
	EntityTypeGroup = "Group"
	EntityTypeRole  = "Role"
	EntityTypeUser  = "User"
)

// GenerateCredentialReportResponse is undocumented.
type GenerateCredentialReportResponse struct {
	Description aws.StringValue `xml:"GenerateCredentialReportResult>Description"`
	State       aws.StringValue `xml:"GenerateCredentialReportResult>State"`
}

func (v *GenerateCredentialReportResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	StateEnum := []string{
		ReportStateTypeComplete,
		ReportStateTypeInprogress,
		ReportStateTypeStarted,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetAccountAuthorizationDetailsRequest is undocumented.
type GetAccountAuthorizationDetailsRequest struct {
	Filter   []string         `xml:"Filter>member"`
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
}

func (v *GetAccountAuthorizationDetailsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetAccountAuthorizationDetailsResponse is undocumented.
type GetAccountAuthorizationDetailsResponse struct {
	GroupDetailList []GroupDetail    `xml:"GetAccountAuthorizationDetailsResult>GroupDetailList>member"`
	IsTruncated     aws.BooleanValue `xml:"GetAccountAuthorizationDetailsResult>IsTruncated"`
	Marker          aws.StringValue  `xml:"GetAccountAuthorizationDetailsResult>Marker"`
	RoleDetailList  []RoleDetail     `xml:"GetAccountAuthorizationDetailsResult>RoleDetailList>member"`
	UserDetailList  []UserDetail     `xml:"GetAccountAuthorizationDetailsResult>UserDetailList>member"`
}

func (v *GetAccountAuthorizationDetailsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetAccountPasswordPolicyResponse is undocumented.
type GetAccountPasswordPolicyResponse struct {
	PasswordPolicy *PasswordPolicy `xml:"GetAccountPasswordPolicyResult>PasswordPolicy"`
}

func (v *GetAccountPasswordPolicyResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PasswordPolicy"); err != nil {
		errors["PasswordPolicy"] = append(errors["PasswordPolicy"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetAccountSummaryResponse is undocumented.
type GetAccountSummaryResponse struct {
	SummaryMap map[string]int `xml:"GetAccountSummaryResult>SummaryMap"`
}

func (v *GetAccountSummaryResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetCredentialReportResponse is undocumented.
type GetCredentialReportResponse struct {
	Content       []byte          `xml:"GetCredentialReportResult>Content"`
	GeneratedTime time.Time       `xml:"GetCredentialReportResult>GeneratedTime"`
	ReportFormat  aws.StringValue `xml:"GetCredentialReportResult>ReportFormat"`
}

func (v *GetCredentialReportResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	ReportFormatEnum := []string{
		ReportFormatTypeTextCSV,
	}
	if err := model.ValidateEnum(v, "ReportFormat", ReportFormatEnum); err != nil {
		errors["ReportFormat"] = append(errors["ReportFormat"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetGroupPolicyRequest is undocumented.
type GetGroupPolicyRequest struct {
	GroupName  aws.StringValue `xml:"GroupName"`
	PolicyName aws.StringValue `xml:"PolicyName"`
}

func (v *GetGroupPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetGroupPolicyResponse is undocumented.
type GetGroupPolicyResponse struct {
	GroupName      aws.StringValue `xml:"GetGroupPolicyResult>GroupName"`
	PolicyDocument aws.StringValue `xml:"GetGroupPolicyResult>PolicyDocument"`
	PolicyName     aws.StringValue `xml:"GetGroupPolicyResult>PolicyName"`
}

func (v *GetGroupPolicyResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetGroupRequest is undocumented.
type GetGroupRequest struct {
	GroupName aws.StringValue  `xml:"GroupName"`
	Marker    aws.StringValue  `xml:"Marker"`
	MaxItems  aws.IntegerValue `xml:"MaxItems"`
}

func (v *GetGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetGroupResponse is undocumented.
type GetGroupResponse struct {
	Group       *Group           `xml:"GetGroupResult>Group"`
	IsTruncated aws.BooleanValue `xml:"GetGroupResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"GetGroupResult>Marker"`
	Users       []User           `xml:"GetGroupResult>Users>member"`
}

func (v *GetGroupResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Group"); err != nil {
		errors["Group"] = append(errors["Group"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "Users"); err != nil {
		errors["Users"] = append(errors["Users"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetInstanceProfileRequest is undocumented.
type GetInstanceProfileRequest struct {
	InstanceProfileName aws.StringValue `xml:"InstanceProfileName"`
}

func (v *GetInstanceProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfileName"); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileName", 1); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileName", 128); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileName", `[\w+=,.@-]*`); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetInstanceProfileResponse is undocumented.
type GetInstanceProfileResponse struct {
	InstanceProfile *InstanceProfile `xml:"GetInstanceProfileResult>InstanceProfile"`
}

func (v *GetInstanceProfileResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfile"); err != nil {
		errors["InstanceProfile"] = append(errors["InstanceProfile"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetLoginProfileRequest is undocumented.
type GetLoginProfileRequest struct {
	UserName aws.StringValue `xml:"UserName"`
}

func (v *GetLoginProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetLoginProfileResponse is undocumented.
type GetLoginProfileResponse struct {
	LoginProfile *LoginProfile `xml:"GetLoginProfileResult>LoginProfile"`
}

func (v *GetLoginProfileResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "LoginProfile"); err != nil {
		errors["LoginProfile"] = append(errors["LoginProfile"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetOpenIDConnectProviderRequest is undocumented.
type GetOpenIDConnectProviderRequest struct {
	OpenIDConnectProviderARN aws.StringValue `xml:"OpenIDConnectProviderArn"`
}

func (v *GetOpenIDConnectProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "OpenIDConnectProviderARN"); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMin(v, "OpenIDConnectProviderARN", 20); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMax(v, "OpenIDConnectProviderARN", 2048); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetOpenIDConnectProviderResponse is undocumented.
type GetOpenIDConnectProviderResponse struct {
	ClientIDList   []string        `xml:"GetOpenIDConnectProviderResult>ClientIDList>member"`
	CreateDate     time.Time       `xml:"GetOpenIDConnectProviderResult>CreateDate"`
	ThumbprintList []string        `xml:"GetOpenIDConnectProviderResult>ThumbprintList>member"`
	URL            aws.StringValue `xml:"GetOpenIDConnectProviderResult>Url"`
}

func (v *GetOpenIDConnectProviderResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "URL", 1); err != nil {
		errors["URL"] = append(errors["URL"], err)
	}

	if err := model.ValidateMax(v, "URL", 255); err != nil {
		errors["URL"] = append(errors["URL"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetRolePolicyRequest is undocumented.
type GetRolePolicyRequest struct {
	PolicyName aws.StringValue `xml:"PolicyName"`
	RoleName   aws.StringValue `xml:"RoleName"`
}

func (v *GetRolePolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetRolePolicyResponse is undocumented.
type GetRolePolicyResponse struct {
	PolicyDocument aws.StringValue `xml:"GetRolePolicyResult>PolicyDocument"`
	PolicyName     aws.StringValue `xml:"GetRolePolicyResult>PolicyName"`
	RoleName       aws.StringValue `xml:"GetRolePolicyResult>RoleName"`
}

func (v *GetRolePolicyResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetRoleRequest is undocumented.
type GetRoleRequest struct {
	RoleName aws.StringValue `xml:"RoleName"`
}

func (v *GetRoleRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetRoleResponse is undocumented.
type GetRoleResponse struct {
	Role *Role `xml:"GetRoleResult>Role"`
}

func (v *GetRoleResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Role"); err != nil {
		errors["Role"] = append(errors["Role"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetSAMLProviderRequest is undocumented.
type GetSAMLProviderRequest struct {
	SAMLProviderARN aws.StringValue `xml:"SAMLProviderArn"`
}

func (v *GetSAMLProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SAMLProviderARN"); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMin(v, "SAMLProviderARN", 20); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMax(v, "SAMLProviderARN", 2048); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetSAMLProviderResponse is undocumented.
type GetSAMLProviderResponse struct {
	CreateDate           time.Time       `xml:"GetSAMLProviderResult>CreateDate"`
	SAMLMetadataDocument aws.StringValue `xml:"GetSAMLProviderResult>SAMLMetadataDocument"`
	ValidUntil           time.Time       `xml:"GetSAMLProviderResult>ValidUntil"`
}

func (v *GetSAMLProviderResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "SAMLMetadataDocument", 1000); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if err := model.ValidateMax(v, "SAMLMetadataDocument", 10000000); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetServerCertificateRequest is undocumented.
type GetServerCertificateRequest struct {
	ServerCertificateName aws.StringValue `xml:"ServerCertificateName"`
}

func (v *GetServerCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ServerCertificateName"); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMin(v, "ServerCertificateName", 1); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMax(v, "ServerCertificateName", 128); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidatePattern(v, "ServerCertificateName", `[\w+=,.@-]*`); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetServerCertificateResponse is undocumented.
type GetServerCertificateResponse struct {
	ServerCertificate *ServerCertificate `xml:"GetServerCertificateResult>ServerCertificate"`
}

func (v *GetServerCertificateResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ServerCertificate"); err != nil {
		errors["ServerCertificate"] = append(errors["ServerCertificate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetUserPolicyRequest is undocumented.
type GetUserPolicyRequest struct {
	PolicyName aws.StringValue `xml:"PolicyName"`
	UserName   aws.StringValue `xml:"UserName"`
}

func (v *GetUserPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetUserPolicyResponse is undocumented.
type GetUserPolicyResponse struct {
	PolicyDocument aws.StringValue `xml:"GetUserPolicyResult>PolicyDocument"`
	PolicyName     aws.StringValue `xml:"GetUserPolicyResult>PolicyName"`
	UserName       aws.StringValue `xml:"GetUserPolicyResult>UserName"`
}

func (v *GetUserPolicyResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetUserRequest is undocumented.
type GetUserRequest struct {
	UserName aws.StringValue `xml:"UserName"`
}

func (v *GetUserRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetUserResponse is undocumented.
type GetUserResponse struct {
	User *User `xml:"GetUserResult>User"`
}

func (v *GetUserResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "User"); err != nil {
		errors["User"] = append(errors["User"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Group is undocumented.
type Group struct {
	ARN        aws.StringValue `xml:"Arn"`
	CreateDate time.Time       `xml:"CreateDate"`
	GroupID    aws.StringValue `xml:"GroupId"`
	GroupName  aws.StringValue `xml:"GroupName"`
	Path       aws.StringValue `xml:"Path"`
}

func (v *Group) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ARN"); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateRequired(v, "CreateDate"); err != nil {
		errors["CreateDate"] = append(errors["CreateDate"], err)
	}

	if err := model.ValidateRequired(v, "GroupID"); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidateMin(v, "GroupID", 16); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidateMax(v, "GroupID", 32); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidatePattern(v, "GroupID", `[\w]*`); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "Path"); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GroupDetail is undocumented.
type GroupDetail struct {
	ARN             aws.StringValue `xml:"Arn"`
	CreateDate      time.Time       `xml:"CreateDate"`
	GroupID         aws.StringValue `xml:"GroupId"`
	GroupName       aws.StringValue `xml:"GroupName"`
	GroupPolicyList []PolicyDetail  `xml:"GroupPolicyList>member"`
	Path            aws.StringValue `xml:"Path"`
}

func (v *GroupDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "GroupID", 16); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidateMax(v, "GroupID", 32); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidatePattern(v, "GroupID", `[\w]*`); err != nil {
		errors["GroupID"] = append(errors["GroupID"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// InstanceProfile is undocumented.
type InstanceProfile struct {
	ARN                 aws.StringValue `xml:"Arn"`
	CreateDate          time.Time       `xml:"CreateDate"`
	InstanceProfileID   aws.StringValue `xml:"InstanceProfileId"`
	InstanceProfileName aws.StringValue `xml:"InstanceProfileName"`
	Path                aws.StringValue `xml:"Path"`
	Roles               []Role          `xml:"Roles>member"`
}

func (v *InstanceProfile) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ARN"); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateRequired(v, "CreateDate"); err != nil {
		errors["CreateDate"] = append(errors["CreateDate"], err)
	}

	if err := model.ValidateRequired(v, "InstanceProfileID"); err != nil {
		errors["InstanceProfileID"] = append(errors["InstanceProfileID"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileID", 16); err != nil {
		errors["InstanceProfileID"] = append(errors["InstanceProfileID"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileID", 32); err != nil {
		errors["InstanceProfileID"] = append(errors["InstanceProfileID"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileID", `[\w]*`); err != nil {
		errors["InstanceProfileID"] = append(errors["InstanceProfileID"], err)
	}

	if err := model.ValidateRequired(v, "InstanceProfileName"); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileName", 1); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileName", 128); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileName", `[\w+=,.@-]*`); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateRequired(v, "Path"); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "Roles"); err != nil {
		errors["Roles"] = append(errors["Roles"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListAccessKeysRequest is undocumented.
type ListAccessKeysRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	UserName aws.StringValue  `xml:"UserName"`
}

func (v *ListAccessKeysRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListAccessKeysResponse is undocumented.
type ListAccessKeysResponse struct {
	AccessKeyMetadata []AccessKeyMetadata `xml:"ListAccessKeysResult>AccessKeyMetadata>member"`
	IsTruncated       aws.BooleanValue    `xml:"ListAccessKeysResult>IsTruncated"`
	Marker            aws.StringValue     `xml:"ListAccessKeysResult>Marker"`
}

func (v *ListAccessKeysResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessKeyMetadata"); err != nil {
		errors["AccessKeyMetadata"] = append(errors["AccessKeyMetadata"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListAccountAliasesRequest is undocumented.
type ListAccountAliasesRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
}

func (v *ListAccountAliasesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListAccountAliasesResponse is undocumented.
type ListAccountAliasesResponse struct {
	AccountAliases []string         `xml:"ListAccountAliasesResult>AccountAliases>member"`
	IsTruncated    aws.BooleanValue `xml:"ListAccountAliasesResult>IsTruncated"`
	Marker         aws.StringValue  `xml:"ListAccountAliasesResult>Marker"`
}

func (v *ListAccountAliasesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccountAliases"); err != nil {
		errors["AccountAliases"] = append(errors["AccountAliases"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGroupPoliciesRequest is undocumented.
type ListGroupPoliciesRequest struct {
	GroupName aws.StringValue  `xml:"GroupName"`
	Marker    aws.StringValue  `xml:"Marker"`
	MaxItems  aws.IntegerValue `xml:"MaxItems"`
}

func (v *ListGroupPoliciesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGroupPoliciesResponse is undocumented.
type ListGroupPoliciesResponse struct {
	IsTruncated aws.BooleanValue `xml:"ListGroupPoliciesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListGroupPoliciesResult>Marker"`
	PolicyNames []string         `xml:"ListGroupPoliciesResult>PolicyNames>member"`
}

func (v *ListGroupPoliciesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "PolicyNames"); err != nil {
		errors["PolicyNames"] = append(errors["PolicyNames"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGroupsForUserRequest is undocumented.
type ListGroupsForUserRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	UserName aws.StringValue  `xml:"UserName"`
}

func (v *ListGroupsForUserRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGroupsForUserResponse is undocumented.
type ListGroupsForUserResponse struct {
	Groups      []Group          `xml:"ListGroupsForUserResult>Groups>member"`
	IsTruncated aws.BooleanValue `xml:"ListGroupsForUserResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListGroupsForUserResult>Marker"`
}

func (v *ListGroupsForUserResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Groups"); err != nil {
		errors["Groups"] = append(errors["Groups"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGroupsRequest is undocumented.
type ListGroupsRequest struct {
	Marker     aws.StringValue  `xml:"Marker"`
	MaxItems   aws.IntegerValue `xml:"MaxItems"`
	PathPrefix aws.StringValue  `xml:"PathPrefix"`
}

func (v *ListGroupsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "PathPrefix", 1); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidateMax(v, "PathPrefix", 512); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidatePattern(v, "PathPrefix", `\u002F[\u0021-\u007F]*`); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListGroupsResponse is undocumented.
type ListGroupsResponse struct {
	Groups      []Group          `xml:"ListGroupsResult>Groups>member"`
	IsTruncated aws.BooleanValue `xml:"ListGroupsResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListGroupsResult>Marker"`
}

func (v *ListGroupsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Groups"); err != nil {
		errors["Groups"] = append(errors["Groups"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListInstanceProfilesForRoleRequest is undocumented.
type ListInstanceProfilesForRoleRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	RoleName aws.StringValue  `xml:"RoleName"`
}

func (v *ListInstanceProfilesForRoleRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListInstanceProfilesForRoleResponse is undocumented.
type ListInstanceProfilesForRoleResponse struct {
	InstanceProfiles []InstanceProfile `xml:"ListInstanceProfilesForRoleResult>InstanceProfiles>member"`
	IsTruncated      aws.BooleanValue  `xml:"ListInstanceProfilesForRoleResult>IsTruncated"`
	Marker           aws.StringValue   `xml:"ListInstanceProfilesForRoleResult>Marker"`
}

func (v *ListInstanceProfilesForRoleResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfiles"); err != nil {
		errors["InstanceProfiles"] = append(errors["InstanceProfiles"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListInstanceProfilesRequest is undocumented.
type ListInstanceProfilesRequest struct {
	Marker     aws.StringValue  `xml:"Marker"`
	MaxItems   aws.IntegerValue `xml:"MaxItems"`
	PathPrefix aws.StringValue  `xml:"PathPrefix"`
}

func (v *ListInstanceProfilesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "PathPrefix", 1); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidateMax(v, "PathPrefix", 512); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidatePattern(v, "PathPrefix", `\u002F[\u0021-\u007F]*`); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListInstanceProfilesResponse is undocumented.
type ListInstanceProfilesResponse struct {
	InstanceProfiles []InstanceProfile `xml:"ListInstanceProfilesResult>InstanceProfiles>member"`
	IsTruncated      aws.BooleanValue  `xml:"ListInstanceProfilesResult>IsTruncated"`
	Marker           aws.StringValue   `xml:"ListInstanceProfilesResult>Marker"`
}

func (v *ListInstanceProfilesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfiles"); err != nil {
		errors["InstanceProfiles"] = append(errors["InstanceProfiles"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListMFADevicesRequest is undocumented.
type ListMFADevicesRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	UserName aws.StringValue  `xml:"UserName"`
}

func (v *ListMFADevicesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListMFADevicesResponse is undocumented.
type ListMFADevicesResponse struct {
	IsTruncated aws.BooleanValue `xml:"ListMFADevicesResult>IsTruncated"`
	MFADevices  []MFADevice      `xml:"ListMFADevicesResult>MFADevices>member"`
	Marker      aws.StringValue  `xml:"ListMFADevicesResult>Marker"`
}

func (v *ListMFADevicesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "MFADevices"); err != nil {
		errors["MFADevices"] = append(errors["MFADevices"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListOpenIDConnectProvidersRequest is undocumented.
type ListOpenIDConnectProvidersRequest struct {
}

func (v *ListOpenIDConnectProvidersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListOpenIDConnectProvidersResponse is undocumented.
type ListOpenIDConnectProvidersResponse struct {
	OpenIDConnectProviderList []OpenIDConnectProviderListEntry `xml:"ListOpenIDConnectProvidersResult>OpenIDConnectProviderList>member"`
}

func (v *ListOpenIDConnectProvidersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListRolePoliciesRequest is undocumented.
type ListRolePoliciesRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	RoleName aws.StringValue  `xml:"RoleName"`
}

func (v *ListRolePoliciesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListRolePoliciesResponse is undocumented.
type ListRolePoliciesResponse struct {
	IsTruncated aws.BooleanValue `xml:"ListRolePoliciesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListRolePoliciesResult>Marker"`
	PolicyNames []string         `xml:"ListRolePoliciesResult>PolicyNames>member"`
}

func (v *ListRolePoliciesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "PolicyNames"); err != nil {
		errors["PolicyNames"] = append(errors["PolicyNames"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListRolesRequest is undocumented.
type ListRolesRequest struct {
	Marker     aws.StringValue  `xml:"Marker"`
	MaxItems   aws.IntegerValue `xml:"MaxItems"`
	PathPrefix aws.StringValue  `xml:"PathPrefix"`
}

func (v *ListRolesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "PathPrefix", 1); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidateMax(v, "PathPrefix", 512); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidatePattern(v, "PathPrefix", `\u002F[\u0021-\u007F]*`); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListRolesResponse is undocumented.
type ListRolesResponse struct {
	IsTruncated aws.BooleanValue `xml:"ListRolesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListRolesResult>Marker"`
	Roles       []Role           `xml:"ListRolesResult>Roles>member"`
}

func (v *ListRolesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "Roles"); err != nil {
		errors["Roles"] = append(errors["Roles"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListSAMLProvidersRequest is undocumented.
type ListSAMLProvidersRequest struct {
}

func (v *ListSAMLProvidersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListSAMLProvidersResponse is undocumented.
type ListSAMLProvidersResponse struct {
	SAMLProviderList []SAMLProviderListEntry `xml:"ListSAMLProvidersResult>SAMLProviderList>member"`
}

func (v *ListSAMLProvidersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListServerCertificatesRequest is undocumented.
type ListServerCertificatesRequest struct {
	Marker     aws.StringValue  `xml:"Marker"`
	MaxItems   aws.IntegerValue `xml:"MaxItems"`
	PathPrefix aws.StringValue  `xml:"PathPrefix"`
}

func (v *ListServerCertificatesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "PathPrefix", 1); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidateMax(v, "PathPrefix", 512); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidatePattern(v, "PathPrefix", `\u002F[\u0021-\u007F]*`); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListServerCertificatesResponse is undocumented.
type ListServerCertificatesResponse struct {
	IsTruncated                   aws.BooleanValue            `xml:"ListServerCertificatesResult>IsTruncated"`
	Marker                        aws.StringValue             `xml:"ListServerCertificatesResult>Marker"`
	ServerCertificateMetadataList []ServerCertificateMetadata `xml:"ListServerCertificatesResult>ServerCertificateMetadataList>member"`
}

func (v *ListServerCertificatesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "ServerCertificateMetadataList"); err != nil {
		errors["ServerCertificateMetadataList"] = append(errors["ServerCertificateMetadataList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListSigningCertificatesRequest is undocumented.
type ListSigningCertificatesRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	UserName aws.StringValue  `xml:"UserName"`
}

func (v *ListSigningCertificatesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListSigningCertificatesResponse is undocumented.
type ListSigningCertificatesResponse struct {
	Certificates []SigningCertificate `xml:"ListSigningCertificatesResult>Certificates>member"`
	IsTruncated  aws.BooleanValue     `xml:"ListSigningCertificatesResult>IsTruncated"`
	Marker       aws.StringValue      `xml:"ListSigningCertificatesResult>Marker"`
}

func (v *ListSigningCertificatesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Certificates"); err != nil {
		errors["Certificates"] = append(errors["Certificates"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListUserPoliciesRequest is undocumented.
type ListUserPoliciesRequest struct {
	Marker   aws.StringValue  `xml:"Marker"`
	MaxItems aws.IntegerValue `xml:"MaxItems"`
	UserName aws.StringValue  `xml:"UserName"`
}

func (v *ListUserPoliciesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListUserPoliciesResponse is undocumented.
type ListUserPoliciesResponse struct {
	IsTruncated aws.BooleanValue `xml:"ListUserPoliciesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListUserPoliciesResult>Marker"`
	PolicyNames []string         `xml:"ListUserPoliciesResult>PolicyNames>member"`
}

func (v *ListUserPoliciesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "PolicyNames"); err != nil {
		errors["PolicyNames"] = append(errors["PolicyNames"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListUsersRequest is undocumented.
type ListUsersRequest struct {
	Marker     aws.StringValue  `xml:"Marker"`
	MaxItems   aws.IntegerValue `xml:"MaxItems"`
	PathPrefix aws.StringValue  `xml:"PathPrefix"`
}

func (v *ListUsersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMin(v, "PathPrefix", 1); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidateMax(v, "PathPrefix", 512); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if err := model.ValidatePattern(v, "PathPrefix", `\u002F[\u0021-\u007F]*`); err != nil {
		errors["PathPrefix"] = append(errors["PathPrefix"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListUsersResponse is undocumented.
type ListUsersResponse struct {
	IsTruncated aws.BooleanValue `xml:"ListUsersResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListUsersResult>Marker"`
	Users       []User           `xml:"ListUsersResult>Users>member"`
}

func (v *ListUsersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "Users"); err != nil {
		errors["Users"] = append(errors["Users"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListVirtualMFADevicesRequest is undocumented.
type ListVirtualMFADevicesRequest struct {
	AssignmentStatus aws.StringValue  `xml:"AssignmentStatus"`
	Marker           aws.StringValue  `xml:"Marker"`
	MaxItems         aws.IntegerValue `xml:"MaxItems"`
}

func (v *ListVirtualMFADevicesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AssignmentStatusEnum := []string{
		AssignmentStatusTypeAny,
		AssignmentStatusTypeAssigned,
		AssignmentStatusTypeUnassigned,
	}
	if err := model.ValidateEnum(v, "AssignmentStatus", AssignmentStatusEnum); err != nil {
		errors["AssignmentStatus"] = append(errors["AssignmentStatus"], err)
	}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMin(v, "MaxItems", 1); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if err := model.ValidateMax(v, "MaxItems", 1000); err != nil {
		errors["MaxItems"] = append(errors["MaxItems"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListVirtualMFADevicesResponse is undocumented.
type ListVirtualMFADevicesResponse struct {
	IsTruncated       aws.BooleanValue   `xml:"ListVirtualMFADevicesResult>IsTruncated"`
	Marker            aws.StringValue    `xml:"ListVirtualMFADevicesResult>Marker"`
	VirtualMFADevices []VirtualMFADevice `xml:"ListVirtualMFADevicesResult>VirtualMFADevices>member"`
}

func (v *ListVirtualMFADevicesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Marker", 1); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateMax(v, "Marker", 320); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidatePattern(v, "Marker", `[\u0020-\u00FF]*`); err != nil {
		errors["Marker"] = append(errors["Marker"], err)
	}

	if err := model.ValidateRequired(v, "VirtualMFADevices"); err != nil {
		errors["VirtualMFADevices"] = append(errors["VirtualMFADevices"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LoginProfile is undocumented.
type LoginProfile struct {
	CreateDate            time.Time        `xml:"CreateDate"`
	PasswordResetRequired aws.BooleanValue `xml:"PasswordResetRequired"`
	UserName              aws.StringValue  `xml:"UserName"`
}

func (v *LoginProfile) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CreateDate"); err != nil {
		errors["CreateDate"] = append(errors["CreateDate"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// MFADevice is undocumented.
type MFADevice struct {
	EnableDate   time.Time       `xml:"EnableDate"`
	SerialNumber aws.StringValue `xml:"SerialNumber"`
	UserName     aws.StringValue `xml:"UserName"`
}

func (v *MFADevice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "EnableDate"); err != nil {
		errors["EnableDate"] = append(errors["EnableDate"], err)
	}

	if err := model.ValidateRequired(v, "SerialNumber"); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMin(v, "SerialNumber", 9); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMax(v, "SerialNumber", 256); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidatePattern(v, "SerialNumber", `[\w+=/:,.@-]*`); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// OpenIDConnectProviderListEntry is undocumented.
type OpenIDConnectProviderListEntry struct {
	ARN aws.StringValue `xml:"Arn"`
}

func (v *OpenIDConnectProviderListEntry) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PasswordPolicy is undocumented.
type PasswordPolicy struct {
	AllowUsersToChangePassword aws.BooleanValue `xml:"AllowUsersToChangePassword"`
	ExpirePasswords            aws.BooleanValue `xml:"ExpirePasswords"`
	HardExpiry                 aws.BooleanValue `xml:"HardExpiry"`
	MaxPasswordAge             aws.IntegerValue `xml:"MaxPasswordAge"`
	MinimumPasswordLength      aws.IntegerValue `xml:"MinimumPasswordLength"`
	PasswordReusePrevention    aws.IntegerValue `xml:"PasswordReusePrevention"`
	RequireLowercaseCharacters aws.BooleanValue `xml:"RequireLowercaseCharacters"`
	RequireNumbers             aws.BooleanValue `xml:"RequireNumbers"`
	RequireSymbols             aws.BooleanValue `xml:"RequireSymbols"`
	RequireUppercaseCharacters aws.BooleanValue `xml:"RequireUppercaseCharacters"`
}

func (v *PasswordPolicy) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "MaxPasswordAge", 1); err != nil {
		errors["MaxPasswordAge"] = append(errors["MaxPasswordAge"], err)
	}

	if err := model.ValidateMax(v, "MaxPasswordAge", 1095); err != nil {
		errors["MaxPasswordAge"] = append(errors["MaxPasswordAge"], err)
	}

	if err := model.ValidateMin(v, "MinimumPasswordLength", 6); err != nil {
		errors["MinimumPasswordLength"] = append(errors["MinimumPasswordLength"], err)
	}

	if err := model.ValidateMax(v, "MinimumPasswordLength", 128); err != nil {
		errors["MinimumPasswordLength"] = append(errors["MinimumPasswordLength"], err)
	}

	if err := model.ValidateMin(v, "PasswordReusePrevention", 1); err != nil {
		errors["PasswordReusePrevention"] = append(errors["PasswordReusePrevention"], err)
	}

	if err := model.ValidateMax(v, "PasswordReusePrevention", 24); err != nil {
		errors["PasswordReusePrevention"] = append(errors["PasswordReusePrevention"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PolicyDetail is undocumented.
type PolicyDetail struct {
	PolicyDocument aws.StringValue `xml:"PolicyDocument"`
	PolicyName     aws.StringValue `xml:"PolicyName"`
}

func (v *PolicyDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PutGroupPolicyRequest is undocumented.
type PutGroupPolicyRequest struct {
	GroupName      aws.StringValue `xml:"GroupName"`
	PolicyDocument aws.StringValue `xml:"PolicyDocument"`
	PolicyName     aws.StringValue `xml:"PolicyName"`
}

func (v *PutGroupPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PutRolePolicyRequest is undocumented.
type PutRolePolicyRequest struct {
	PolicyDocument aws.StringValue `xml:"PolicyDocument"`
	PolicyName     aws.StringValue `xml:"PolicyName"`
	RoleName       aws.StringValue `xml:"RoleName"`
}

func (v *PutRolePolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PutUserPolicyRequest is undocumented.
type PutUserPolicyRequest struct {
	PolicyDocument aws.StringValue `xml:"PolicyDocument"`
	PolicyName     aws.StringValue `xml:"PolicyName"`
	UserName       aws.StringValue `xml:"UserName"`
}

func (v *PutUserPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "PolicyName"); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMin(v, "PolicyName", 1); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateMax(v, "PolicyName", 128); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidatePattern(v, "PolicyName", `[\w+=,.@-]*`); err != nil {
		errors["PolicyName"] = append(errors["PolicyName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RemoveClientIDFromOpenIDConnectProviderRequest is undocumented.
type RemoveClientIDFromOpenIDConnectProviderRequest struct {
	ClientID                 aws.StringValue `xml:"ClientID"`
	OpenIDConnectProviderARN aws.StringValue `xml:"OpenIDConnectProviderArn"`
}

func (v *RemoveClientIDFromOpenIDConnectProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ClientID"); err != nil {
		errors["ClientID"] = append(errors["ClientID"], err)
	}

	if err := model.ValidateMin(v, "ClientID", 1); err != nil {
		errors["ClientID"] = append(errors["ClientID"], err)
	}

	if err := model.ValidateMax(v, "ClientID", 255); err != nil {
		errors["ClientID"] = append(errors["ClientID"], err)
	}

	if err := model.ValidateRequired(v, "OpenIDConnectProviderARN"); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMin(v, "OpenIDConnectProviderARN", 20); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMax(v, "OpenIDConnectProviderARN", 2048); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RemoveRoleFromInstanceProfileRequest is undocumented.
type RemoveRoleFromInstanceProfileRequest struct {
	InstanceProfileName aws.StringValue `xml:"InstanceProfileName"`
	RoleName            aws.StringValue `xml:"RoleName"`
}

func (v *RemoveRoleFromInstanceProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InstanceProfileName"); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMin(v, "InstanceProfileName", 1); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateMax(v, "InstanceProfileName", 128); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidatePattern(v, "InstanceProfileName", `[\w+=,.@-]*`); err != nil {
		errors["InstanceProfileName"] = append(errors["InstanceProfileName"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RemoveUserFromGroupRequest is undocumented.
type RemoveUserFromGroupRequest struct {
	GroupName aws.StringValue `xml:"GroupName"`
	UserName  aws.StringValue `xml:"UserName"`
}

func (v *RemoveUserFromGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for IAM.
const (
	ReportFormatTypeTextCSV = "text/csv"
)

// Possible values for IAM.
const (
	ReportStateTypeComplete   = "COMPLETE"
	ReportStateTypeInprogress = "INPROGRESS"
	ReportStateTypeStarted    = "STARTED"
)

// ResyncMFADeviceRequest is undocumented.
type ResyncMFADeviceRequest struct {
	AuthenticationCode1 aws.StringValue `xml:"AuthenticationCode1"`
	AuthenticationCode2 aws.StringValue `xml:"AuthenticationCode2"`
	SerialNumber        aws.StringValue `xml:"SerialNumber"`
	UserName            aws.StringValue `xml:"UserName"`
}

func (v *ResyncMFADeviceRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AuthenticationCode1"); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidateMin(v, "AuthenticationCode1", 6); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidateMax(v, "AuthenticationCode1", 6); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidatePattern(v, "AuthenticationCode1", `[\d]*`); err != nil {
		errors["AuthenticationCode1"] = append(errors["AuthenticationCode1"], err)
	}

	if err := model.ValidateRequired(v, "AuthenticationCode2"); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidateMin(v, "AuthenticationCode2", 6); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidateMax(v, "AuthenticationCode2", 6); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidatePattern(v, "AuthenticationCode2", `[\d]*`); err != nil {
		errors["AuthenticationCode2"] = append(errors["AuthenticationCode2"], err)
	}

	if err := model.ValidateRequired(v, "SerialNumber"); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMin(v, "SerialNumber", 9); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMax(v, "SerialNumber", 256); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidatePattern(v, "SerialNumber", `[\w+=/:,.@-]*`); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Role is undocumented.
type Role struct {
	ARN                      aws.StringValue `xml:"Arn"`
	AssumeRolePolicyDocument aws.StringValue `xml:"AssumeRolePolicyDocument"`
	CreateDate               time.Time       `xml:"CreateDate"`
	Path                     aws.StringValue `xml:"Path"`
	RoleID                   aws.StringValue `xml:"RoleId"`
	RoleName                 aws.StringValue `xml:"RoleName"`
}

func (v *Role) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ARN"); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "AssumeRolePolicyDocument", 1); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "AssumeRolePolicyDocument", 131072); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "AssumeRolePolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "CreateDate"); err != nil {
		errors["CreateDate"] = append(errors["CreateDate"], err)
	}

	if err := model.ValidateRequired(v, "Path"); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "RoleID"); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidateMin(v, "RoleID", 16); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidateMax(v, "RoleID", 32); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidatePattern(v, "RoleID", `[\w]*`); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RoleDetail is undocumented.
type RoleDetail struct {
	ARN                      aws.StringValue   `xml:"Arn"`
	AssumeRolePolicyDocument aws.StringValue   `xml:"AssumeRolePolicyDocument"`
	CreateDate               time.Time         `xml:"CreateDate"`
	InstanceProfileList      []InstanceProfile `xml:"InstanceProfileList>member"`
	Path                     aws.StringValue   `xml:"Path"`
	RoleID                   aws.StringValue   `xml:"RoleId"`
	RoleName                 aws.StringValue   `xml:"RoleName"`
	RolePolicyList           []PolicyDetail    `xml:"RolePolicyList>member"`
}

func (v *RoleDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "AssumeRolePolicyDocument", 1); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "AssumeRolePolicyDocument", 131072); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "AssumeRolePolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["AssumeRolePolicyDocument"] = append(errors["AssumeRolePolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "RoleID", 16); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidateMax(v, "RoleID", 32); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidatePattern(v, "RoleID", `[\w]*`); err != nil {
		errors["RoleID"] = append(errors["RoleID"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SAMLProviderListEntry is undocumented.
type SAMLProviderListEntry struct {
	ARN        aws.StringValue `xml:"Arn"`
	CreateDate time.Time       `xml:"CreateDate"`
	ValidUntil time.Time       `xml:"ValidUntil"`
}

func (v *SAMLProviderListEntry) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ServerCertificate is undocumented.
type ServerCertificate struct {
	CertificateBody           aws.StringValue            `xml:"CertificateBody"`
	CertificateChain          aws.StringValue            `xml:"CertificateChain"`
	ServerCertificateMetadata *ServerCertificateMetadata `xml:"ServerCertificateMetadata"`
}

func (v *ServerCertificate) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CertificateBody"); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "CertificateBody", 1); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMax(v, "CertificateBody", 16384); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidatePattern(v, "CertificateBody", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "CertificateChain", 1); err != nil {
		errors["CertificateChain"] = append(errors["CertificateChain"], err)
	}

	if err := model.ValidateMax(v, "CertificateChain", 2097152); err != nil {
		errors["CertificateChain"] = append(errors["CertificateChain"], err)
	}

	if err := model.ValidatePattern(v, "CertificateChain", `[\u0009\u000A\u000D\u0020-\u00FF]*`); err != nil {
		errors["CertificateChain"] = append(errors["CertificateChain"], err)
	}

	if err := model.ValidateRequired(v, "ServerCertificateMetadata"); err != nil {
		errors["ServerCertificateMetadata"] = append(errors["ServerCertificateMetadata"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ServerCertificateMetadata is undocumented.
type ServerCertificateMetadata struct {
	ARN                   aws.StringValue `xml:"Arn"`
	Expiration            time.Time       `xml:"Expiration"`
	Path                  aws.StringValue `xml:"Path"`
	ServerCertificateID   aws.StringValue `xml:"ServerCertificateId"`
	ServerCertificateName aws.StringValue `xml:"ServerCertificateName"`
	UploadDate            time.Time       `xml:"UploadDate"`
}

func (v *ServerCertificateMetadata) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ARN"); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateRequired(v, "Path"); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "ServerCertificateID"); err != nil {
		errors["ServerCertificateID"] = append(errors["ServerCertificateID"], err)
	}

	if err := model.ValidateMin(v, "ServerCertificateID", 16); err != nil {
		errors["ServerCertificateID"] = append(errors["ServerCertificateID"], err)
	}

	if err := model.ValidateMax(v, "ServerCertificateID", 32); err != nil {
		errors["ServerCertificateID"] = append(errors["ServerCertificateID"], err)
	}

	if err := model.ValidatePattern(v, "ServerCertificateID", `[\w]*`); err != nil {
		errors["ServerCertificateID"] = append(errors["ServerCertificateID"], err)
	}

	if err := model.ValidateRequired(v, "ServerCertificateName"); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMin(v, "ServerCertificateName", 1); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMax(v, "ServerCertificateName", 128); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidatePattern(v, "ServerCertificateName", `[\w+=,.@-]*`); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SigningCertificate is undocumented.
type SigningCertificate struct {
	CertificateBody aws.StringValue `xml:"CertificateBody"`
	CertificateID   aws.StringValue `xml:"CertificateId"`
	Status          aws.StringValue `xml:"Status"`
	UploadDate      time.Time       `xml:"UploadDate"`
	UserName        aws.StringValue `xml:"UserName"`
}

func (v *SigningCertificate) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CertificateBody"); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "CertificateBody", 1); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMax(v, "CertificateBody", 16384); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidatePattern(v, "CertificateBody", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateRequired(v, "CertificateID"); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMin(v, "CertificateID", 24); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMax(v, "CertificateID", 128); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidatePattern(v, "CertificateID", `[\w]*`); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	StatusEnum := []string{
		StatusTypeActive,
		StatusTypeInactive,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateAccessKeyRequest is undocumented.
type UpdateAccessKeyRequest struct {
	AccessKeyID aws.StringValue `xml:"AccessKeyId"`
	Status      aws.StringValue `xml:"Status"`
	UserName    aws.StringValue `xml:"UserName"`
}

func (v *UpdateAccessKeyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessKeyID"); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMin(v, "AccessKeyID", 16); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateMax(v, "AccessKeyID", 32); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidatePattern(v, "AccessKeyID", `[\w]*`); err != nil {
		errors["AccessKeyID"] = append(errors["AccessKeyID"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	StatusEnum := []string{
		StatusTypeActive,
		StatusTypeInactive,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateAccountPasswordPolicyRequest is undocumented.
type UpdateAccountPasswordPolicyRequest struct {
	AllowUsersToChangePassword aws.BooleanValue `xml:"AllowUsersToChangePassword"`
	HardExpiry                 aws.BooleanValue `xml:"HardExpiry"`
	MaxPasswordAge             aws.IntegerValue `xml:"MaxPasswordAge"`
	MinimumPasswordLength      aws.IntegerValue `xml:"MinimumPasswordLength"`
	PasswordReusePrevention    aws.IntegerValue `xml:"PasswordReusePrevention"`
	RequireLowercaseCharacters aws.BooleanValue `xml:"RequireLowercaseCharacters"`
	RequireNumbers             aws.BooleanValue `xml:"RequireNumbers"`
	RequireSymbols             aws.BooleanValue `xml:"RequireSymbols"`
	RequireUppercaseCharacters aws.BooleanValue `xml:"RequireUppercaseCharacters"`
}

func (v *UpdateAccountPasswordPolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "MaxPasswordAge", 1); err != nil {
		errors["MaxPasswordAge"] = append(errors["MaxPasswordAge"], err)
	}

	if err := model.ValidateMax(v, "MaxPasswordAge", 1095); err != nil {
		errors["MaxPasswordAge"] = append(errors["MaxPasswordAge"], err)
	}

	if err := model.ValidateMin(v, "MinimumPasswordLength", 6); err != nil {
		errors["MinimumPasswordLength"] = append(errors["MinimumPasswordLength"], err)
	}

	if err := model.ValidateMax(v, "MinimumPasswordLength", 128); err != nil {
		errors["MinimumPasswordLength"] = append(errors["MinimumPasswordLength"], err)
	}

	if err := model.ValidateMin(v, "PasswordReusePrevention", 1); err != nil {
		errors["PasswordReusePrevention"] = append(errors["PasswordReusePrevention"], err)
	}

	if err := model.ValidateMax(v, "PasswordReusePrevention", 24); err != nil {
		errors["PasswordReusePrevention"] = append(errors["PasswordReusePrevention"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateAssumeRolePolicyRequest is undocumented.
type UpdateAssumeRolePolicyRequest struct {
	PolicyDocument aws.StringValue `xml:"PolicyDocument"`
	RoleName       aws.StringValue `xml:"RoleName"`
}

func (v *UpdateAssumeRolePolicyRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "PolicyDocument"); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMin(v, "PolicyDocument", 1); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateMax(v, "PolicyDocument", 131072); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidatePattern(v, "PolicyDocument", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["PolicyDocument"] = append(errors["PolicyDocument"], err)
	}

	if err := model.ValidateRequired(v, "RoleName"); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMin(v, "RoleName", 1); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidateMax(v, "RoleName", 64); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if err := model.ValidatePattern(v, "RoleName", `[\w+=,.@-]*`); err != nil {
		errors["RoleName"] = append(errors["RoleName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateGroupRequest is undocumented.
type UpdateGroupRequest struct {
	GroupName    aws.StringValue `xml:"GroupName"`
	NewGroupName aws.StringValue `xml:"NewGroupName"`
	NewPath      aws.StringValue `xml:"NewPath"`
}

func (v *UpdateGroupRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "GroupName"); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "GroupName", 1); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMax(v, "GroupName", 128); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidatePattern(v, "GroupName", `[\w+=,.@-]*`); err != nil {
		errors["GroupName"] = append(errors["GroupName"], err)
	}

	if err := model.ValidateMin(v, "NewGroupName", 1); err != nil {
		errors["NewGroupName"] = append(errors["NewGroupName"], err)
	}

	if err := model.ValidateMax(v, "NewGroupName", 128); err != nil {
		errors["NewGroupName"] = append(errors["NewGroupName"], err)
	}

	if err := model.ValidatePattern(v, "NewGroupName", `[\w+=,.@-]*`); err != nil {
		errors["NewGroupName"] = append(errors["NewGroupName"], err)
	}

	if err := model.ValidateMin(v, "NewPath", 1); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidateMax(v, "NewPath", 512); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidatePattern(v, "NewPath", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateLoginProfileRequest is undocumented.
type UpdateLoginProfileRequest struct {
	Password              aws.StringValue  `xml:"Password"`
	PasswordResetRequired aws.BooleanValue `xml:"PasswordResetRequired"`
	UserName              aws.StringValue  `xml:"UserName"`
}

func (v *UpdateLoginProfileRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "Password", 1); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidateMax(v, "Password", 128); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidatePattern(v, "Password", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["Password"] = append(errors["Password"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateOpenIDConnectProviderThumbprintRequest is undocumented.
type UpdateOpenIDConnectProviderThumbprintRequest struct {
	OpenIDConnectProviderARN aws.StringValue `xml:"OpenIDConnectProviderArn"`
	ThumbprintList           []string        `xml:"ThumbprintList>member"`
}

func (v *UpdateOpenIDConnectProviderThumbprintRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "OpenIDConnectProviderARN"); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMin(v, "OpenIDConnectProviderARN", 20); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateMax(v, "OpenIDConnectProviderARN", 2048); err != nil {
		errors["OpenIDConnectProviderARN"] = append(errors["OpenIDConnectProviderARN"], err)
	}

	if err := model.ValidateRequired(v, "ThumbprintList"); err != nil {
		errors["ThumbprintList"] = append(errors["ThumbprintList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateSAMLProviderRequest is undocumented.
type UpdateSAMLProviderRequest struct {
	SAMLMetadataDocument aws.StringValue `xml:"SAMLMetadataDocument"`
	SAMLProviderARN      aws.StringValue `xml:"SAMLProviderArn"`
}

func (v *UpdateSAMLProviderRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SAMLMetadataDocument"); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if err := model.ValidateMin(v, "SAMLMetadataDocument", 1000); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if err := model.ValidateMax(v, "SAMLMetadataDocument", 10000000); err != nil {
		errors["SAMLMetadataDocument"] = append(errors["SAMLMetadataDocument"], err)
	}

	if err := model.ValidateRequired(v, "SAMLProviderARN"); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMin(v, "SAMLProviderARN", 20); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMax(v, "SAMLProviderARN", 2048); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateSAMLProviderResponse is undocumented.
type UpdateSAMLProviderResponse struct {
	SAMLProviderARN aws.StringValue `xml:"UpdateSAMLProviderResult>SAMLProviderArn"`
}

func (v *UpdateSAMLProviderResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "SAMLProviderARN", 20); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if err := model.ValidateMax(v, "SAMLProviderARN", 2048); err != nil {
		errors["SAMLProviderARN"] = append(errors["SAMLProviderARN"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateServerCertificateRequest is undocumented.
type UpdateServerCertificateRequest struct {
	NewPath                  aws.StringValue `xml:"NewPath"`
	NewServerCertificateName aws.StringValue `xml:"NewServerCertificateName"`
	ServerCertificateName    aws.StringValue `xml:"ServerCertificateName"`
}

func (v *UpdateServerCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "NewPath", 1); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidateMax(v, "NewPath", 512); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidatePattern(v, "NewPath", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidateMin(v, "NewServerCertificateName", 1); err != nil {
		errors["NewServerCertificateName"] = append(errors["NewServerCertificateName"], err)
	}

	if err := model.ValidateMax(v, "NewServerCertificateName", 128); err != nil {
		errors["NewServerCertificateName"] = append(errors["NewServerCertificateName"], err)
	}

	if err := model.ValidatePattern(v, "NewServerCertificateName", `[\w+=,.@-]*`); err != nil {
		errors["NewServerCertificateName"] = append(errors["NewServerCertificateName"], err)
	}

	if err := model.ValidateRequired(v, "ServerCertificateName"); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMin(v, "ServerCertificateName", 1); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMax(v, "ServerCertificateName", 128); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidatePattern(v, "ServerCertificateName", `[\w+=,.@-]*`); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateSigningCertificateRequest is undocumented.
type UpdateSigningCertificateRequest struct {
	CertificateID aws.StringValue `xml:"CertificateId"`
	Status        aws.StringValue `xml:"Status"`
	UserName      aws.StringValue `xml:"UserName"`
}

func (v *UpdateSigningCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CertificateID"); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMin(v, "CertificateID", 24); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateMax(v, "CertificateID", 128); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidatePattern(v, "CertificateID", `[\w]*`); err != nil {
		errors["CertificateID"] = append(errors["CertificateID"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	StatusEnum := []string{
		StatusTypeActive,
		StatusTypeInactive,
	}
	if err := model.ValidateEnum(v, "Status", StatusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateUserRequest is undocumented.
type UpdateUserRequest struct {
	NewPath     aws.StringValue `xml:"NewPath"`
	NewUserName aws.StringValue `xml:"NewUserName"`
	UserName    aws.StringValue `xml:"UserName"`
}

func (v *UpdateUserRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "NewPath", 1); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidateMax(v, "NewPath", 512); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidatePattern(v, "NewPath", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["NewPath"] = append(errors["NewPath"], err)
	}

	if err := model.ValidateMin(v, "NewUserName", 1); err != nil {
		errors["NewUserName"] = append(errors["NewUserName"], err)
	}

	if err := model.ValidateMax(v, "NewUserName", 64); err != nil {
		errors["NewUserName"] = append(errors["NewUserName"], err)
	}

	if err := model.ValidatePattern(v, "NewUserName", `[\w+=,.@-]*`); err != nil {
		errors["NewUserName"] = append(errors["NewUserName"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UploadServerCertificateRequest is undocumented.
type UploadServerCertificateRequest struct {
	CertificateBody       aws.StringValue `xml:"CertificateBody"`
	CertificateChain      aws.StringValue `xml:"CertificateChain"`
	Path                  aws.StringValue `xml:"Path"`
	PrivateKey            aws.StringValue `xml:"PrivateKey"`
	ServerCertificateName aws.StringValue `xml:"ServerCertificateName"`
}

func (v *UploadServerCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CertificateBody"); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "CertificateBody", 1); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMax(v, "CertificateBody", 16384); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidatePattern(v, "CertificateBody", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "CertificateChain", 1); err != nil {
		errors["CertificateChain"] = append(errors["CertificateChain"], err)
	}

	if err := model.ValidateMax(v, "CertificateChain", 2097152); err != nil {
		errors["CertificateChain"] = append(errors["CertificateChain"], err)
	}

	if err := model.ValidatePattern(v, "CertificateChain", `[\u0009\u000A\u000D\u0020-\u00FF]*`); err != nil {
		errors["CertificateChain"] = append(errors["CertificateChain"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "PrivateKey"); err != nil {
		errors["PrivateKey"] = append(errors["PrivateKey"], err)
	}

	if err := model.ValidateMin(v, "PrivateKey", 1); err != nil {
		errors["PrivateKey"] = append(errors["PrivateKey"], err)
	}

	if err := model.ValidateMax(v, "PrivateKey", 16384); err != nil {
		errors["PrivateKey"] = append(errors["PrivateKey"], err)
	}

	if err := model.ValidatePattern(v, "PrivateKey", `[\u0009\u000A\u000D\u0020-\u00FF]*`); err != nil {
		errors["PrivateKey"] = append(errors["PrivateKey"], err)
	}

	if err := model.ValidateRequired(v, "ServerCertificateName"); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMin(v, "ServerCertificateName", 1); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidateMax(v, "ServerCertificateName", 128); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if err := model.ValidatePattern(v, "ServerCertificateName", `[\w+=,.@-]*`); err != nil {
		errors["ServerCertificateName"] = append(errors["ServerCertificateName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UploadServerCertificateResponse is undocumented.
type UploadServerCertificateResponse struct {
	ServerCertificateMetadata *ServerCertificateMetadata `xml:"UploadServerCertificateResult>ServerCertificateMetadata"`
}

func (v *UploadServerCertificateResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UploadSigningCertificateRequest is undocumented.
type UploadSigningCertificateRequest struct {
	CertificateBody aws.StringValue `xml:"CertificateBody"`
	UserName        aws.StringValue `xml:"UserName"`
}

func (v *UploadSigningCertificateRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CertificateBody"); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "CertificateBody", 1); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMax(v, "CertificateBody", 16384); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidatePattern(v, "CertificateBody", `[\u0009\u000A\u000D\u0020-\u00FF]+`); err != nil {
		errors["CertificateBody"] = append(errors["CertificateBody"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 128); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UploadSigningCertificateResponse is undocumented.
type UploadSigningCertificateResponse struct {
	Certificate *SigningCertificate `xml:"UploadSigningCertificateResult>Certificate"`
}

func (v *UploadSigningCertificateResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Certificate"); err != nil {
		errors["Certificate"] = append(errors["Certificate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// User is undocumented.
type User struct {
	ARN              aws.StringValue `xml:"Arn"`
	CreateDate       time.Time       `xml:"CreateDate"`
	PasswordLastUsed time.Time       `xml:"PasswordLastUsed"`
	Path             aws.StringValue `xml:"Path"`
	UserID           aws.StringValue `xml:"UserId"`
	UserName         aws.StringValue `xml:"UserName"`
}

func (v *User) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ARN"); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateRequired(v, "CreateDate"); err != nil {
		errors["CreateDate"] = append(errors["CreateDate"], err)
	}

	if err := model.ValidateRequired(v, "Path"); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateRequired(v, "UserID"); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidateMin(v, "UserID", 16); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidateMax(v, "UserID", 32); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidatePattern(v, "UserID", `[\w]*`); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidateRequired(v, "UserName"); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UserDetail is undocumented.
type UserDetail struct {
	ARN            aws.StringValue `xml:"Arn"`
	CreateDate     time.Time       `xml:"CreateDate"`
	GroupList      []string        `xml:"GroupList>member"`
	Path           aws.StringValue `xml:"Path"`
	UserID         aws.StringValue `xml:"UserId"`
	UserName       aws.StringValue `xml:"UserName"`
	UserPolicyList []PolicyDetail  `xml:"UserPolicyList>member"`
}

func (v *UserDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "ARN", 20); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMax(v, "ARN", 2048); err != nil {
		errors["ARN"] = append(errors["ARN"], err)
	}

	if err := model.ValidateMin(v, "Path", 1); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMax(v, "Path", 512); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidatePattern(v, "Path", `(\u002F)|(\u002F[\u0021-\u007F]+\u002F)`); err != nil {
		errors["Path"] = append(errors["Path"], err)
	}

	if err := model.ValidateMin(v, "UserID", 16); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidateMax(v, "UserID", 32); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidatePattern(v, "UserID", `[\w]*`); err != nil {
		errors["UserID"] = append(errors["UserID"], err)
	}

	if err := model.ValidateMin(v, "UserName", 1); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidateMax(v, "UserName", 64); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if err := model.ValidatePattern(v, "UserName", `[\w+=,.@-]*`); err != nil {
		errors["UserName"] = append(errors["UserName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// VirtualMFADevice is undocumented.
type VirtualMFADevice struct {
	Base32StringSeed []byte          `xml:"Base32StringSeed"`
	EnableDate       time.Time       `xml:"EnableDate"`
	QRCodePNG        []byte          `xml:"QRCodePNG"`
	SerialNumber     aws.StringValue `xml:"SerialNumber"`
	User             *User           `xml:"User"`
}

func (v *VirtualMFADevice) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "SerialNumber"); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMin(v, "SerialNumber", 9); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidateMax(v, "SerialNumber", 256); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if err := model.ValidatePattern(v, "SerialNumber", `[\w+=/:,.@-]*`); err != nil {
		errors["SerialNumber"] = append(errors["SerialNumber"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for IAM.
const (
	AssignmentStatusTypeAny        = "Any"
	AssignmentStatusTypeAssigned   = "Assigned"
	AssignmentStatusTypeUnassigned = "Unassigned"
)

// Possible values for IAM.
const (
	StatusTypeActive   = "Active"
	StatusTypeInactive = "Inactive"
)

// Possible values for IAM.
const (
	SummaryKeyTypeAccessKeysPerUserQuota          = "AccessKeysPerUserQuota"
	SummaryKeyTypeAccountMFAenabled               = "AccountMFAEnabled"
	SummaryKeyTypeGroupPolicySizeQuota            = "GroupPolicySizeQuota"
	SummaryKeyTypeGroups                          = "Groups"
	SummaryKeyTypeGroupsPerUserQuota              = "GroupsPerUserQuota"
	SummaryKeyTypeGroupsQuota                     = "GroupsQuota"
	SummaryKeyTypeMFAdevices                      = "MFADevices"
	SummaryKeyTypeMFAdevicesInUse                 = "MFADevicesInUse"
	SummaryKeyTypeServerCertificates              = "ServerCertificates"
	SummaryKeyTypeServerCertificatesQuota         = "ServerCertificatesQuota"
	SummaryKeyTypeSigningCertificatesPerUserQuota = "SigningCertificatesPerUserQuota"
	SummaryKeyTypeUserPolicySizeQuota             = "UserPolicySizeQuota"
	SummaryKeyTypeUsers                           = "Users"
	SummaryKeyTypeUsersQuota                      = "UsersQuota"
)

// CreateAccessKeyResult is a wrapper for CreateAccessKeyResponse.
type CreateAccessKeyResult struct {
	AccessKey *AccessKey `xml:"CreateAccessKeyResult>AccessKey"`
}

// CreateGroupResult is a wrapper for CreateGroupResponse.
type CreateGroupResult struct {
	Group *Group `xml:"CreateGroupResult>Group"`
}

// CreateInstanceProfileResult is a wrapper for CreateInstanceProfileResponse.
type CreateInstanceProfileResult struct {
	InstanceProfile *InstanceProfile `xml:"CreateInstanceProfileResult>InstanceProfile"`
}

// CreateLoginProfileResult is a wrapper for CreateLoginProfileResponse.
type CreateLoginProfileResult struct {
	LoginProfile *LoginProfile `xml:"CreateLoginProfileResult>LoginProfile"`
}

// CreateOpenIDConnectProviderResult is a wrapper for CreateOpenIDConnectProviderResponse.
type CreateOpenIDConnectProviderResult struct {
	OpenIDConnectProviderARN aws.StringValue `xml:"CreateOpenIDConnectProviderResult>OpenIDConnectProviderArn"`
}

// CreateRoleResult is a wrapper for CreateRoleResponse.
type CreateRoleResult struct {
	Role *Role `xml:"CreateRoleResult>Role"`
}

// CreateSAMLProviderResult is a wrapper for CreateSAMLProviderResponse.
type CreateSAMLProviderResult struct {
	SAMLProviderARN aws.StringValue `xml:"CreateSAMLProviderResult>SAMLProviderArn"`
}

// CreateUserResult is a wrapper for CreateUserResponse.
type CreateUserResult struct {
	User *User `xml:"CreateUserResult>User"`
}

// CreateVirtualMFADeviceResult is a wrapper for CreateVirtualMFADeviceResponse.
type CreateVirtualMFADeviceResult struct {
	VirtualMFADevice *VirtualMFADevice `xml:"CreateVirtualMFADeviceResult>VirtualMFADevice"`
}

// GenerateCredentialReportResult is a wrapper for GenerateCredentialReportResponse.
type GenerateCredentialReportResult struct {
	Description aws.StringValue `xml:"GenerateCredentialReportResult>Description"`
	State       aws.StringValue `xml:"GenerateCredentialReportResult>State"`
}

// GetAccountAuthorizationDetailsResult is a wrapper for GetAccountAuthorizationDetailsResponse.
type GetAccountAuthorizationDetailsResult struct {
	GroupDetailList []GroupDetail    `xml:"GetAccountAuthorizationDetailsResult>GroupDetailList>member"`
	IsTruncated     aws.BooleanValue `xml:"GetAccountAuthorizationDetailsResult>IsTruncated"`
	Marker          aws.StringValue  `xml:"GetAccountAuthorizationDetailsResult>Marker"`
	RoleDetailList  []RoleDetail     `xml:"GetAccountAuthorizationDetailsResult>RoleDetailList>member"`
	UserDetailList  []UserDetail     `xml:"GetAccountAuthorizationDetailsResult>UserDetailList>member"`
}

// GetAccountPasswordPolicyResult is a wrapper for GetAccountPasswordPolicyResponse.
type GetAccountPasswordPolicyResult struct {
	PasswordPolicy *PasswordPolicy `xml:"GetAccountPasswordPolicyResult>PasswordPolicy"`
}

// GetAccountSummaryResult is a wrapper for GetAccountSummaryResponse.
type GetAccountSummaryResult struct {
	SummaryMap map[string]int `xml:"GetAccountSummaryResult>SummaryMap"`
}

// GetCredentialReportResult is a wrapper for GetCredentialReportResponse.
type GetCredentialReportResult struct {
	Content       []byte          `xml:"GetCredentialReportResult>Content"`
	GeneratedTime time.Time       `xml:"GetCredentialReportResult>GeneratedTime"`
	ReportFormat  aws.StringValue `xml:"GetCredentialReportResult>ReportFormat"`
}

// GetGroupPolicyResult is a wrapper for GetGroupPolicyResponse.
type GetGroupPolicyResult struct {
	GroupName      aws.StringValue `xml:"GetGroupPolicyResult>GroupName"`
	PolicyDocument aws.StringValue `xml:"GetGroupPolicyResult>PolicyDocument"`
	PolicyName     aws.StringValue `xml:"GetGroupPolicyResult>PolicyName"`
}

// GetGroupResult is a wrapper for GetGroupResponse.
type GetGroupResult struct {
	Group       *Group           `xml:"GetGroupResult>Group"`
	IsTruncated aws.BooleanValue `xml:"GetGroupResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"GetGroupResult>Marker"`
	Users       []User           `xml:"GetGroupResult>Users>member"`
}

// GetInstanceProfileResult is a wrapper for GetInstanceProfileResponse.
type GetInstanceProfileResult struct {
	InstanceProfile *InstanceProfile `xml:"GetInstanceProfileResult>InstanceProfile"`
}

// GetLoginProfileResult is a wrapper for GetLoginProfileResponse.
type GetLoginProfileResult struct {
	LoginProfile *LoginProfile `xml:"GetLoginProfileResult>LoginProfile"`
}

// GetOpenIDConnectProviderResult is a wrapper for GetOpenIDConnectProviderResponse.
type GetOpenIDConnectProviderResult struct {
	ClientIDList   []string        `xml:"GetOpenIDConnectProviderResult>ClientIDList>member"`
	CreateDate     time.Time       `xml:"GetOpenIDConnectProviderResult>CreateDate"`
	ThumbprintList []string        `xml:"GetOpenIDConnectProviderResult>ThumbprintList>member"`
	URL            aws.StringValue `xml:"GetOpenIDConnectProviderResult>Url"`
}

// GetRolePolicyResult is a wrapper for GetRolePolicyResponse.
type GetRolePolicyResult struct {
	PolicyDocument aws.StringValue `xml:"GetRolePolicyResult>PolicyDocument"`
	PolicyName     aws.StringValue `xml:"GetRolePolicyResult>PolicyName"`
	RoleName       aws.StringValue `xml:"GetRolePolicyResult>RoleName"`
}

// GetRoleResult is a wrapper for GetRoleResponse.
type GetRoleResult struct {
	Role *Role `xml:"GetRoleResult>Role"`
}

// GetSAMLProviderResult is a wrapper for GetSAMLProviderResponse.
type GetSAMLProviderResult struct {
	CreateDate           time.Time       `xml:"GetSAMLProviderResult>CreateDate"`
	SAMLMetadataDocument aws.StringValue `xml:"GetSAMLProviderResult>SAMLMetadataDocument"`
	ValidUntil           time.Time       `xml:"GetSAMLProviderResult>ValidUntil"`
}

// GetServerCertificateResult is a wrapper for GetServerCertificateResponse.
type GetServerCertificateResult struct {
	ServerCertificate *ServerCertificate `xml:"GetServerCertificateResult>ServerCertificate"`
}

// GetUserPolicyResult is a wrapper for GetUserPolicyResponse.
type GetUserPolicyResult struct {
	PolicyDocument aws.StringValue `xml:"GetUserPolicyResult>PolicyDocument"`
	PolicyName     aws.StringValue `xml:"GetUserPolicyResult>PolicyName"`
	UserName       aws.StringValue `xml:"GetUserPolicyResult>UserName"`
}

// GetUserResult is a wrapper for GetUserResponse.
type GetUserResult struct {
	User *User `xml:"GetUserResult>User"`
}

// ListAccessKeysResult is a wrapper for ListAccessKeysResponse.
type ListAccessKeysResult struct {
	AccessKeyMetadata []AccessKeyMetadata `xml:"ListAccessKeysResult>AccessKeyMetadata>member"`
	IsTruncated       aws.BooleanValue    `xml:"ListAccessKeysResult>IsTruncated"`
	Marker            aws.StringValue     `xml:"ListAccessKeysResult>Marker"`
}

// ListAccountAliasesResult is a wrapper for ListAccountAliasesResponse.
type ListAccountAliasesResult struct {
	AccountAliases []string         `xml:"ListAccountAliasesResult>AccountAliases>member"`
	IsTruncated    aws.BooleanValue `xml:"ListAccountAliasesResult>IsTruncated"`
	Marker         aws.StringValue  `xml:"ListAccountAliasesResult>Marker"`
}

// ListGroupPoliciesResult is a wrapper for ListGroupPoliciesResponse.
type ListGroupPoliciesResult struct {
	IsTruncated aws.BooleanValue `xml:"ListGroupPoliciesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListGroupPoliciesResult>Marker"`
	PolicyNames []string         `xml:"ListGroupPoliciesResult>PolicyNames>member"`
}

// ListGroupsForUserResult is a wrapper for ListGroupsForUserResponse.
type ListGroupsForUserResult struct {
	Groups      []Group          `xml:"ListGroupsForUserResult>Groups>member"`
	IsTruncated aws.BooleanValue `xml:"ListGroupsForUserResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListGroupsForUserResult>Marker"`
}

// ListGroupsResult is a wrapper for ListGroupsResponse.
type ListGroupsResult struct {
	Groups      []Group          `xml:"ListGroupsResult>Groups>member"`
	IsTruncated aws.BooleanValue `xml:"ListGroupsResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListGroupsResult>Marker"`
}

// ListInstanceProfilesForRoleResult is a wrapper for ListInstanceProfilesForRoleResponse.
type ListInstanceProfilesForRoleResult struct {
	InstanceProfiles []InstanceProfile `xml:"ListInstanceProfilesForRoleResult>InstanceProfiles>member"`
	IsTruncated      aws.BooleanValue  `xml:"ListInstanceProfilesForRoleResult>IsTruncated"`
	Marker           aws.StringValue   `xml:"ListInstanceProfilesForRoleResult>Marker"`
}

// ListInstanceProfilesResult is a wrapper for ListInstanceProfilesResponse.
type ListInstanceProfilesResult struct {
	InstanceProfiles []InstanceProfile `xml:"ListInstanceProfilesResult>InstanceProfiles>member"`
	IsTruncated      aws.BooleanValue  `xml:"ListInstanceProfilesResult>IsTruncated"`
	Marker           aws.StringValue   `xml:"ListInstanceProfilesResult>Marker"`
}

// ListMFADevicesResult is a wrapper for ListMFADevicesResponse.
type ListMFADevicesResult struct {
	IsTruncated aws.BooleanValue `xml:"ListMFADevicesResult>IsTruncated"`
	MFADevices  []MFADevice      `xml:"ListMFADevicesResult>MFADevices>member"`
	Marker      aws.StringValue  `xml:"ListMFADevicesResult>Marker"`
}

// ListOpenIDConnectProvidersResult is a wrapper for ListOpenIDConnectProvidersResponse.
type ListOpenIDConnectProvidersResult struct {
	OpenIDConnectProviderList []OpenIDConnectProviderListEntry `xml:"ListOpenIDConnectProvidersResult>OpenIDConnectProviderList>member"`
}

// ListRolePoliciesResult is a wrapper for ListRolePoliciesResponse.
type ListRolePoliciesResult struct {
	IsTruncated aws.BooleanValue `xml:"ListRolePoliciesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListRolePoliciesResult>Marker"`
	PolicyNames []string         `xml:"ListRolePoliciesResult>PolicyNames>member"`
}

// ListRolesResult is a wrapper for ListRolesResponse.
type ListRolesResult struct {
	IsTruncated aws.BooleanValue `xml:"ListRolesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListRolesResult>Marker"`
	Roles       []Role           `xml:"ListRolesResult>Roles>member"`
}

// ListSAMLProvidersResult is a wrapper for ListSAMLProvidersResponse.
type ListSAMLProvidersResult struct {
	SAMLProviderList []SAMLProviderListEntry `xml:"ListSAMLProvidersResult>SAMLProviderList>member"`
}

// ListServerCertificatesResult is a wrapper for ListServerCertificatesResponse.
type ListServerCertificatesResult struct {
	IsTruncated                   aws.BooleanValue            `xml:"ListServerCertificatesResult>IsTruncated"`
	Marker                        aws.StringValue             `xml:"ListServerCertificatesResult>Marker"`
	ServerCertificateMetadataList []ServerCertificateMetadata `xml:"ListServerCertificatesResult>ServerCertificateMetadataList>member"`
}

// ListSigningCertificatesResult is a wrapper for ListSigningCertificatesResponse.
type ListSigningCertificatesResult struct {
	Certificates []SigningCertificate `xml:"ListSigningCertificatesResult>Certificates>member"`
	IsTruncated  aws.BooleanValue     `xml:"ListSigningCertificatesResult>IsTruncated"`
	Marker       aws.StringValue      `xml:"ListSigningCertificatesResult>Marker"`
}

// ListUserPoliciesResult is a wrapper for ListUserPoliciesResponse.
type ListUserPoliciesResult struct {
	IsTruncated aws.BooleanValue `xml:"ListUserPoliciesResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListUserPoliciesResult>Marker"`
	PolicyNames []string         `xml:"ListUserPoliciesResult>PolicyNames>member"`
}

// ListUsersResult is a wrapper for ListUsersResponse.
type ListUsersResult struct {
	IsTruncated aws.BooleanValue `xml:"ListUsersResult>IsTruncated"`
	Marker      aws.StringValue  `xml:"ListUsersResult>Marker"`
	Users       []User           `xml:"ListUsersResult>Users>member"`
}

// ListVirtualMFADevicesResult is a wrapper for ListVirtualMFADevicesResponse.
type ListVirtualMFADevicesResult struct {
	IsTruncated       aws.BooleanValue   `xml:"ListVirtualMFADevicesResult>IsTruncated"`
	Marker            aws.StringValue    `xml:"ListVirtualMFADevicesResult>Marker"`
	VirtualMFADevices []VirtualMFADevice `xml:"ListVirtualMFADevicesResult>VirtualMFADevices>member"`
}

// UpdateSAMLProviderResult is a wrapper for UpdateSAMLProviderResponse.
type UpdateSAMLProviderResult struct {
	SAMLProviderARN aws.StringValue `xml:"UpdateSAMLProviderResult>SAMLProviderArn"`
}

// UploadServerCertificateResult is a wrapper for UploadServerCertificateResponse.
type UploadServerCertificateResult struct {
	ServerCertificateMetadata *ServerCertificateMetadata `xml:"UploadServerCertificateResult>ServerCertificateMetadata"`
}

// UploadSigningCertificateResult is a wrapper for UploadSigningCertificateResponse.
type UploadSigningCertificateResult struct {
	Certificate *SigningCertificate `xml:"UploadSigningCertificateResult>Certificate"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
