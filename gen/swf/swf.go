// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package swf provides a client for Amazon Simple Workflow Service.
package swf

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

// SWF is a client for Amazon Simple Workflow Service.
type SWF struct {
	client *aws.JSONClient
}

// New returns a new SWF client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *SWF {
	if client == nil {
		client = http.DefaultClient
	}

	service := "swf"
	endpoint, service, region := endpoints.Lookup("swf", region)

	return &SWF{
		client: &aws.JSONClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			}, Client: client,
			Endpoint:     endpoint,
			JSONVersion:  "1.0",
			TargetPrefix: "SimpleWorkflowService",
		},
	}
}

// CountClosedWorkflowExecutions returns the number of closed workflow
// executions within the given domain that meet the specified filtering
// criteria. You can use IAM policies to control this action's access to
// Amazon SWF resources as follows: Use a Resource element with the domain
// name to limit the action to only specified domains. Use an Action
// element to allow or deny permission to call this action. Constrain the
// following parameters by using a Condition element with the appropriate
// keys. tagFilter.tag : String constraint. The key is swf:tagFilter.tag
// typeFilter.name : String constraint. The key is swf:typeFilter.name
// typeFilter.version : String constraint. The key is
// swf:typeFilter.version If the caller does not have sufficient
// permissions to invoke the action, or the parameter values fall outside
// the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) CountClosedWorkflowExecutions(req *CountClosedWorkflowExecutionsInput) (resp *WorkflowExecutionCount, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowExecutionCount{}
	err = c.client.Do("CountClosedWorkflowExecutions", "POST", "/", req, resp)
	return
}

// CountOpenWorkflowExecutions returns the number of open workflow
// executions within the given domain that meet the specified filtering
// criteria. You can use IAM policies to control this action's access to
// Amazon SWF resources as follows: Use a Resource element with the domain
// name to limit the action to only specified domains. Use an Action
// element to allow or deny permission to call this action. Constrain the
// following parameters by using a Condition element with the appropriate
// keys. tagFilter.tag : String constraint. The key is swf:tagFilter.tag
// typeFilter.name : String constraint. The key is swf:typeFilter.name
// typeFilter.version : String constraint. The key is
// swf:typeFilter.version If the caller does not have sufficient
// permissions to invoke the action, or the parameter values fall outside
// the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) CountOpenWorkflowExecutions(req *CountOpenWorkflowExecutionsInput) (resp *WorkflowExecutionCount, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowExecutionCount{}
	err = c.client.Do("CountOpenWorkflowExecutions", "POST", "/", req, resp)
	return
}

// CountPendingActivityTasks returns the estimated number of activity tasks
// in the specified task list. The count returned is an approximation and
// is not guaranteed to be exact. If you specify a task list that no
// activity task was ever scheduled in then 0 will be returned. You can use
// IAM policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. Constrain the taskList.name parameter by
// using a Condition element with the swf:taskList.name key to allow the
// action to access only certain task lists. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) CountPendingActivityTasks(req *CountPendingActivityTasksInput) (resp *PendingTaskCount, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &PendingTaskCount{}
	err = c.client.Do("CountPendingActivityTasks", "POST", "/", req, resp)
	return
}

// CountPendingDecisionTasks returns the estimated number of decision tasks
// in the specified task list. The count returned is an approximation and
// is not guaranteed to be exact. If you specify a task list that no
// decision task was ever scheduled in then 0 will be returned. You can use
// IAM policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. Constrain the taskList.name parameter by
// using a Condition element with the swf:taskList.name key to allow the
// action to access only certain task lists. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) CountPendingDecisionTasks(req *CountPendingDecisionTasksInput) (resp *PendingTaskCount, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &PendingTaskCount{}
	err = c.client.Do("CountPendingDecisionTasks", "POST", "/", req, resp)
	return
}

// DeprecateActivityType deprecates the specified activity type . After an
// activity type has been deprecated, you cannot create new tasks of that
// activity type. Tasks of this type that were scheduled before the type
// was deprecated will continue to run. You can use IAM policies to control
// this action's access to Amazon SWF resources as follows: Use a Resource
// element with the domain name to limit the action to only specified
// domains. Use an Action element to allow or deny permission to call this
// action. Constrain the following parameters by using a Condition element
// with the appropriate keys. activityType.name : String constraint. The
// key is swf:activityType.name activityType.version : String constraint.
// The key is swf:activityType.version If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) DeprecateActivityType(req *DeprecateActivityTypeInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeprecateActivityType", "POST", "/", req, nil)
	return
}

// DeprecateDomain deprecates the specified domain. After a domain has been
// deprecated it cannot be used to create new workflow executions or
// register new types. However, you can still use visibility actions on
// this domain. Deprecating a domain also deprecates all activity and
// workflow types registered in the domain. Executions that were started
// before the domain was deprecated will continue to run. You can use IAM
// policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. You cannot use an IAM policy to
// constrain this action's parameters. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) DeprecateDomain(req *DeprecateDomainInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeprecateDomain", "POST", "/", req, nil)
	return
}

// DeprecateWorkflowType deprecates the specified workflow type . After a
// workflow type has been deprecated, you cannot create new executions of
// that type. Executions that were started before the type was deprecated
// will continue to run. A deprecated workflow type may still be used when
// calling visibility actions. You can use IAM policies to control this
// action's access to Amazon SWF resources as follows: Use a Resource
// element with the domain name to limit the action to only specified
// domains. Use an Action element to allow or deny permission to call this
// action. Constrain the following parameters by using a Condition element
// with the appropriate keys. workflowType.name : String constraint. The
// key is swf:workflowType.name workflowType.version : String constraint.
// The key is swf:workflowType.version If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) DeprecateWorkflowType(req *DeprecateWorkflowTypeInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("DeprecateWorkflowType", "POST", "/", req, nil)
	return
}

// DescribeActivityType returns information about the specified activity
// type. This includes configuration settings provided at registration time
// as well as other general information about the type. You can use IAM
// policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. Constrain the following parameters by
// using a Condition element with the appropriate keys. activityType.name :
// String constraint. The key is swf:activityType.name activityType.version
// : String constraint. The key is swf:activityType.version If the caller
// does not have sufficient permissions to invoke the action, or the
// parameter values fall outside the specified constraints, the action
// fails by throwing OperationNotPermitted . For details and example IAM
// policies, see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) DescribeActivityType(req *DescribeActivityTypeInput) (resp *ActivityTypeDetail, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ActivityTypeDetail{}
	err = c.client.Do("DescribeActivityType", "POST", "/", req, resp)
	return
}

// DescribeDomain returns information about the specified domain including
// description and status. You can use IAM policies to control this
// action's access to Amazon SWF resources as follows: Use a Resource
// element with the domain name to limit the action to only specified
// domains. Use an Action element to allow or deny permission to call this
// action. You cannot use an IAM policy to constrain this action's
// parameters. If the caller does not have sufficient permissions to invoke
// the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) DescribeDomain(req *DescribeDomainInput) (resp *DomainDetail, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DomainDetail{}
	err = c.client.Do("DescribeDomain", "POST", "/", req, resp)
	return
}

// DescribeWorkflowExecution returns information about the specified
// workflow execution including its type and some statistics. You can use
// IAM policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. You cannot use an IAM policy to
// constrain this action's parameters. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) DescribeWorkflowExecution(req *DescribeWorkflowExecutionInput) (resp *WorkflowExecutionDetail, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowExecutionDetail{}
	err = c.client.Do("DescribeWorkflowExecution", "POST", "/", req, resp)
	return
}

// DescribeWorkflowType returns information about the specified workflow
// type . This includes configuration settings specified when the type was
// registered and other information such as creation date, current status,
// etc. You can use IAM policies to control this action's access to Amazon
// SWF resources as follows: Use a Resource element with the domain name to
// limit the action to only specified domains. Use an Action element to
// allow or deny permission to call this action. Constrain the following
// parameters by using a Condition element with the appropriate keys.
// workflowType.name : String constraint. The key is swf:workflowType.name
// workflowType.version : String constraint. The key is
// swf:workflowType.version If the caller does not have sufficient
// permissions to invoke the action, or the parameter values fall outside
// the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) DescribeWorkflowType(req *DescribeWorkflowTypeInput) (resp *WorkflowTypeDetail, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowTypeDetail{}
	err = c.client.Do("DescribeWorkflowType", "POST", "/", req, resp)
	return
}

// GetWorkflowExecutionHistory returns the history of the specified
// workflow execution. The results may be split into multiple pages. To
// retrieve subsequent pages, make the call again using the nextPageToken
// returned by the initial call. You can use IAM policies to control this
// action's access to Amazon SWF resources as follows: Use a Resource
// element with the domain name to limit the action to only specified
// domains. Use an Action element to allow or deny permission to call this
// action. You cannot use an IAM policy to constrain this action's
// parameters. If the caller does not have sufficient permissions to invoke
// the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) GetWorkflowExecutionHistory(req *GetWorkflowExecutionHistoryInput) (resp *History, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &History{}
	err = c.client.Do("GetWorkflowExecutionHistory", "POST", "/", req, resp)
	return
}

// ListActivityTypes returns information about all activities registered in
// the specified domain that match the specified name and registration
// status. The result includes information like creation date, current
// status of the activity, etc. The results may be split into multiple
// pages. To retrieve subsequent pages, make the call again using the
// nextPageToken returned by the initial call. You can use IAM policies to
// control this action's access to Amazon SWF resources as follows: Use a
// Resource element with the domain name to limit the action to only
// specified domains. Use an Action element to allow or deny permission to
// call this action. You cannot use an IAM policy to constrain this
// action's parameters. If the caller does not have sufficient permissions
// to invoke the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) ListActivityTypes(req *ListActivityTypesInput) (resp *ActivityTypeInfos, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ActivityTypeInfos{}
	err = c.client.Do("ListActivityTypes", "POST", "/", req, resp)
	return
}

// ListClosedWorkflowExecutions returns a list of closed workflow
// executions in the specified domain that meet the filtering criteria. The
// results may be split into multiple pages. To retrieve subsequent pages,
// make the call again using the nextPageToken returned by the initial
// call. You can use IAM policies to control this action's access to Amazon
// SWF resources as follows: Use a Resource element with the domain name to
// limit the action to only specified domains. Use an Action element to
// allow or deny permission to call this action. Constrain the following
// parameters by using a Condition element with the appropriate keys.
// tagFilter.tag : String constraint. The key is swf:tagFilter.tag
// typeFilter.name : String constraint. The key is swf:typeFilter.name
// typeFilter.version : String constraint. The key is
// swf:typeFilter.version If the caller does not have sufficient
// permissions to invoke the action, or the parameter values fall outside
// the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) ListClosedWorkflowExecutions(req *ListClosedWorkflowExecutionsInput) (resp *WorkflowExecutionInfos, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowExecutionInfos{}
	err = c.client.Do("ListClosedWorkflowExecutions", "POST", "/", req, resp)
	return
}

// ListDomains returns the list of domains registered in the account. The
// results may be split into multiple pages. To retrieve subsequent pages,
// make the call again using the nextPageToken returned by the initial
// call. You can use IAM policies to control this action's access to Amazon
// SWF resources as follows: Use a Resource element with the domain name to
// limit the action to only specified domains. The element must be set to
// arn:aws:swf::AccountID:domain/*" , where "AccountID" is the account ID,
// with no dashes. Use an Action element to allow or deny permission to
// call this action. You cannot use an IAM policy to constrain this
// action's parameters. If the caller does not have sufficient permissions
// to invoke the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) ListDomains(req *ListDomainsInput) (resp *DomainInfos, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DomainInfos{}
	err = c.client.Do("ListDomains", "POST", "/", req, resp)
	return
}

// ListOpenWorkflowExecutions returns a list of open workflow executions in
// the specified domain that meet the filtering criteria. The results may
// be split into multiple pages. To retrieve subsequent pages, make the
// call again using the nextPageToken returned by the initial call. You can
// use IAM policies to control this action's access to Amazon SWF resources
// as follows: Use a Resource element with the domain name to limit the
// action to only specified domains. Use an Action element to allow or deny
// permission to call this action. Constrain the following parameters by
// using a Condition element with the appropriate keys. tagFilter.tag :
// String constraint. The key is swf:tagFilter.tag typeFilter.name : String
// constraint. The key is swf:typeFilter.name typeFilter.version : String
// constraint. The key is swf:typeFilter.version If the caller does not
// have sufficient permissions to invoke the action, or the parameter
// values fall outside the specified constraints, the action fails by
// throwing OperationNotPermitted . For details and example IAM policies,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) ListOpenWorkflowExecutions(req *ListOpenWorkflowExecutionsInput) (resp *WorkflowExecutionInfos, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowExecutionInfos{}
	err = c.client.Do("ListOpenWorkflowExecutions", "POST", "/", req, resp)
	return
}

// ListWorkflowTypes returns information about workflow types in the
// specified domain. The results may be split into multiple pages that can
// be retrieved by making the call repeatedly. You can use IAM policies to
// control this action's access to Amazon SWF resources as follows: Use a
// Resource element with the domain name to limit the action to only
// specified domains. Use an Action element to allow or deny permission to
// call this action. You cannot use an IAM policy to constrain this
// action's parameters. If the caller does not have sufficient permissions
// to invoke the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) ListWorkflowTypes(req *ListWorkflowTypesInput) (resp *WorkflowTypeInfos, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &WorkflowTypeInfos{}
	err = c.client.Do("ListWorkflowTypes", "POST", "/", req, resp)
	return
}

// PollForActivityTask used by workers to get an ActivityTask from the
// specified activity taskList . This initiates a long poll, where the
// service holds the connection open and responds as soon as a task becomes
// available. The maximum time the service holds on to the request before
// responding is 60 seconds. If no task is available within 60 seconds, the
// poll will return an empty result. An empty result, in this context,
// means that an ActivityTask is returned, but that the value of taskToken
// is an empty string. If a task is returned, the worker should use its
// type to identify and process it correctly. Workers should set their
// client side socket timeout to at least 70 seconds (10 seconds higher
// than the maximum time service may hold the poll request). You can use
// IAM policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. Constrain the taskList.name parameter by
// using a Condition element with the swf:taskList.name key to allow the
// action to access only certain task lists. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) PollForActivityTask(req *PollForActivityTaskInput) (resp *ActivityTask, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ActivityTask{}
	err = c.client.Do("PollForActivityTask", "POST", "/", req, resp)
	return
}

// PollForDecisionTask used by deciders to get a DecisionTask from the
// specified decision taskList . A decision task may be returned for any
// open workflow execution that is using the specified task list. The task
// includes a paginated view of the history of the workflow execution. The
// decider should use the workflow type and the history to determine how to
// properly handle the task. This action initiates a long poll, where the
// service holds the connection open and responds as soon a task becomes
// available. If no decision task is available in the specified task list
// before the timeout of 60 seconds expires, an empty result is returned.
// An empty result, in this context, means that a DecisionTask is returned,
// but that the value of taskToken is an empty string. Deciders should set
// their client side socket timeout to at least 70 seconds (10 seconds
// higher than the timeout). Because the number of workflow history events
// for a single workflow execution might be very large, the result returned
// might be split up across a number of pages. To retrieve subsequent
// pages, make additional calls to PollForDecisionTask using the
// nextPageToken returned by the initial call. Note that you do not call
// GetWorkflowExecutionHistory with this nextPageToken . Instead, call
// PollForDecisionTask again. You can use IAM policies to control this
// action's access to Amazon SWF resources as follows: Use a Resource
// element with the domain name to limit the action to only specified
// domains. Use an Action element to allow or deny permission to call this
// action. Constrain the taskList.name parameter by using a Condition
// element with the swf:taskList.name key to allow the action to access
// only certain task lists. If the caller does not have sufficient
// permissions to invoke the action, or the parameter values fall outside
// the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) PollForDecisionTask(req *PollForDecisionTaskInput) (resp *DecisionTask, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DecisionTask{}
	err = c.client.Do("PollForDecisionTask", "POST", "/", req, resp)
	return
}

// RecordActivityTaskHeartbeat used by activity workers to report to the
// service that the ActivityTask represented by the specified taskToken is
// still making progress. The worker can also (optionally) specify details
// of the progress, for example percent complete, using the details
// parameter. This action can also be used by the worker as a mechanism to
// check if cancellation is being requested for the activity task. If a
// cancellation is being attempted for the specified task, then the boolean
// cancelRequested flag returned by the service is set to true . This
// action resets the taskHeartbeatTimeout clock. The taskHeartbeatTimeout
// is specified in RegisterActivityType . This action does not in itself
// create an event in the workflow execution history. However, if the task
// times out, the workflow execution history will contain a
// ActivityTaskTimedOut event that contains the information from the last
// heartbeat generated by the activity worker. If the cancelRequested flag
// returns true , a cancellation is being attempted. If the worker can
// cancel the activity, it should respond with RespondActivityTaskCanceled
// . Otherwise, it should ignore the cancellation request. You can use IAM
// policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. You cannot use an IAM policy to
// constrain this action's parameters. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RecordActivityTaskHeartbeat(req *RecordActivityTaskHeartbeatInput) (resp *ActivityTaskStatus, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &ActivityTaskStatus{}
	err = c.client.Do("RecordActivityTaskHeartbeat", "POST", "/", req, resp)
	return
}

// RegisterActivityType registers a new activity type along with its
// configuration settings in the specified domain. A TypeAlreadyExists
// fault is returned if the type already exists in the domain. You cannot
// change any configuration settings of the type after its registration,
// and it must be registered as a new version. You can use IAM policies to
// control this action's access to Amazon SWF resources as follows: Use a
// Resource element with the domain name to limit the action to only
// specified domains. Use an Action element to allow or deny permission to
// call this action. Constrain the following parameters by using a
// Condition element with the appropriate keys. defaultTaskList.name :
// String constraint. The key is swf:defaultTaskList.name name : String
// constraint. The key is swf:name version : String constraint. The key is
// swf:version If the caller does not have sufficient permissions to invoke
// the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) RegisterActivityType(req *RegisterActivityTypeInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RegisterActivityType", "POST", "/", req, nil)
	return
}

// RegisterDomain you can use IAM policies to control this action's access
// to Amazon SWF resources as follows: You cannot use an IAM policy to
// control domain access for this action. The name of the domain being
// registered is available as the resource of this action. Use an Action
// element to allow or deny permission to call this action. You cannot use
// an IAM policy to constrain this action's parameters. If the caller does
// not have sufficient permissions to invoke the action, or the parameter
// values fall outside the specified constraints, the action fails by
// throwing OperationNotPermitted . For details and example IAM policies,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RegisterDomain(req *RegisterDomainInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RegisterDomain", "POST", "/", req, nil)
	return
}

// RegisterWorkflowType registers a new workflow type and its configuration
// settings in the specified domain. The retention period for the workflow
// history is set by the RegisterDomain action. If the type already exists,
// then a TypeAlreadyExists fault is returned. You cannot change the
// configuration settings of a workflow type once it is registered and it
// must be registered as a new version. You can use IAM policies to control
// this action's access to Amazon SWF resources as follows: Use a Resource
// element with the domain name to limit the action to only specified
// domains. Use an Action element to allow or deny permission to call this
// action. Constrain the following parameters by using a Condition element
// with the appropriate keys. defaultTaskList.name : String constraint. The
// key is swf:defaultTaskList.name name : String constraint. The key is
// swf:name version : String constraint. The key is swf:version If the
// caller does not have sufficient permissions to invoke the action, or the
// parameter values fall outside the specified constraints, the action
// fails by throwing OperationNotPermitted . For details and example IAM
// policies, see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RegisterWorkflowType(req *RegisterWorkflowTypeInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RegisterWorkflowType", "POST", "/", req, nil)
	return
}

// RequestCancelWorkflowExecution records a
// WorkflowExecutionCancelRequested event in the currently running workflow
// execution identified by the given domain, workflowId, and runId. This
// logically requests the cancellation of the workflow execution as a
// whole. It is up to the decider to take appropriate actions when it
// receives an execution history with this event. You can use IAM policies
// to control this action's access to Amazon SWF resources as follows: Use
// a Resource element with the domain name to limit the action to only
// specified domains. Use an Action element to allow or deny permission to
// call this action. You cannot use an IAM policy to constrain this
// action's parameters. If the caller does not have sufficient permissions
// to invoke the action, or the parameter values fall outside the specified
// constraints, the action fails by throwing OperationNotPermitted . For
// details and example IAM policies, see Using IAM to Manage Access to
// Amazon SWF Workflows
func (c *SWF) RequestCancelWorkflowExecution(req *RequestCancelWorkflowExecutionInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RequestCancelWorkflowExecution", "POST", "/", req, nil)
	return
}

// RespondActivityTaskCanceled used by workers to tell the service that the
// ActivityTask identified by the taskToken was successfully canceled.
// Additional details can be optionally provided using the details
// argument. These details (if provided) appear in the ActivityTaskCanceled
// event added to the workflow history. Only use this operation if the
// canceled flag of a RecordActivityTaskHeartbeat request returns true and
// if the activity can be safely undone or abandoned. A task is considered
// open from the time that it is scheduled until it is closed. Therefore a
// task is reported as open while a worker is processing it. A task is
// closed after it has been specified in a call to
// RespondActivityTaskCompleted , RespondActivityTaskCanceled,
// RespondActivityTaskFailed , or the task has timed out . You can use IAM
// policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. You cannot use an IAM policy to
// constrain this action's parameters. If the caller does not have
// sufficient permissions to invoke the action, or the parameter values
// fall outside the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RespondActivityTaskCanceled(req *RespondActivityTaskCanceledInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RespondActivityTaskCanceled", "POST", "/", req, nil)
	return
}

// RespondActivityTaskCompleted used by workers to tell the service that
// the ActivityTask identified by the taskToken completed successfully with
// a result (if provided). The result appears in the ActivityTaskCompleted
// event in the workflow history. If the requested task does not complete
// successfully, use RespondActivityTaskFailed instead. If the worker finds
// that the task is canceled through the canceled flag returned by
// RecordActivityTaskHeartbeat , it should cancel the task, clean up and
// then call RespondActivityTaskCanceled . A task is considered open from
// the time that it is scheduled until it is closed. Therefore a task is
// reported as open while a worker is processing it. A task is closed after
// it has been specified in a call to RespondActivityTaskCompleted,
// RespondActivityTaskCanceled , RespondActivityTaskFailed , or the task
// has timed out . You can use IAM policies to control this action's access
// to Amazon SWF resources as follows: Use a Resource element with the
// domain name to limit the action to only specified domains. Use an Action
// element to allow or deny permission to call this action. You cannot use
// an IAM policy to constrain this action's parameters. If the caller does
// not have sufficient permissions to invoke the action, or the parameter
// values fall outside the specified constraints, the action fails by
// throwing OperationNotPermitted . For details and example IAM policies,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RespondActivityTaskCompleted(req *RespondActivityTaskCompletedInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RespondActivityTaskCompleted", "POST", "/", req, nil)
	return
}

// RespondActivityTaskFailed used by workers to tell the service that the
// ActivityTask identified by the taskToken has failed with reason (if
// specified). The reason and details appear in the ActivityTaskFailed
// event added to the workflow history. A task is considered open from the
// time that it is scheduled until it is closed. Therefore a task is
// reported as open while a worker is processing it. A task is closed after
// it has been specified in a call to RespondActivityTaskCompleted ,
// RespondActivityTaskCanceled , RespondActivityTaskFailed, or the task has
// timed out . You can use IAM policies to control this action's access to
// Amazon SWF resources as follows: Use a Resource element with the domain
// name to limit the action to only specified domains. Use an Action
// element to allow or deny permission to call this action. You cannot use
// an IAM policy to constrain this action's parameters. If the caller does
// not have sufficient permissions to invoke the action, or the parameter
// values fall outside the specified constraints, the action fails by
// throwing OperationNotPermitted . For details and example IAM policies,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RespondActivityTaskFailed(req *RespondActivityTaskFailedInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RespondActivityTaskFailed", "POST", "/", req, nil)
	return
}

// RespondDecisionTaskCompleted used by deciders to tell the service that
// the DecisionTask identified by the taskToken has successfully completed.
// The decisions argument specifies the list of decisions made while
// processing the task. A DecisionTaskCompleted event is added to the
// workflow history. The executionContext specified is attached to the
// event in the workflow execution history. If an IAM policy grants
// permission to use RespondDecisionTaskCompleted , it can express
// permissions for the list of decisions in the decisions parameter. Each
// of the decisions has one or more parameters, much like a regular API
// call. To allow for policies to be as readable as possible, you can
// express permissions on decisions as if they were actual API calls,
// including applying conditions to some parameters. For more information,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) RespondDecisionTaskCompleted(req *RespondDecisionTaskCompletedInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("RespondDecisionTaskCompleted", "POST", "/", req, nil)
	return
}

// SignalWorkflowExecution records a WorkflowExecutionSignaled event in the
// workflow execution history and creates a decision task for the workflow
// execution identified by the given domain, workflowId and runId. The
// event is recorded with the specified user defined signalName and input
// (if provided). You can use IAM policies to control this action's access
// to Amazon SWF resources as follows: Use a Resource element with the
// domain name to limit the action to only specified domains. Use an Action
// element to allow or deny permission to call this action. You cannot use
// an IAM policy to constrain this action's parameters. If the caller does
// not have sufficient permissions to invoke the action, or the parameter
// values fall outside the specified constraints, the action fails by
// throwing OperationNotPermitted . For details and example IAM policies,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) SignalWorkflowExecution(req *SignalWorkflowExecutionInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("SignalWorkflowExecution", "POST", "/", req, nil)
	return
}

// StartWorkflowExecution starts an execution of the workflow type in the
// specified domain using the provided workflowId and input data. This
// action returns the newly started workflow execution. You can use IAM
// policies to control this action's access to Amazon SWF resources as
// follows: Use a Resource element with the domain name to limit the action
// to only specified domains. Use an Action element to allow or deny
// permission to call this action. Constrain the following parameters by
// using a Condition element with the appropriate keys. tagList.member.0 :
// The key is swf:tagList.member.0 tagList.member.1 : The key is
// swf:tagList.member.1 tagList.member.2 : The key is swf:tagList.member.2
// tagList.member.3 : The key is swf:tagList.member.3 tagList.member.4 :
// The key is swf:tagList.member.4 taskList : String constraint. The key is
// swf:taskList.name name : String constraint. The key is
// swf:workflowType.name version : String constraint. The key is
// swf:workflowType.version If the caller does not have sufficient
// permissions to invoke the action, or the parameter values fall outside
// the specified constraints, the action fails by throwing
// OperationNotPermitted . For details and example IAM policies, see Using
// IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) StartWorkflowExecution(req *StartWorkflowExecutionInput) (resp *Run, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &Run{}
	err = c.client.Do("StartWorkflowExecution", "POST", "/", req, resp)
	return
}

// TerminateWorkflowExecution records a WorkflowExecutionTerminated event
// and forces closure of the workflow execution identified by the given
// domain, runId, and workflowId. The child policy, registered with the
// workflow type or specified when starting this execution, is applied to
// any open child workflow executions of this workflow execution. If the
// identified workflow execution was in progress, it is terminated
// immediately. You can use IAM policies to control this action's access to
// Amazon SWF resources as follows: Use a Resource element with the domain
// name to limit the action to only specified domains. Use an Action
// element to allow or deny permission to call this action. You cannot use
// an IAM policy to constrain this action's parameters. If the caller does
// not have sufficient permissions to invoke the action, or the parameter
// values fall outside the specified constraints, the action fails by
// throwing OperationNotPermitted . For details and example IAM policies,
// see Using IAM to Manage Access to Amazon SWF Workflows
func (c *SWF) TerminateWorkflowExecution(req *TerminateWorkflowExecutionInput) (err error) {
	if err = req.Validate(); err != nil {
		return
	}

	// NRE
	err = c.client.Do("TerminateWorkflowExecution", "POST", "/", req, nil)
	return
}

// ActivityTask is undocumented.
type ActivityTask struct {
	ActivityID        aws.StringValue    `json:"activityId"`
	ActivityType      *ActivityType      `json:"activityType"`
	Input             aws.StringValue    `json:"input,omitempty"`
	StartedEventID    aws.LongValue      `json:"startedEventId"`
	TaskToken         aws.StringValue    `json:"taskToken"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
}

func (v *ActivityTask) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskCancelRequestedEventAttributes is undocumented.
type ActivityTaskCancelRequestedEventAttributes struct {
	ActivityID                   aws.StringValue `json:"activityId"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *ActivityTaskCancelRequestedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskCanceledEventAttributes is undocumented.
type ActivityTaskCanceledEventAttributes struct {
	Details                      aws.StringValue `json:"details,omitempty"`
	LatestCancelRequestedEventID aws.LongValue   `json:"latestCancelRequestedEventId,omitempty"`
	ScheduledEventID             aws.LongValue   `json:"scheduledEventId"`
	StartedEventID               aws.LongValue   `json:"startedEventId"`
}

func (v *ActivityTaskCanceledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskCompletedEventAttributes is undocumented.
type ActivityTaskCompletedEventAttributes struct {
	Result           aws.StringValue `json:"result,omitempty"`
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
	StartedEventID   aws.LongValue   `json:"startedEventId"`
}

func (v *ActivityTaskCompletedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Result", 32768); err != nil {
		errors["Result"] = append(errors["Result"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskFailedEventAttributes is undocumented.
type ActivityTaskFailedEventAttributes struct {
	Details          aws.StringValue `json:"details,omitempty"`
	Reason           aws.StringValue `json:"reason,omitempty"`
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
	StartedEventID   aws.LongValue   `json:"startedEventId"`
}

func (v *ActivityTaskFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskScheduledEventAttributes is undocumented.
type ActivityTaskScheduledEventAttributes struct {
	ActivityID                   aws.StringValue `json:"activityId"`
	ActivityType                 *ActivityType   `json:"activityType"`
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	HeartbeatTimeout             aws.StringValue `json:"heartbeatTimeout,omitempty"`
	Input                        aws.StringValue `json:"input,omitempty"`
	ScheduleToCloseTimeout       aws.StringValue `json:"scheduleToCloseTimeout,omitempty"`
	ScheduleToStartTimeout       aws.StringValue `json:"scheduleToStartTimeout,omitempty"`
	StartToCloseTimeout          aws.StringValue `json:"startToCloseTimeout,omitempty"`
	TaskList                     *TaskList       `json:"taskList"`
}

func (v *ActivityTaskScheduledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "HeartbeatTimeout", 8); err != nil {
		errors["HeartbeatTimeout"] = append(errors["HeartbeatTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "ScheduleToCloseTimeout", 8); err != nil {
		errors["ScheduleToCloseTimeout"] = append(errors["ScheduleToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "ScheduleToStartTimeout", 8); err != nil {
		errors["ScheduleToStartTimeout"] = append(errors["ScheduleToStartTimeout"], err)
	}

	if err := model.ValidateMax(v, "StartToCloseTimeout", 8); err != nil {
		errors["StartToCloseTimeout"] = append(errors["StartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskStartedEventAttributes is undocumented.
type ActivityTaskStartedEventAttributes struct {
	Identity         aws.StringValue `json:"identity,omitempty"`
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
}

func (v *ActivityTaskStartedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Identity", 256); err != nil {
		errors["Identity"] = append(errors["Identity"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskStatus is undocumented.
type ActivityTaskStatus struct {
	CancelRequested aws.BooleanValue `json:"cancelRequested"`
}

func (v *ActivityTaskStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CancelRequested"); err != nil {
		errors["CancelRequested"] = append(errors["CancelRequested"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTaskTimedOutEventAttributes is undocumented.
type ActivityTaskTimedOutEventAttributes struct {
	Details          aws.StringValue `json:"details,omitempty"`
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
	StartedEventID   aws.LongValue   `json:"startedEventId"`
	TimeoutType      aws.StringValue `json:"timeoutType"`
}

func (v *ActivityTaskTimedOutEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 2048); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimeoutType"); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	timeoutTypeEnum := []string{
		ActivityTaskTimeoutTypeHeartbeat,
		ActivityTaskTimeoutTypeScheduleToClose,
		ActivityTaskTimeoutTypeScheduleToStart,
		ActivityTaskTimeoutTypeStartToClose,
	}
	if err := model.ValidateEnum(v, "TimeoutType", timeoutTypeEnum); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	ActivityTaskTimeoutTypeHeartbeat       = "HEARTBEAT"
	ActivityTaskTimeoutTypeScheduleToClose = "SCHEDULE_TO_CLOSE"
	ActivityTaskTimeoutTypeScheduleToStart = "SCHEDULE_TO_START"
	ActivityTaskTimeoutTypeStartToClose    = "START_TO_CLOSE"
)

// ActivityType is undocumented.
type ActivityType struct {
	Name    aws.StringValue `json:"name"`
	Version aws.StringValue `json:"version"`
}

func (v *ActivityType) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "Version"); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMin(v, "Version", 1); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMax(v, "Version", 64); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTypeConfiguration is undocumented.
type ActivityTypeConfiguration struct {
	DefaultTaskHeartbeatTimeout       aws.StringValue `json:"defaultTaskHeartbeatTimeout,omitempty"`
	DefaultTaskList                   *TaskList       `json:"defaultTaskList,omitempty"`
	DefaultTaskScheduleToCloseTimeout aws.StringValue `json:"defaultTaskScheduleToCloseTimeout,omitempty"`
	DefaultTaskScheduleToStartTimeout aws.StringValue `json:"defaultTaskScheduleToStartTimeout,omitempty"`
	DefaultTaskStartToCloseTimeout    aws.StringValue `json:"defaultTaskStartToCloseTimeout,omitempty"`
}

func (v *ActivityTypeConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultTaskHeartbeatTimeout", 8); err != nil {
		errors["DefaultTaskHeartbeatTimeout"] = append(errors["DefaultTaskHeartbeatTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskScheduleToCloseTimeout", 8); err != nil {
		errors["DefaultTaskScheduleToCloseTimeout"] = append(errors["DefaultTaskScheduleToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskScheduleToStartTimeout", 8); err != nil {
		errors["DefaultTaskScheduleToStartTimeout"] = append(errors["DefaultTaskScheduleToStartTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskStartToCloseTimeout", 8); err != nil {
		errors["DefaultTaskStartToCloseTimeout"] = append(errors["DefaultTaskStartToCloseTimeout"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTypeDetail is undocumented.
type ActivityTypeDetail struct {
	Configuration *ActivityTypeConfiguration `json:"configuration"`
	TypeInfo      *ActivityTypeInfo          `json:"typeInfo"`
}

func (v *ActivityTypeDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Configuration"); err != nil {
		errors["Configuration"] = append(errors["Configuration"], err)
	}

	if err := model.ValidateRequired(v, "TypeInfo"); err != nil {
		errors["TypeInfo"] = append(errors["TypeInfo"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTypeInfo is undocumented.
type ActivityTypeInfo struct {
	ActivityType    *ActivityType      `json:"activityType"`
	CreationDate    *aws.LongTimestamp `json:"creationDate"`
	DeprecationDate *aws.LongTimestamp `json:"deprecationDate,omitempty"`
	Description     aws.StringValue    `json:"description,omitempty"`
	Status          aws.StringValue    `json:"status"`
}

func (v *ActivityTypeInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateRequired(v, "CreationDate"); err != nil {
		errors["CreationDate"] = append(errors["CreationDate"], err)
	}

	if err := model.ValidateMax(v, "Description", 1024); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	statusEnum := []string{
		RegistrationStatusDeprecated,
		RegistrationStatusRegistered,
	}
	if err := model.ValidateEnum(v, "Status", statusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ActivityTypeInfos is undocumented.
type ActivityTypeInfos struct {
	NextPageToken aws.StringValue    `json:"nextPageToken,omitempty"`
	TypeInfos     []ActivityTypeInfo `json:"typeInfos"`
}

func (v *ActivityTypeInfos) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "TypeInfos"); err != nil {
		errors["TypeInfos"] = append(errors["TypeInfos"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelTimerDecisionAttributes is undocumented.
type CancelTimerDecisionAttributes struct {
	TimerID aws.StringValue `json:"timerId"`
}

func (v *CancelTimerDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	CancelTimerFailedCauseOperationNotPermitted = "OPERATION_NOT_PERMITTED"
	CancelTimerFailedCauseTimerIDUnknown        = "TIMER_ID_UNKNOWN"
)

// CancelTimerFailedEventAttributes is undocumented.
type CancelTimerFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	TimerID                      aws.StringValue `json:"timerId"`
}

func (v *CancelTimerFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		CancelTimerFailedCauseOperationNotPermitted,
		CancelTimerFailedCauseTimerIDUnknown,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CancelWorkflowExecutionDecisionAttributes is undocumented.
type CancelWorkflowExecutionDecisionAttributes struct {
	Details aws.StringValue `json:"details,omitempty"`
}

func (v *CancelWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	CancelWorkflowExecutionFailedCauseOperationNotPermitted = "OPERATION_NOT_PERMITTED"
	CancelWorkflowExecutionFailedCauseUnhandledDecision     = "UNHANDLED_DECISION"
)

// CancelWorkflowExecutionFailedEventAttributes is undocumented.
type CancelWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *CancelWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		CancelWorkflowExecutionFailedCauseOperationNotPermitted,
		CancelWorkflowExecutionFailedCauseUnhandledDecision,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	ChildPolicyAbandon       = "ABANDON"
	ChildPolicyRequestCancel = "REQUEST_CANCEL"
	ChildPolicyTerminate     = "TERMINATE"
)

// ChildWorkflowExecutionCanceledEventAttributes is undocumented.
type ChildWorkflowExecutionCanceledEventAttributes struct {
	Details           aws.StringValue    `json:"details,omitempty"`
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	StartedEventID    aws.LongValue      `json:"startedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
	WorkflowType      *WorkflowType      `json:"workflowType"`
}

func (v *ChildWorkflowExecutionCanceledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChildWorkflowExecutionCompletedEventAttributes is undocumented.
type ChildWorkflowExecutionCompletedEventAttributes struct {
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	Result            aws.StringValue    `json:"result,omitempty"`
	StartedEventID    aws.LongValue      `json:"startedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
	WorkflowType      *WorkflowType      `json:"workflowType"`
}

func (v *ChildWorkflowExecutionCompletedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateMax(v, "Result", 32768); err != nil {
		errors["Result"] = append(errors["Result"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChildWorkflowExecutionFailedEventAttributes is undocumented.
type ChildWorkflowExecutionFailedEventAttributes struct {
	Details           aws.StringValue    `json:"details,omitempty"`
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	Reason            aws.StringValue    `json:"reason,omitempty"`
	StartedEventID    aws.LongValue      `json:"startedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
	WorkflowType      *WorkflowType      `json:"workflowType"`
}

func (v *ChildWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChildWorkflowExecutionStartedEventAttributes is undocumented.
type ChildWorkflowExecutionStartedEventAttributes struct {
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
	WorkflowType      *WorkflowType      `json:"workflowType"`
}

func (v *ChildWorkflowExecutionStartedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChildWorkflowExecutionTerminatedEventAttributes is undocumented.
type ChildWorkflowExecutionTerminatedEventAttributes struct {
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	StartedEventID    aws.LongValue      `json:"startedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
	WorkflowType      *WorkflowType      `json:"workflowType"`
}

func (v *ChildWorkflowExecutionTerminatedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ChildWorkflowExecutionTimedOutEventAttributes is undocumented.
type ChildWorkflowExecutionTimedOutEventAttributes struct {
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	StartedEventID    aws.LongValue      `json:"startedEventId"`
	TimeoutType       aws.StringValue    `json:"timeoutType"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
	WorkflowType      *WorkflowType      `json:"workflowType"`
}

func (v *ChildWorkflowExecutionTimedOutEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimeoutType"); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	timeoutTypeEnum := []string{
		WorkflowExecutionTimeoutTypeStartToClose,
	}
	if err := model.ValidateEnum(v, "TimeoutType", timeoutTypeEnum); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	CloseStatusCanceled       = "CANCELED"
	CloseStatusCompleted      = "COMPLETED"
	CloseStatusContinuedAsNew = "CONTINUED_AS_NEW"
	CloseStatusFailed         = "FAILED"
	CloseStatusTerminated     = "TERMINATED"
	CloseStatusTimedOut       = "TIMED_OUT"
)

// CloseStatusFilter is undocumented.
type CloseStatusFilter struct {
	Status aws.StringValue `json:"status"`
}

func (v *CloseStatusFilter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	statusEnum := []string{
		CloseStatusCanceled,
		CloseStatusCompleted,
		CloseStatusContinuedAsNew,
		CloseStatusFailed,
		CloseStatusTerminated,
		CloseStatusTimedOut,
	}
	if err := model.ValidateEnum(v, "Status", statusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CompleteWorkflowExecutionDecisionAttributes is undocumented.
type CompleteWorkflowExecutionDecisionAttributes struct {
	Result aws.StringValue `json:"result,omitempty"`
}

func (v *CompleteWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Result", 32768); err != nil {
		errors["Result"] = append(errors["Result"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	CompleteWorkflowExecutionFailedCauseOperationNotPermitted = "OPERATION_NOT_PERMITTED"
	CompleteWorkflowExecutionFailedCauseUnhandledDecision     = "UNHANDLED_DECISION"
)

// CompleteWorkflowExecutionFailedEventAttributes is undocumented.
type CompleteWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *CompleteWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		CompleteWorkflowExecutionFailedCauseOperationNotPermitted,
		CompleteWorkflowExecutionFailedCauseUnhandledDecision,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ContinueAsNewWorkflowExecutionDecisionAttributes is undocumented.
type ContinueAsNewWorkflowExecutionDecisionAttributes struct {
	ChildPolicy                  aws.StringValue `json:"childPolicy,omitempty"`
	ExecutionStartToCloseTimeout aws.StringValue `json:"executionStartToCloseTimeout,omitempty"`
	Input                        aws.StringValue `json:"input,omitempty"`
	TagList                      []string        `json:"tagList,omitempty"`
	TaskList                     *TaskList       `json:"taskList,omitempty"`
	TaskStartToCloseTimeout      aws.StringValue `json:"taskStartToCloseTimeout,omitempty"`
	WorkflowTypeVersion          aws.StringValue `json:"workflowTypeVersion,omitempty"`
}

func (v *ContinueAsNewWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateMin(v, "WorkflowTypeVersion", 1); err != nil {
		errors["WorkflowTypeVersion"] = append(errors["WorkflowTypeVersion"], err)
	}

	if err := model.ValidateMax(v, "WorkflowTypeVersion", 64); err != nil {
		errors["WorkflowTypeVersion"] = append(errors["WorkflowTypeVersion"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	ContinueAsNewWorkflowExecutionFailedCauseDefaultChildPolicyUndefined                  = "DEFAULT_CHILD_POLICY_UNDEFINED"
	ContinueAsNewWorkflowExecutionFailedCauseDefaultExecutionStartToCloseTimeoutUndefined = "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED"
	ContinueAsNewWorkflowExecutionFailedCauseDefaultTaskListUndefined                     = "DEFAULT_TASK_LIST_UNDEFINED"
	ContinueAsNewWorkflowExecutionFailedCauseDefaultTaskStartToCloseTimeoutUndefined      = "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED"
	ContinueAsNewWorkflowExecutionFailedCauseOperationNotPermitted                        = "OPERATION_NOT_PERMITTED"
	ContinueAsNewWorkflowExecutionFailedCauseUnhandledDecision                            = "UNHANDLED_DECISION"
	ContinueAsNewWorkflowExecutionFailedCauseWorkflowTypeDeprecated                       = "WORKFLOW_TYPE_DEPRECATED"
	ContinueAsNewWorkflowExecutionFailedCauseWorkflowTypeDoesNotExist                     = "WORKFLOW_TYPE_DOES_NOT_EXIST"
)

// ContinueAsNewWorkflowExecutionFailedEventAttributes is undocumented.
type ContinueAsNewWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *ContinueAsNewWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		ContinueAsNewWorkflowExecutionFailedCauseDefaultChildPolicyUndefined,
		ContinueAsNewWorkflowExecutionFailedCauseDefaultExecutionStartToCloseTimeoutUndefined,
		ContinueAsNewWorkflowExecutionFailedCauseDefaultTaskListUndefined,
		ContinueAsNewWorkflowExecutionFailedCauseDefaultTaskStartToCloseTimeoutUndefined,
		ContinueAsNewWorkflowExecutionFailedCauseOperationNotPermitted,
		ContinueAsNewWorkflowExecutionFailedCauseUnhandledDecision,
		ContinueAsNewWorkflowExecutionFailedCauseWorkflowTypeDeprecated,
		ContinueAsNewWorkflowExecutionFailedCauseWorkflowTypeDoesNotExist,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CountClosedWorkflowExecutionsInput is undocumented.
type CountClosedWorkflowExecutionsInput struct {
	CloseStatusFilter *CloseStatusFilter       `json:"closeStatusFilter,omitempty"`
	CloseTimeFilter   *ExecutionTimeFilter     `json:"closeTimeFilter,omitempty"`
	Domain            aws.StringValue          `json:"domain"`
	ExecutionFilter   *WorkflowExecutionFilter `json:"executionFilter,omitempty"`
	StartTimeFilter   *ExecutionTimeFilter     `json:"startTimeFilter,omitempty"`
	TagFilter         *TagFilter               `json:"tagFilter,omitempty"`
	TypeFilter        *WorkflowTypeFilter      `json:"typeFilter,omitempty"`
}

func (v *CountClosedWorkflowExecutionsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CountOpenWorkflowExecutionsInput is undocumented.
type CountOpenWorkflowExecutionsInput struct {
	Domain          aws.StringValue          `json:"domain"`
	ExecutionFilter *WorkflowExecutionFilter `json:"executionFilter,omitempty"`
	StartTimeFilter *ExecutionTimeFilter     `json:"startTimeFilter"`
	TagFilter       *TagFilter               `json:"tagFilter,omitempty"`
	TypeFilter      *WorkflowTypeFilter      `json:"typeFilter,omitempty"`
}

func (v *CountOpenWorkflowExecutionsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "StartTimeFilter"); err != nil {
		errors["StartTimeFilter"] = append(errors["StartTimeFilter"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CountPendingActivityTasksInput is undocumented.
type CountPendingActivityTasksInput struct {
	Domain   aws.StringValue `json:"domain"`
	TaskList *TaskList       `json:"taskList"`
}

func (v *CountPendingActivityTasksInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CountPendingDecisionTasksInput is undocumented.
type CountPendingDecisionTasksInput struct {
	Domain   aws.StringValue `json:"domain"`
	TaskList *TaskList       `json:"taskList"`
}

func (v *CountPendingDecisionTasksInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Decision is undocumented.
type Decision struct {
	CancelTimerDecisionAttributes                            *CancelTimerDecisionAttributes                            `json:"cancelTimerDecisionAttributes,omitempty"`
	CancelWorkflowExecutionDecisionAttributes                *CancelWorkflowExecutionDecisionAttributes                `json:"cancelWorkflowExecutionDecisionAttributes,omitempty"`
	CompleteWorkflowExecutionDecisionAttributes              *CompleteWorkflowExecutionDecisionAttributes              `json:"completeWorkflowExecutionDecisionAttributes,omitempty"`
	ContinueAsNewWorkflowExecutionDecisionAttributes         *ContinueAsNewWorkflowExecutionDecisionAttributes         `json:"continueAsNewWorkflowExecutionDecisionAttributes,omitempty"`
	DecisionType                                             aws.StringValue                                           `json:"decisionType"`
	FailWorkflowExecutionDecisionAttributes                  *FailWorkflowExecutionDecisionAttributes                  `json:"failWorkflowExecutionDecisionAttributes,omitempty"`
	RecordMarkerDecisionAttributes                           *RecordMarkerDecisionAttributes                           `json:"recordMarkerDecisionAttributes,omitempty"`
	RequestCancelActivityTaskDecisionAttributes              *RequestCancelActivityTaskDecisionAttributes              `json:"requestCancelActivityTaskDecisionAttributes,omitempty"`
	RequestCancelExternalWorkflowExecutionDecisionAttributes *RequestCancelExternalWorkflowExecutionDecisionAttributes `json:"requestCancelExternalWorkflowExecutionDecisionAttributes,omitempty"`
	ScheduleActivityTaskDecisionAttributes                   *ScheduleActivityTaskDecisionAttributes                   `json:"scheduleActivityTaskDecisionAttributes,omitempty"`
	SignalExternalWorkflowExecutionDecisionAttributes        *SignalExternalWorkflowExecutionDecisionAttributes        `json:"signalExternalWorkflowExecutionDecisionAttributes,omitempty"`
	StartChildWorkflowExecutionDecisionAttributes            *StartChildWorkflowExecutionDecisionAttributes            `json:"startChildWorkflowExecutionDecisionAttributes,omitempty"`
	StartTimerDecisionAttributes                             *StartTimerDecisionAttributes                             `json:"startTimerDecisionAttributes,omitempty"`
}

func (v *Decision) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DecisionType"); err != nil {
		errors["DecisionType"] = append(errors["DecisionType"], err)
	}

	decisionTypeEnum := []string{
		DecisionTypeCancelTimer,
		DecisionTypeCancelWorkflowExecution,
		DecisionTypeCompleteWorkflowExecution,
		DecisionTypeContinueAsNewWorkflowExecution,
		DecisionTypeFailWorkflowExecution,
		DecisionTypeRecordMarker,
		DecisionTypeRequestCancelActivityTask,
		DecisionTypeRequestCancelExternalWorkflowExecution,
		DecisionTypeScheduleActivityTask,
		DecisionTypeSignalExternalWorkflowExecution,
		DecisionTypeStartChildWorkflowExecution,
		DecisionTypeStartTimer,
	}
	if err := model.ValidateEnum(v, "DecisionType", decisionTypeEnum); err != nil {
		errors["DecisionType"] = append(errors["DecisionType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DecisionTask is undocumented.
type DecisionTask struct {
	Events                 []HistoryEvent     `json:"events"`
	NextPageToken          aws.StringValue    `json:"nextPageToken,omitempty"`
	PreviousStartedEventID aws.LongValue      `json:"previousStartedEventId,omitempty"`
	StartedEventID         aws.LongValue      `json:"startedEventId"`
	TaskToken              aws.StringValue    `json:"taskToken"`
	WorkflowExecution      *WorkflowExecution `json:"workflowExecution"`
	WorkflowType           *WorkflowType      `json:"workflowType"`
}

func (v *DecisionTask) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Events"); err != nil {
		errors["Events"] = append(errors["Events"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DecisionTaskCompletedEventAttributes is undocumented.
type DecisionTaskCompletedEventAttributes struct {
	ExecutionContext aws.StringValue `json:"executionContext,omitempty"`
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
	StartedEventID   aws.LongValue   `json:"startedEventId"`
}

func (v *DecisionTaskCompletedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "ExecutionContext", 32768); err != nil {
		errors["ExecutionContext"] = append(errors["ExecutionContext"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DecisionTaskScheduledEventAttributes is undocumented.
type DecisionTaskScheduledEventAttributes struct {
	StartToCloseTimeout aws.StringValue `json:"startToCloseTimeout,omitempty"`
	TaskList            *TaskList       `json:"taskList"`
}

func (v *DecisionTaskScheduledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "StartToCloseTimeout", 8); err != nil {
		errors["StartToCloseTimeout"] = append(errors["StartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DecisionTaskStartedEventAttributes is undocumented.
type DecisionTaskStartedEventAttributes struct {
	Identity         aws.StringValue `json:"identity,omitempty"`
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
}

func (v *DecisionTaskStartedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Identity", 256); err != nil {
		errors["Identity"] = append(errors["Identity"], err)
	}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DecisionTaskTimedOutEventAttributes is undocumented.
type DecisionTaskTimedOutEventAttributes struct {
	ScheduledEventID aws.LongValue   `json:"scheduledEventId"`
	StartedEventID   aws.LongValue   `json:"startedEventId"`
	TimeoutType      aws.StringValue `json:"timeoutType"`
}

func (v *DecisionTaskTimedOutEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ScheduledEventID"); err != nil {
		errors["ScheduledEventID"] = append(errors["ScheduledEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimeoutType"); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	timeoutTypeEnum := []string{
		DecisionTaskTimeoutTypeStartToClose,
	}
	if err := model.ValidateEnum(v, "TimeoutType", timeoutTypeEnum); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	DecisionTaskTimeoutTypeStartToClose = "START_TO_CLOSE"
)

// Possible values for SWF.
const (
	DecisionTypeCancelTimer                            = "CancelTimer"
	DecisionTypeCancelWorkflowExecution                = "CancelWorkflowExecution"
	DecisionTypeCompleteWorkflowExecution              = "CompleteWorkflowExecution"
	DecisionTypeContinueAsNewWorkflowExecution         = "ContinueAsNewWorkflowExecution"
	DecisionTypeFailWorkflowExecution                  = "FailWorkflowExecution"
	DecisionTypeRecordMarker                           = "RecordMarker"
	DecisionTypeRequestCancelActivityTask              = "RequestCancelActivityTask"
	DecisionTypeRequestCancelExternalWorkflowExecution = "RequestCancelExternalWorkflowExecution"
	DecisionTypeScheduleActivityTask                   = "ScheduleActivityTask"
	DecisionTypeSignalExternalWorkflowExecution        = "SignalExternalWorkflowExecution"
	DecisionTypeStartChildWorkflowExecution            = "StartChildWorkflowExecution"
	DecisionTypeStartTimer                             = "StartTimer"
)

// DeprecateActivityTypeInput is undocumented.
type DeprecateActivityTypeInput struct {
	ActivityType *ActivityType   `json:"activityType"`
	Domain       aws.StringValue `json:"domain"`
}

func (v *DeprecateActivityTypeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeprecateDomainInput is undocumented.
type DeprecateDomainInput struct {
	Name aws.StringValue `json:"name"`
}

func (v *DeprecateDomainInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeprecateWorkflowTypeInput is undocumented.
type DeprecateWorkflowTypeInput struct {
	Domain       aws.StringValue `json:"domain"`
	WorkflowType *WorkflowType   `json:"workflowType"`
}

func (v *DeprecateWorkflowTypeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeActivityTypeInput is undocumented.
type DescribeActivityTypeInput struct {
	ActivityType *ActivityType   `json:"activityType"`
	Domain       aws.StringValue `json:"domain"`
}

func (v *DescribeActivityTypeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDomainInput is undocumented.
type DescribeDomainInput struct {
	Name aws.StringValue `json:"name"`
}

func (v *DescribeDomainInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeWorkflowExecutionInput is undocumented.
type DescribeWorkflowExecutionInput struct {
	Domain    aws.StringValue    `json:"domain"`
	Execution *WorkflowExecution `json:"execution"`
}

func (v *DescribeWorkflowExecutionInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "Execution"); err != nil {
		errors["Execution"] = append(errors["Execution"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeWorkflowTypeInput is undocumented.
type DescribeWorkflowTypeInput struct {
	Domain       aws.StringValue `json:"domain"`
	WorkflowType *WorkflowType   `json:"workflowType"`
}

func (v *DescribeWorkflowTypeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DomainConfiguration is undocumented.
type DomainConfiguration struct {
	WorkflowExecutionRetentionPeriodInDays aws.StringValue `json:"workflowExecutionRetentionPeriodInDays"`
}

func (v *DomainConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "WorkflowExecutionRetentionPeriodInDays"); err != nil {
		errors["WorkflowExecutionRetentionPeriodInDays"] = append(errors["WorkflowExecutionRetentionPeriodInDays"], err)
	}

	if err := model.ValidateMin(v, "WorkflowExecutionRetentionPeriodInDays", 1); err != nil {
		errors["WorkflowExecutionRetentionPeriodInDays"] = append(errors["WorkflowExecutionRetentionPeriodInDays"], err)
	}

	if err := model.ValidateMax(v, "WorkflowExecutionRetentionPeriodInDays", 8); err != nil {
		errors["WorkflowExecutionRetentionPeriodInDays"] = append(errors["WorkflowExecutionRetentionPeriodInDays"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DomainDetail is undocumented.
type DomainDetail struct {
	Configuration *DomainConfiguration `json:"configuration"`
	DomainInfo    *DomainInfo          `json:"domainInfo"`
}

func (v *DomainDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Configuration"); err != nil {
		errors["Configuration"] = append(errors["Configuration"], err)
	}

	if err := model.ValidateRequired(v, "DomainInfo"); err != nil {
		errors["DomainInfo"] = append(errors["DomainInfo"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DomainInfo is undocumented.
type DomainInfo struct {
	Description aws.StringValue `json:"description,omitempty"`
	Name        aws.StringValue `json:"name"`
	Status      aws.StringValue `json:"status"`
}

func (v *DomainInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Description", 1024); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	statusEnum := []string{
		RegistrationStatusDeprecated,
		RegistrationStatusRegistered,
	}
	if err := model.ValidateEnum(v, "Status", statusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DomainInfos is undocumented.
type DomainInfos struct {
	DomainInfos   []DomainInfo    `json:"domainInfos"`
	NextPageToken aws.StringValue `json:"nextPageToken,omitempty"`
}

func (v *DomainInfos) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainInfos"); err != nil {
		errors["DomainInfos"] = append(errors["DomainInfos"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	EventTypeActivityTaskCancelRequested                     = "ActivityTaskCancelRequested"
	EventTypeActivityTaskCanceled                            = "ActivityTaskCanceled"
	EventTypeActivityTaskCompleted                           = "ActivityTaskCompleted"
	EventTypeActivityTaskFailed                              = "ActivityTaskFailed"
	EventTypeActivityTaskScheduled                           = "ActivityTaskScheduled"
	EventTypeActivityTaskStarted                             = "ActivityTaskStarted"
	EventTypeActivityTaskTimedOut                            = "ActivityTaskTimedOut"
	EventTypeCancelTimerFailed                               = "CancelTimerFailed"
	EventTypeCancelWorkflowExecutionFailed                   = "CancelWorkflowExecutionFailed"
	EventTypeChildWorkflowExecutionCanceled                  = "ChildWorkflowExecutionCanceled"
	EventTypeChildWorkflowExecutionCompleted                 = "ChildWorkflowExecutionCompleted"
	EventTypeChildWorkflowExecutionFailed                    = "ChildWorkflowExecutionFailed"
	EventTypeChildWorkflowExecutionStarted                   = "ChildWorkflowExecutionStarted"
	EventTypeChildWorkflowExecutionTerminated                = "ChildWorkflowExecutionTerminated"
	EventTypeChildWorkflowExecutionTimedOut                  = "ChildWorkflowExecutionTimedOut"
	EventTypeCompleteWorkflowExecutionFailed                 = "CompleteWorkflowExecutionFailed"
	EventTypeContinueAsNewWorkflowExecutionFailed            = "ContinueAsNewWorkflowExecutionFailed"
	EventTypeDecisionTaskCompleted                           = "DecisionTaskCompleted"
	EventTypeDecisionTaskScheduled                           = "DecisionTaskScheduled"
	EventTypeDecisionTaskStarted                             = "DecisionTaskStarted"
	EventTypeDecisionTaskTimedOut                            = "DecisionTaskTimedOut"
	EventTypeExternalWorkflowExecutionCancelRequested        = "ExternalWorkflowExecutionCancelRequested"
	EventTypeExternalWorkflowExecutionSignaled               = "ExternalWorkflowExecutionSignaled"
	EventTypeFailWorkflowExecutionFailed                     = "FailWorkflowExecutionFailed"
	EventTypeMarkerRecorded                                  = "MarkerRecorded"
	EventTypeRecordMarkerFailed                              = "RecordMarkerFailed"
	EventTypeRequestCancelActivityTaskFailed                 = "RequestCancelActivityTaskFailed"
	EventTypeRequestCancelExternalWorkflowExecutionFailed    = "RequestCancelExternalWorkflowExecutionFailed"
	EventTypeRequestCancelExternalWorkflowExecutionInitiated = "RequestCancelExternalWorkflowExecutionInitiated"
	EventTypeScheduleActivityTaskFailed                      = "ScheduleActivityTaskFailed"
	EventTypeSignalExternalWorkflowExecutionFailed           = "SignalExternalWorkflowExecutionFailed"
	EventTypeSignalExternalWorkflowExecutionInitiated        = "SignalExternalWorkflowExecutionInitiated"
	EventTypeStartChildWorkflowExecutionFailed               = "StartChildWorkflowExecutionFailed"
	EventTypeStartChildWorkflowExecutionInitiated            = "StartChildWorkflowExecutionInitiated"
	EventTypeStartTimerFailed                                = "StartTimerFailed"
	EventTypeTimerCanceled                                   = "TimerCanceled"
	EventTypeTimerFired                                      = "TimerFired"
	EventTypeTimerStarted                                    = "TimerStarted"
	EventTypeWorkflowExecutionCancelRequested                = "WorkflowExecutionCancelRequested"
	EventTypeWorkflowExecutionCanceled                       = "WorkflowExecutionCanceled"
	EventTypeWorkflowExecutionCompleted                      = "WorkflowExecutionCompleted"
	EventTypeWorkflowExecutionContinuedAsNew                 = "WorkflowExecutionContinuedAsNew"
	EventTypeWorkflowExecutionFailed                         = "WorkflowExecutionFailed"
	EventTypeWorkflowExecutionSignaled                       = "WorkflowExecutionSignaled"
	EventTypeWorkflowExecutionStarted                        = "WorkflowExecutionStarted"
	EventTypeWorkflowExecutionTerminated                     = "WorkflowExecutionTerminated"
	EventTypeWorkflowExecutionTimedOut                       = "WorkflowExecutionTimedOut"
)

// Possible values for SWF.
const (
	ExecutionStatusClosed = "CLOSED"
	ExecutionStatusOpen   = "OPEN"
)

// ExecutionTimeFilter is undocumented.
type ExecutionTimeFilter struct {
	LatestDate *aws.LongTimestamp `json:"latestDate,omitempty"`
	OldestDate *aws.LongTimestamp `json:"oldestDate"`
}

func (v *ExecutionTimeFilter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "OldestDate"); err != nil {
		errors["OldestDate"] = append(errors["OldestDate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ExternalWorkflowExecutionCancelRequestedEventAttributes is undocumented.
type ExternalWorkflowExecutionCancelRequestedEventAttributes struct {
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
}

func (v *ExternalWorkflowExecutionCancelRequestedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ExternalWorkflowExecutionSignaledEventAttributes is undocumented.
type ExternalWorkflowExecutionSignaledEventAttributes struct {
	InitiatedEventID  aws.LongValue      `json:"initiatedEventId"`
	WorkflowExecution *WorkflowExecution `json:"workflowExecution"`
}

func (v *ExternalWorkflowExecutionSignaledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecution"); err != nil {
		errors["WorkflowExecution"] = append(errors["WorkflowExecution"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// FailWorkflowExecutionDecisionAttributes is undocumented.
type FailWorkflowExecutionDecisionAttributes struct {
	Details aws.StringValue `json:"details,omitempty"`
	Reason  aws.StringValue `json:"reason,omitempty"`
}

func (v *FailWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	FailWorkflowExecutionFailedCauseOperationNotPermitted = "OPERATION_NOT_PERMITTED"
	FailWorkflowExecutionFailedCauseUnhandledDecision     = "UNHANDLED_DECISION"
)

// FailWorkflowExecutionFailedEventAttributes is undocumented.
type FailWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *FailWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		FailWorkflowExecutionFailedCauseOperationNotPermitted,
		FailWorkflowExecutionFailedCauseUnhandledDecision,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// GetWorkflowExecutionHistoryInput is undocumented.
type GetWorkflowExecutionHistoryInput struct {
	Domain          aws.StringValue    `json:"domain"`
	Execution       *WorkflowExecution `json:"execution"`
	MaximumPageSize aws.IntegerValue   `json:"maximumPageSize,omitempty"`
	NextPageToken   aws.StringValue    `json:"nextPageToken,omitempty"`
	ReverseOrder    aws.BooleanValue   `json:"reverseOrder,omitempty"`
}

func (v *GetWorkflowExecutionHistoryInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "Execution"); err != nil {
		errors["Execution"] = append(errors["Execution"], err)
	}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// History is undocumented.
type History struct {
	Events        []HistoryEvent  `json:"events"`
	NextPageToken aws.StringValue `json:"nextPageToken,omitempty"`
}

func (v *History) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Events"); err != nil {
		errors["Events"] = append(errors["Events"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// HistoryEvent is undocumented.
type HistoryEvent struct {
	ActivityTaskCancelRequestedEventAttributes                     *ActivityTaskCancelRequestedEventAttributes                     `json:"activityTaskCancelRequestedEventAttributes,omitempty"`
	ActivityTaskCanceledEventAttributes                            *ActivityTaskCanceledEventAttributes                            `json:"activityTaskCanceledEventAttributes,omitempty"`
	ActivityTaskCompletedEventAttributes                           *ActivityTaskCompletedEventAttributes                           `json:"activityTaskCompletedEventAttributes,omitempty"`
	ActivityTaskFailedEventAttributes                              *ActivityTaskFailedEventAttributes                              `json:"activityTaskFailedEventAttributes,omitempty"`
	ActivityTaskScheduledEventAttributes                           *ActivityTaskScheduledEventAttributes                           `json:"activityTaskScheduledEventAttributes,omitempty"`
	ActivityTaskStartedEventAttributes                             *ActivityTaskStartedEventAttributes                             `json:"activityTaskStartedEventAttributes,omitempty"`
	ActivityTaskTimedOutEventAttributes                            *ActivityTaskTimedOutEventAttributes                            `json:"activityTaskTimedOutEventAttributes,omitempty"`
	CancelTimerFailedEventAttributes                               *CancelTimerFailedEventAttributes                               `json:"cancelTimerFailedEventAttributes,omitempty"`
	CancelWorkflowExecutionFailedEventAttributes                   *CancelWorkflowExecutionFailedEventAttributes                   `json:"cancelWorkflowExecutionFailedEventAttributes,omitempty"`
	ChildWorkflowExecutionCanceledEventAttributes                  *ChildWorkflowExecutionCanceledEventAttributes                  `json:"childWorkflowExecutionCanceledEventAttributes,omitempty"`
	ChildWorkflowExecutionCompletedEventAttributes                 *ChildWorkflowExecutionCompletedEventAttributes                 `json:"childWorkflowExecutionCompletedEventAttributes,omitempty"`
	ChildWorkflowExecutionFailedEventAttributes                    *ChildWorkflowExecutionFailedEventAttributes                    `json:"childWorkflowExecutionFailedEventAttributes,omitempty"`
	ChildWorkflowExecutionStartedEventAttributes                   *ChildWorkflowExecutionStartedEventAttributes                   `json:"childWorkflowExecutionStartedEventAttributes,omitempty"`
	ChildWorkflowExecutionTerminatedEventAttributes                *ChildWorkflowExecutionTerminatedEventAttributes                `json:"childWorkflowExecutionTerminatedEventAttributes,omitempty"`
	ChildWorkflowExecutionTimedOutEventAttributes                  *ChildWorkflowExecutionTimedOutEventAttributes                  `json:"childWorkflowExecutionTimedOutEventAttributes,omitempty"`
	CompleteWorkflowExecutionFailedEventAttributes                 *CompleteWorkflowExecutionFailedEventAttributes                 `json:"completeWorkflowExecutionFailedEventAttributes,omitempty"`
	ContinueAsNewWorkflowExecutionFailedEventAttributes            *ContinueAsNewWorkflowExecutionFailedEventAttributes            `json:"continueAsNewWorkflowExecutionFailedEventAttributes,omitempty"`
	DecisionTaskCompletedEventAttributes                           *DecisionTaskCompletedEventAttributes                           `json:"decisionTaskCompletedEventAttributes,omitempty"`
	DecisionTaskScheduledEventAttributes                           *DecisionTaskScheduledEventAttributes                           `json:"decisionTaskScheduledEventAttributes,omitempty"`
	DecisionTaskStartedEventAttributes                             *DecisionTaskStartedEventAttributes                             `json:"decisionTaskStartedEventAttributes,omitempty"`
	DecisionTaskTimedOutEventAttributes                            *DecisionTaskTimedOutEventAttributes                            `json:"decisionTaskTimedOutEventAttributes,omitempty"`
	EventID                                                        aws.LongValue                                                   `json:"eventId"`
	EventTimestamp                                                 *aws.LongTimestamp                                              `json:"eventTimestamp"`
	EventType                                                      aws.StringValue                                                 `json:"eventType"`
	ExternalWorkflowExecutionCancelRequestedEventAttributes        *ExternalWorkflowExecutionCancelRequestedEventAttributes        `json:"externalWorkflowExecutionCancelRequestedEventAttributes,omitempty"`
	ExternalWorkflowExecutionSignaledEventAttributes               *ExternalWorkflowExecutionSignaledEventAttributes               `json:"externalWorkflowExecutionSignaledEventAttributes,omitempty"`
	FailWorkflowExecutionFailedEventAttributes                     *FailWorkflowExecutionFailedEventAttributes                     `json:"failWorkflowExecutionFailedEventAttributes,omitempty"`
	MarkerRecordedEventAttributes                                  *MarkerRecordedEventAttributes                                  `json:"markerRecordedEventAttributes,omitempty"`
	RecordMarkerFailedEventAttributes                              *RecordMarkerFailedEventAttributes                              `json:"recordMarkerFailedEventAttributes,omitempty"`
	RequestCancelActivityTaskFailedEventAttributes                 *RequestCancelActivityTaskFailedEventAttributes                 `json:"requestCancelActivityTaskFailedEventAttributes,omitempty"`
	RequestCancelExternalWorkflowExecutionFailedEventAttributes    *RequestCancelExternalWorkflowExecutionFailedEventAttributes    `json:"requestCancelExternalWorkflowExecutionFailedEventAttributes,omitempty"`
	RequestCancelExternalWorkflowExecutionInitiatedEventAttributes *RequestCancelExternalWorkflowExecutionInitiatedEventAttributes `json:"requestCancelExternalWorkflowExecutionInitiatedEventAttributes,omitempty"`
	ScheduleActivityTaskFailedEventAttributes                      *ScheduleActivityTaskFailedEventAttributes                      `json:"scheduleActivityTaskFailedEventAttributes,omitempty"`
	SignalExternalWorkflowExecutionFailedEventAttributes           *SignalExternalWorkflowExecutionFailedEventAttributes           `json:"signalExternalWorkflowExecutionFailedEventAttributes,omitempty"`
	SignalExternalWorkflowExecutionInitiatedEventAttributes        *SignalExternalWorkflowExecutionInitiatedEventAttributes        `json:"signalExternalWorkflowExecutionInitiatedEventAttributes,omitempty"`
	StartChildWorkflowExecutionFailedEventAttributes               *StartChildWorkflowExecutionFailedEventAttributes               `json:"startChildWorkflowExecutionFailedEventAttributes,omitempty"`
	StartChildWorkflowExecutionInitiatedEventAttributes            *StartChildWorkflowExecutionInitiatedEventAttributes            `json:"startChildWorkflowExecutionInitiatedEventAttributes,omitempty"`
	StartTimerFailedEventAttributes                                *StartTimerFailedEventAttributes                                `json:"startTimerFailedEventAttributes,omitempty"`
	TimerCanceledEventAttributes                                   *TimerCanceledEventAttributes                                   `json:"timerCanceledEventAttributes,omitempty"`
	TimerFiredEventAttributes                                      *TimerFiredEventAttributes                                      `json:"timerFiredEventAttributes,omitempty"`
	TimerStartedEventAttributes                                    *TimerStartedEventAttributes                                    `json:"timerStartedEventAttributes,omitempty"`
	WorkflowExecutionCancelRequestedEventAttributes                *WorkflowExecutionCancelRequestedEventAttributes                `json:"workflowExecutionCancelRequestedEventAttributes,omitempty"`
	WorkflowExecutionCanceledEventAttributes                       *WorkflowExecutionCanceledEventAttributes                       `json:"workflowExecutionCanceledEventAttributes,omitempty"`
	WorkflowExecutionCompletedEventAttributes                      *WorkflowExecutionCompletedEventAttributes                      `json:"workflowExecutionCompletedEventAttributes,omitempty"`
	WorkflowExecutionContinuedAsNewEventAttributes                 *WorkflowExecutionContinuedAsNewEventAttributes                 `json:"workflowExecutionContinuedAsNewEventAttributes,omitempty"`
	WorkflowExecutionFailedEventAttributes                         *WorkflowExecutionFailedEventAttributes                         `json:"workflowExecutionFailedEventAttributes,omitempty"`
	WorkflowExecutionSignaledEventAttributes                       *WorkflowExecutionSignaledEventAttributes                       `json:"workflowExecutionSignaledEventAttributes,omitempty"`
	WorkflowExecutionStartedEventAttributes                        *WorkflowExecutionStartedEventAttributes                        `json:"workflowExecutionStartedEventAttributes,omitempty"`
	WorkflowExecutionTerminatedEventAttributes                     *WorkflowExecutionTerminatedEventAttributes                     `json:"workflowExecutionTerminatedEventAttributes,omitempty"`
	WorkflowExecutionTimedOutEventAttributes                       *WorkflowExecutionTimedOutEventAttributes                       `json:"workflowExecutionTimedOutEventAttributes,omitempty"`
}

func (v *HistoryEvent) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "EventID"); err != nil {
		errors["EventID"] = append(errors["EventID"], err)
	}

	if err := model.ValidateRequired(v, "EventTimestamp"); err != nil {
		errors["EventTimestamp"] = append(errors["EventTimestamp"], err)
	}

	if err := model.ValidateRequired(v, "EventType"); err != nil {
		errors["EventType"] = append(errors["EventType"], err)
	}

	eventTypeEnum := []string{
		EventTypeActivityTaskCancelRequested,
		EventTypeActivityTaskCanceled,
		EventTypeActivityTaskCompleted,
		EventTypeActivityTaskFailed,
		EventTypeActivityTaskScheduled,
		EventTypeActivityTaskStarted,
		EventTypeActivityTaskTimedOut,
		EventTypeCancelTimerFailed,
		EventTypeCancelWorkflowExecutionFailed,
		EventTypeChildWorkflowExecutionCanceled,
		EventTypeChildWorkflowExecutionCompleted,
		EventTypeChildWorkflowExecutionFailed,
		EventTypeChildWorkflowExecutionStarted,
		EventTypeChildWorkflowExecutionTerminated,
		EventTypeChildWorkflowExecutionTimedOut,
		EventTypeCompleteWorkflowExecutionFailed,
		EventTypeContinueAsNewWorkflowExecutionFailed,
		EventTypeDecisionTaskCompleted,
		EventTypeDecisionTaskScheduled,
		EventTypeDecisionTaskStarted,
		EventTypeDecisionTaskTimedOut,
		EventTypeExternalWorkflowExecutionCancelRequested,
		EventTypeExternalWorkflowExecutionSignaled,
		EventTypeFailWorkflowExecutionFailed,
		EventTypeMarkerRecorded,
		EventTypeRecordMarkerFailed,
		EventTypeRequestCancelActivityTaskFailed,
		EventTypeRequestCancelExternalWorkflowExecutionFailed,
		EventTypeRequestCancelExternalWorkflowExecutionInitiated,
		EventTypeScheduleActivityTaskFailed,
		EventTypeSignalExternalWorkflowExecutionFailed,
		EventTypeSignalExternalWorkflowExecutionInitiated,
		EventTypeStartChildWorkflowExecutionFailed,
		EventTypeStartChildWorkflowExecutionInitiated,
		EventTypeStartTimerFailed,
		EventTypeTimerCanceled,
		EventTypeTimerFired,
		EventTypeTimerStarted,
		EventTypeWorkflowExecutionCancelRequested,
		EventTypeWorkflowExecutionCanceled,
		EventTypeWorkflowExecutionCompleted,
		EventTypeWorkflowExecutionContinuedAsNew,
		EventTypeWorkflowExecutionFailed,
		EventTypeWorkflowExecutionSignaled,
		EventTypeWorkflowExecutionStarted,
		EventTypeWorkflowExecutionTerminated,
		EventTypeWorkflowExecutionTimedOut,
	}
	if err := model.ValidateEnum(v, "EventType", eventTypeEnum); err != nil {
		errors["EventType"] = append(errors["EventType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListActivityTypesInput is undocumented.
type ListActivityTypesInput struct {
	Domain             aws.StringValue  `json:"domain"`
	MaximumPageSize    aws.IntegerValue `json:"maximumPageSize,omitempty"`
	Name               aws.StringValue  `json:"name,omitempty"`
	NextPageToken      aws.StringValue  `json:"nextPageToken,omitempty"`
	RegistrationStatus aws.StringValue  `json:"registrationStatus"`
	ReverseOrder       aws.BooleanValue `json:"reverseOrder,omitempty"`
}

func (v *ListActivityTypesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "RegistrationStatus"); err != nil {
		errors["RegistrationStatus"] = append(errors["RegistrationStatus"], err)
	}

	registrationStatusEnum := []string{
		RegistrationStatusDeprecated,
		RegistrationStatusRegistered,
	}
	if err := model.ValidateEnum(v, "RegistrationStatus", registrationStatusEnum); err != nil {
		errors["RegistrationStatus"] = append(errors["RegistrationStatus"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListClosedWorkflowExecutionsInput is undocumented.
type ListClosedWorkflowExecutionsInput struct {
	CloseStatusFilter *CloseStatusFilter       `json:"closeStatusFilter,omitempty"`
	CloseTimeFilter   *ExecutionTimeFilter     `json:"closeTimeFilter,omitempty"`
	Domain            aws.StringValue          `json:"domain"`
	ExecutionFilter   *WorkflowExecutionFilter `json:"executionFilter,omitempty"`
	MaximumPageSize   aws.IntegerValue         `json:"maximumPageSize,omitempty"`
	NextPageToken     aws.StringValue          `json:"nextPageToken,omitempty"`
	ReverseOrder      aws.BooleanValue         `json:"reverseOrder,omitempty"`
	StartTimeFilter   *ExecutionTimeFilter     `json:"startTimeFilter,omitempty"`
	TagFilter         *TagFilter               `json:"tagFilter,omitempty"`
	TypeFilter        *WorkflowTypeFilter      `json:"typeFilter,omitempty"`
}

func (v *ListClosedWorkflowExecutionsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListDomainsInput is undocumented.
type ListDomainsInput struct {
	MaximumPageSize    aws.IntegerValue `json:"maximumPageSize,omitempty"`
	NextPageToken      aws.StringValue  `json:"nextPageToken,omitempty"`
	RegistrationStatus aws.StringValue  `json:"registrationStatus"`
	ReverseOrder       aws.BooleanValue `json:"reverseOrder,omitempty"`
}

func (v *ListDomainsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "RegistrationStatus"); err != nil {
		errors["RegistrationStatus"] = append(errors["RegistrationStatus"], err)
	}

	registrationStatusEnum := []string{
		RegistrationStatusDeprecated,
		RegistrationStatusRegistered,
	}
	if err := model.ValidateEnum(v, "RegistrationStatus", registrationStatusEnum); err != nil {
		errors["RegistrationStatus"] = append(errors["RegistrationStatus"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListOpenWorkflowExecutionsInput is undocumented.
type ListOpenWorkflowExecutionsInput struct {
	Domain          aws.StringValue          `json:"domain"`
	ExecutionFilter *WorkflowExecutionFilter `json:"executionFilter,omitempty"`
	MaximumPageSize aws.IntegerValue         `json:"maximumPageSize,omitempty"`
	NextPageToken   aws.StringValue          `json:"nextPageToken,omitempty"`
	ReverseOrder    aws.BooleanValue         `json:"reverseOrder,omitempty"`
	StartTimeFilter *ExecutionTimeFilter     `json:"startTimeFilter"`
	TagFilter       *TagFilter               `json:"tagFilter,omitempty"`
	TypeFilter      *WorkflowTypeFilter      `json:"typeFilter,omitempty"`
}

func (v *ListOpenWorkflowExecutionsInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "StartTimeFilter"); err != nil {
		errors["StartTimeFilter"] = append(errors["StartTimeFilter"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListWorkflowTypesInput is undocumented.
type ListWorkflowTypesInput struct {
	Domain             aws.StringValue  `json:"domain"`
	MaximumPageSize    aws.IntegerValue `json:"maximumPageSize,omitempty"`
	Name               aws.StringValue  `json:"name,omitempty"`
	NextPageToken      aws.StringValue  `json:"nextPageToken,omitempty"`
	RegistrationStatus aws.StringValue  `json:"registrationStatus"`
	ReverseOrder       aws.BooleanValue `json:"reverseOrder,omitempty"`
}

func (v *ListWorkflowTypesInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "RegistrationStatus"); err != nil {
		errors["RegistrationStatus"] = append(errors["RegistrationStatus"], err)
	}

	registrationStatusEnum := []string{
		RegistrationStatusDeprecated,
		RegistrationStatusRegistered,
	}
	if err := model.ValidateEnum(v, "RegistrationStatus", registrationStatusEnum); err != nil {
		errors["RegistrationStatus"] = append(errors["RegistrationStatus"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// MarkerRecordedEventAttributes is undocumented.
type MarkerRecordedEventAttributes struct {
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	Details                      aws.StringValue `json:"details,omitempty"`
	MarkerName                   aws.StringValue `json:"markerName"`
}

func (v *MarkerRecordedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "MarkerName"); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if err := model.ValidateMin(v, "MarkerName", 1); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if err := model.ValidateMax(v, "MarkerName", 256); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PendingTaskCount is undocumented.
type PendingTaskCount struct {
	Count     aws.IntegerValue `json:"count"`
	Truncated aws.BooleanValue `json:"truncated,omitempty"`
}

func (v *PendingTaskCount) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Count"); err != nil {
		errors["Count"] = append(errors["Count"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PollForActivityTaskInput is undocumented.
type PollForActivityTaskInput struct {
	Domain   aws.StringValue `json:"domain"`
	Identity aws.StringValue `json:"identity,omitempty"`
	TaskList *TaskList       `json:"taskList"`
}

func (v *PollForActivityTaskInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Identity", 256); err != nil {
		errors["Identity"] = append(errors["Identity"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// PollForDecisionTaskInput is undocumented.
type PollForDecisionTaskInput struct {
	Domain          aws.StringValue  `json:"domain"`
	Identity        aws.StringValue  `json:"identity,omitempty"`
	MaximumPageSize aws.IntegerValue `json:"maximumPageSize,omitempty"`
	NextPageToken   aws.StringValue  `json:"nextPageToken,omitempty"`
	ReverseOrder    aws.BooleanValue `json:"reverseOrder,omitempty"`
	TaskList        *TaskList        `json:"taskList"`
}

func (v *PollForDecisionTaskInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Identity", 256); err != nil {
		errors["Identity"] = append(errors["Identity"], err)
	}

	if err := model.ValidateMax(v, "MaximumPageSize", 1000); err != nil {
		errors["MaximumPageSize"] = append(errors["MaximumPageSize"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RecordActivityTaskHeartbeatInput is undocumented.
type RecordActivityTaskHeartbeatInput struct {
	Details   aws.StringValue `json:"details,omitempty"`
	TaskToken aws.StringValue `json:"taskToken"`
}

func (v *RecordActivityTaskHeartbeatInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 2048); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RecordMarkerDecisionAttributes is undocumented.
type RecordMarkerDecisionAttributes struct {
	Details    aws.StringValue `json:"details,omitempty"`
	MarkerName aws.StringValue `json:"markerName"`
}

func (v *RecordMarkerDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "MarkerName"); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if err := model.ValidateMin(v, "MarkerName", 1); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if err := model.ValidateMax(v, "MarkerName", 256); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	RecordMarkerFailedCauseOperationNotPermitted = "OPERATION_NOT_PERMITTED"
)

// RecordMarkerFailedEventAttributes is undocumented.
type RecordMarkerFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	MarkerName                   aws.StringValue `json:"markerName"`
}

func (v *RecordMarkerFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		RecordMarkerFailedCauseOperationNotPermitted,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "MarkerName"); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if err := model.ValidateMin(v, "MarkerName", 1); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if err := model.ValidateMax(v, "MarkerName", 256); err != nil {
		errors["MarkerName"] = append(errors["MarkerName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RegisterActivityTypeInput is undocumented.
type RegisterActivityTypeInput struct {
	DefaultTaskHeartbeatTimeout       aws.StringValue `json:"defaultTaskHeartbeatTimeout,omitempty"`
	DefaultTaskList                   *TaskList       `json:"defaultTaskList,omitempty"`
	DefaultTaskScheduleToCloseTimeout aws.StringValue `json:"defaultTaskScheduleToCloseTimeout,omitempty"`
	DefaultTaskScheduleToStartTimeout aws.StringValue `json:"defaultTaskScheduleToStartTimeout,omitempty"`
	DefaultTaskStartToCloseTimeout    aws.StringValue `json:"defaultTaskStartToCloseTimeout,omitempty"`
	Description                       aws.StringValue `json:"description,omitempty"`
	Domain                            aws.StringValue `json:"domain"`
	Name                              aws.StringValue `json:"name"`
	Version                           aws.StringValue `json:"version"`
}

func (v *RegisterActivityTypeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultTaskHeartbeatTimeout", 8); err != nil {
		errors["DefaultTaskHeartbeatTimeout"] = append(errors["DefaultTaskHeartbeatTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskScheduleToCloseTimeout", 8); err != nil {
		errors["DefaultTaskScheduleToCloseTimeout"] = append(errors["DefaultTaskScheduleToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskScheduleToStartTimeout", 8); err != nil {
		errors["DefaultTaskScheduleToStartTimeout"] = append(errors["DefaultTaskScheduleToStartTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskStartToCloseTimeout", 8); err != nil {
		errors["DefaultTaskStartToCloseTimeout"] = append(errors["DefaultTaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Description", 1024); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "Version"); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMin(v, "Version", 1); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMax(v, "Version", 64); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RegisterDomainInput is undocumented.
type RegisterDomainInput struct {
	Description                            aws.StringValue `json:"description,omitempty"`
	Name                                   aws.StringValue `json:"name"`
	WorkflowExecutionRetentionPeriodInDays aws.StringValue `json:"workflowExecutionRetentionPeriodInDays"`
}

func (v *RegisterDomainInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Description", 1024); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowExecutionRetentionPeriodInDays"); err != nil {
		errors["WorkflowExecutionRetentionPeriodInDays"] = append(errors["WorkflowExecutionRetentionPeriodInDays"], err)
	}

	if err := model.ValidateMin(v, "WorkflowExecutionRetentionPeriodInDays", 1); err != nil {
		errors["WorkflowExecutionRetentionPeriodInDays"] = append(errors["WorkflowExecutionRetentionPeriodInDays"], err)
	}

	if err := model.ValidateMax(v, "WorkflowExecutionRetentionPeriodInDays", 8); err != nil {
		errors["WorkflowExecutionRetentionPeriodInDays"] = append(errors["WorkflowExecutionRetentionPeriodInDays"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RegisterWorkflowTypeInput is undocumented.
type RegisterWorkflowTypeInput struct {
	DefaultChildPolicy                  aws.StringValue `json:"defaultChildPolicy,omitempty"`
	DefaultExecutionStartToCloseTimeout aws.StringValue `json:"defaultExecutionStartToCloseTimeout,omitempty"`
	DefaultTaskList                     *TaskList       `json:"defaultTaskList,omitempty"`
	DefaultTaskStartToCloseTimeout      aws.StringValue `json:"defaultTaskStartToCloseTimeout,omitempty"`
	Description                         aws.StringValue `json:"description,omitempty"`
	Domain                              aws.StringValue `json:"domain"`
	Name                                aws.StringValue `json:"name"`
	Version                             aws.StringValue `json:"version"`
}

func (v *RegisterWorkflowTypeInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	defaultChildPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "DefaultChildPolicy", defaultChildPolicyEnum); err != nil {
		errors["DefaultChildPolicy"] = append(errors["DefaultChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "DefaultExecutionStartToCloseTimeout", 8); err != nil {
		errors["DefaultExecutionStartToCloseTimeout"] = append(errors["DefaultExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskStartToCloseTimeout", 8); err != nil {
		errors["DefaultTaskStartToCloseTimeout"] = append(errors["DefaultTaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Description", 1024); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "Version"); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMin(v, "Version", 1); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMax(v, "Version", 64); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	RegistrationStatusDeprecated = "DEPRECATED"
	RegistrationStatusRegistered = "REGISTERED"
)

// RequestCancelActivityTaskDecisionAttributes is undocumented.
type RequestCancelActivityTaskDecisionAttributes struct {
	ActivityID aws.StringValue `json:"activityId"`
}

func (v *RequestCancelActivityTaskDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	RequestCancelActivityTaskFailedCauseActivityIDUnknown     = "ACTIVITY_ID_UNKNOWN"
	RequestCancelActivityTaskFailedCauseOperationNotPermitted = "OPERATION_NOT_PERMITTED"
)

// RequestCancelActivityTaskFailedEventAttributes is undocumented.
type RequestCancelActivityTaskFailedEventAttributes struct {
	ActivityID                   aws.StringValue `json:"activityId"`
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *RequestCancelActivityTaskFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		RequestCancelActivityTaskFailedCauseActivityIDUnknown,
		RequestCancelActivityTaskFailedCauseOperationNotPermitted,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RequestCancelExternalWorkflowExecutionDecisionAttributes is undocumented.
type RequestCancelExternalWorkflowExecutionDecisionAttributes struct {
	Control    aws.StringValue `json:"control,omitempty"`
	RunID      aws.StringValue `json:"runId,omitempty"`
	WorkflowID aws.StringValue `json:"workflowId"`
}

func (v *RequestCancelExternalWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	RequestCancelExternalWorkflowExecutionFailedCauseOperationNotPermitted                              = "OPERATION_NOT_PERMITTED"
	RequestCancelExternalWorkflowExecutionFailedCauseRequestCancelExternalWorkflowExecutionRateExceeded = "REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED"
	RequestCancelExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution                   = "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"
)

// RequestCancelExternalWorkflowExecutionFailedEventAttributes is undocumented.
type RequestCancelExternalWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	InitiatedEventID             aws.LongValue   `json:"initiatedEventId"`
	RunID                        aws.StringValue `json:"runId,omitempty"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
}

func (v *RequestCancelExternalWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		RequestCancelExternalWorkflowExecutionFailedCauseOperationNotPermitted,
		RequestCancelExternalWorkflowExecutionFailedCauseRequestCancelExternalWorkflowExecutionRateExceeded,
		RequestCancelExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RequestCancelExternalWorkflowExecutionInitiatedEventAttributes is undocumented.
type RequestCancelExternalWorkflowExecutionInitiatedEventAttributes struct {
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	RunID                        aws.StringValue `json:"runId,omitempty"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
}

func (v *RequestCancelExternalWorkflowExecutionInitiatedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RequestCancelWorkflowExecutionInput is undocumented.
type RequestCancelWorkflowExecutionInput struct {
	Domain     aws.StringValue `json:"domain"`
	RunID      aws.StringValue `json:"runId,omitempty"`
	WorkflowID aws.StringValue `json:"workflowId"`
}

func (v *RequestCancelWorkflowExecutionInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RespondActivityTaskCanceledInput is undocumented.
type RespondActivityTaskCanceledInput struct {
	Details   aws.StringValue `json:"details,omitempty"`
	TaskToken aws.StringValue `json:"taskToken"`
}

func (v *RespondActivityTaskCanceledInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RespondActivityTaskCompletedInput is undocumented.
type RespondActivityTaskCompletedInput struct {
	Result    aws.StringValue `json:"result,omitempty"`
	TaskToken aws.StringValue `json:"taskToken"`
}

func (v *RespondActivityTaskCompletedInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Result", 32768); err != nil {
		errors["Result"] = append(errors["Result"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RespondActivityTaskFailedInput is undocumented.
type RespondActivityTaskFailedInput struct {
	Details   aws.StringValue `json:"details,omitempty"`
	Reason    aws.StringValue `json:"reason,omitempty"`
	TaskToken aws.StringValue `json:"taskToken"`
}

func (v *RespondActivityTaskFailedInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// RespondDecisionTaskCompletedInput is undocumented.
type RespondDecisionTaskCompletedInput struct {
	Decisions        []Decision      `json:"decisions,omitempty"`
	ExecutionContext aws.StringValue `json:"executionContext,omitempty"`
	TaskToken        aws.StringValue `json:"taskToken"`
}

func (v *RespondDecisionTaskCompletedInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "ExecutionContext", 32768); err != nil {
		errors["ExecutionContext"] = append(errors["ExecutionContext"], err)
	}

	if err := model.ValidateRequired(v, "TaskToken"); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMin(v, "TaskToken", 1); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if err := model.ValidateMax(v, "TaskToken", 1024); err != nil {
		errors["TaskToken"] = append(errors["TaskToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Run is undocumented.
type Run struct {
	RunID aws.StringValue `json:"runId,omitempty"`
}

func (v *Run) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "RunID", 1); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ScheduleActivityTaskDecisionAttributes is undocumented.
type ScheduleActivityTaskDecisionAttributes struct {
	ActivityID             aws.StringValue `json:"activityId"`
	ActivityType           *ActivityType   `json:"activityType"`
	Control                aws.StringValue `json:"control,omitempty"`
	HeartbeatTimeout       aws.StringValue `json:"heartbeatTimeout,omitempty"`
	Input                  aws.StringValue `json:"input,omitempty"`
	ScheduleToCloseTimeout aws.StringValue `json:"scheduleToCloseTimeout,omitempty"`
	ScheduleToStartTimeout aws.StringValue `json:"scheduleToStartTimeout,omitempty"`
	StartToCloseTimeout    aws.StringValue `json:"startToCloseTimeout,omitempty"`
	TaskList               *TaskList       `json:"taskList,omitempty"`
}

func (v *ScheduleActivityTaskDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateMax(v, "HeartbeatTimeout", 8); err != nil {
		errors["HeartbeatTimeout"] = append(errors["HeartbeatTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "ScheduleToCloseTimeout", 8); err != nil {
		errors["ScheduleToCloseTimeout"] = append(errors["ScheduleToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "ScheduleToStartTimeout", 8); err != nil {
		errors["ScheduleToStartTimeout"] = append(errors["ScheduleToStartTimeout"], err)
	}

	if err := model.ValidateMax(v, "StartToCloseTimeout", 8); err != nil {
		errors["StartToCloseTimeout"] = append(errors["StartToCloseTimeout"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	ScheduleActivityTaskFailedCauseActivityCreationRateExceeded           = "ACTIVITY_CREATION_RATE_EXCEEDED"
	ScheduleActivityTaskFailedCauseActivityIDAlreadyInUse                 = "ACTIVITY_ID_ALREADY_IN_USE"
	ScheduleActivityTaskFailedCauseActivityTypeDeprecated                 = "ACTIVITY_TYPE_DEPRECATED"
	ScheduleActivityTaskFailedCauseActivityTypeDoesNotExist               = "ACTIVITY_TYPE_DOES_NOT_EXIST"
	ScheduleActivityTaskFailedCauseDefaultHeartbeatTimeoutUndefined       = "DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED"
	ScheduleActivityTaskFailedCauseDefaultScheduleToCloseTimeoutUndefined = "DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED"
	ScheduleActivityTaskFailedCauseDefaultScheduleToStartTimeoutUndefined = "DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED"
	ScheduleActivityTaskFailedCauseDefaultStartToCloseTimeoutUndefined    = "DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED"
	ScheduleActivityTaskFailedCauseDefaultTaskListUndefined               = "DEFAULT_TASK_LIST_UNDEFINED"
	ScheduleActivityTaskFailedCauseOpenActivitiesLimitExceeded            = "OPEN_ACTIVITIES_LIMIT_EXCEEDED"
	ScheduleActivityTaskFailedCauseOperationNotPermitted                  = "OPERATION_NOT_PERMITTED"
)

// ScheduleActivityTaskFailedEventAttributes is undocumented.
type ScheduleActivityTaskFailedEventAttributes struct {
	ActivityID                   aws.StringValue `json:"activityId"`
	ActivityType                 *ActivityType   `json:"activityType"`
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
}

func (v *ScheduleActivityTaskFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ActivityID"); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMin(v, "ActivityID", 1); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateMax(v, "ActivityID", 256); err != nil {
		errors["ActivityID"] = append(errors["ActivityID"], err)
	}

	if err := model.ValidateRequired(v, "ActivityType"); err != nil {
		errors["ActivityType"] = append(errors["ActivityType"], err)
	}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		ScheduleActivityTaskFailedCauseActivityCreationRateExceeded,
		ScheduleActivityTaskFailedCauseActivityIDAlreadyInUse,
		ScheduleActivityTaskFailedCauseActivityTypeDeprecated,
		ScheduleActivityTaskFailedCauseActivityTypeDoesNotExist,
		ScheduleActivityTaskFailedCauseDefaultHeartbeatTimeoutUndefined,
		ScheduleActivityTaskFailedCauseDefaultScheduleToCloseTimeoutUndefined,
		ScheduleActivityTaskFailedCauseDefaultScheduleToStartTimeoutUndefined,
		ScheduleActivityTaskFailedCauseDefaultStartToCloseTimeoutUndefined,
		ScheduleActivityTaskFailedCauseDefaultTaskListUndefined,
		ScheduleActivityTaskFailedCauseOpenActivitiesLimitExceeded,
		ScheduleActivityTaskFailedCauseOperationNotPermitted,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SignalExternalWorkflowExecutionDecisionAttributes is undocumented.
type SignalExternalWorkflowExecutionDecisionAttributes struct {
	Control    aws.StringValue `json:"control,omitempty"`
	Input      aws.StringValue `json:"input,omitempty"`
	RunID      aws.StringValue `json:"runId,omitempty"`
	SignalName aws.StringValue `json:"signalName"`
	WorkflowID aws.StringValue `json:"workflowId"`
}

func (v *SignalExternalWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "SignalName"); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMin(v, "SignalName", 1); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMax(v, "SignalName", 256); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	SignalExternalWorkflowExecutionFailedCauseOperationNotPermitted                       = "OPERATION_NOT_PERMITTED"
	SignalExternalWorkflowExecutionFailedCauseSignalExternalWorkflowExecutionRateExceeded = "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED"
	SignalExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution            = "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"
)

// SignalExternalWorkflowExecutionFailedEventAttributes is undocumented.
type SignalExternalWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	InitiatedEventID             aws.LongValue   `json:"initiatedEventId"`
	RunID                        aws.StringValue `json:"runId,omitempty"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
}

func (v *SignalExternalWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		SignalExternalWorkflowExecutionFailedCauseOperationNotPermitted,
		SignalExternalWorkflowExecutionFailedCauseSignalExternalWorkflowExecutionRateExceeded,
		SignalExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SignalExternalWorkflowExecutionInitiatedEventAttributes is undocumented.
type SignalExternalWorkflowExecutionInitiatedEventAttributes struct {
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	Input                        aws.StringValue `json:"input,omitempty"`
	RunID                        aws.StringValue `json:"runId,omitempty"`
	SignalName                   aws.StringValue `json:"signalName"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
}

func (v *SignalExternalWorkflowExecutionInitiatedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "SignalName"); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMin(v, "SignalName", 1); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMax(v, "SignalName", 256); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// SignalWorkflowExecutionInput is undocumented.
type SignalWorkflowExecutionInput struct {
	Domain     aws.StringValue `json:"domain"`
	Input      aws.StringValue `json:"input,omitempty"`
	RunID      aws.StringValue `json:"runId,omitempty"`
	SignalName aws.StringValue `json:"signalName"`
	WorkflowID aws.StringValue `json:"workflowId"`
}

func (v *SignalWorkflowExecutionInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "SignalName"); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMin(v, "SignalName", 1); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMax(v, "SignalName", 256); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartChildWorkflowExecutionDecisionAttributes is undocumented.
type StartChildWorkflowExecutionDecisionAttributes struct {
	ChildPolicy                  aws.StringValue `json:"childPolicy,omitempty"`
	Control                      aws.StringValue `json:"control,omitempty"`
	ExecutionStartToCloseTimeout aws.StringValue `json:"executionStartToCloseTimeout,omitempty"`
	Input                        aws.StringValue `json:"input,omitempty"`
	TagList                      []string        `json:"tagList,omitempty"`
	TaskList                     *TaskList       `json:"taskList,omitempty"`
	TaskStartToCloseTimeout      aws.StringValue `json:"taskStartToCloseTimeout,omitempty"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
	WorkflowType                 *WorkflowType   `json:"workflowType"`
}

func (v *StartChildWorkflowExecutionDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	StartChildWorkflowExecutionFailedCauseChildCreationRateExceeded                    = "CHILD_CREATION_RATE_EXCEEDED"
	StartChildWorkflowExecutionFailedCauseDefaultChildPolicyUndefined                  = "DEFAULT_CHILD_POLICY_UNDEFINED"
	StartChildWorkflowExecutionFailedCauseDefaultExecutionStartToCloseTimeoutUndefined = "DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED"
	StartChildWorkflowExecutionFailedCauseDefaultTaskListUndefined                     = "DEFAULT_TASK_LIST_UNDEFINED"
	StartChildWorkflowExecutionFailedCauseDefaultTaskStartToCloseTimeoutUndefined      = "DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED"
	StartChildWorkflowExecutionFailedCauseOpenChildrenLimitExceeded                    = "OPEN_CHILDREN_LIMIT_EXCEEDED"
	StartChildWorkflowExecutionFailedCauseOpenWorkflowsLimitExceeded                   = "OPEN_WORKFLOWS_LIMIT_EXCEEDED"
	StartChildWorkflowExecutionFailedCauseOperationNotPermitted                        = "OPERATION_NOT_PERMITTED"
	StartChildWorkflowExecutionFailedCauseWorkflowAlreadyRunning                       = "WORKFLOW_ALREADY_RUNNING"
	StartChildWorkflowExecutionFailedCauseWorkflowTypeDeprecated                       = "WORKFLOW_TYPE_DEPRECATED"
	StartChildWorkflowExecutionFailedCauseWorkflowTypeDoesNotExist                     = "WORKFLOW_TYPE_DOES_NOT_EXIST"
)

// StartChildWorkflowExecutionFailedEventAttributes is undocumented.
type StartChildWorkflowExecutionFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	InitiatedEventID             aws.LongValue   `json:"initiatedEventId"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
	WorkflowType                 *WorkflowType   `json:"workflowType"`
}

func (v *StartChildWorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		StartChildWorkflowExecutionFailedCauseChildCreationRateExceeded,
		StartChildWorkflowExecutionFailedCauseDefaultChildPolicyUndefined,
		StartChildWorkflowExecutionFailedCauseDefaultExecutionStartToCloseTimeoutUndefined,
		StartChildWorkflowExecutionFailedCauseDefaultTaskListUndefined,
		StartChildWorkflowExecutionFailedCauseDefaultTaskStartToCloseTimeoutUndefined,
		StartChildWorkflowExecutionFailedCauseOpenChildrenLimitExceeded,
		StartChildWorkflowExecutionFailedCauseOpenWorkflowsLimitExceeded,
		StartChildWorkflowExecutionFailedCauseOperationNotPermitted,
		StartChildWorkflowExecutionFailedCauseWorkflowAlreadyRunning,
		StartChildWorkflowExecutionFailedCauseWorkflowTypeDeprecated,
		StartChildWorkflowExecutionFailedCauseWorkflowTypeDoesNotExist,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "InitiatedEventID"); err != nil {
		errors["InitiatedEventID"] = append(errors["InitiatedEventID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartChildWorkflowExecutionInitiatedEventAttributes is undocumented.
type StartChildWorkflowExecutionInitiatedEventAttributes struct {
	ChildPolicy                  aws.StringValue `json:"childPolicy"`
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	ExecutionStartToCloseTimeout aws.StringValue `json:"executionStartToCloseTimeout,omitempty"`
	Input                        aws.StringValue `json:"input,omitempty"`
	TagList                      []string        `json:"tagList,omitempty"`
	TaskList                     *TaskList       `json:"taskList"`
	TaskStartToCloseTimeout      aws.StringValue `json:"taskStartToCloseTimeout,omitempty"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
	WorkflowType                 *WorkflowType   `json:"workflowType"`
}

func (v *StartChildWorkflowExecutionInitiatedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ChildPolicy"); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartTimerDecisionAttributes is undocumented.
type StartTimerDecisionAttributes struct {
	Control            aws.StringValue `json:"control,omitempty"`
	StartToFireTimeout aws.StringValue `json:"startToFireTimeout"`
	TimerID            aws.StringValue `json:"timerId"`
}

func (v *StartTimerDecisionAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "StartToFireTimeout"); err != nil {
		errors["StartToFireTimeout"] = append(errors["StartToFireTimeout"], err)
	}

	if err := model.ValidateMin(v, "StartToFireTimeout", 1); err != nil {
		errors["StartToFireTimeout"] = append(errors["StartToFireTimeout"], err)
	}

	if err := model.ValidateMax(v, "StartToFireTimeout", 8); err != nil {
		errors["StartToFireTimeout"] = append(errors["StartToFireTimeout"], err)
	}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	StartTimerFailedCauseOpenTimersLimitExceeded   = "OPEN_TIMERS_LIMIT_EXCEEDED"
	StartTimerFailedCauseOperationNotPermitted     = "OPERATION_NOT_PERMITTED"
	StartTimerFailedCauseTimerCreationRateExceeded = "TIMER_CREATION_RATE_EXCEEDED"
	StartTimerFailedCauseTimerIDAlreadyInUse       = "TIMER_ID_ALREADY_IN_USE"
)

// StartTimerFailedEventAttributes is undocumented.
type StartTimerFailedEventAttributes struct {
	Cause                        aws.StringValue `json:"cause"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	TimerID                      aws.StringValue `json:"timerId"`
}

func (v *StartTimerFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Cause"); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	causeEnum := []string{
		StartTimerFailedCauseOpenTimersLimitExceeded,
		StartTimerFailedCauseOperationNotPermitted,
		StartTimerFailedCauseTimerCreationRateExceeded,
		StartTimerFailedCauseTimerIDAlreadyInUse,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// StartWorkflowExecutionInput is undocumented.
type StartWorkflowExecutionInput struct {
	ChildPolicy                  aws.StringValue `json:"childPolicy,omitempty"`
	Domain                       aws.StringValue `json:"domain"`
	ExecutionStartToCloseTimeout aws.StringValue `json:"executionStartToCloseTimeout,omitempty"`
	Input                        aws.StringValue `json:"input,omitempty"`
	TagList                      []string        `json:"tagList,omitempty"`
	TaskList                     *TaskList       `json:"taskList,omitempty"`
	TaskStartToCloseTimeout      aws.StringValue `json:"taskStartToCloseTimeout,omitempty"`
	WorkflowID                   aws.StringValue `json:"workflowId"`
	WorkflowType                 *WorkflowType   `json:"workflowType"`
}

func (v *StartWorkflowExecutionInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TagFilter is undocumented.
type TagFilter struct {
	Tag aws.StringValue `json:"tag"`
}

func (v *TagFilter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Tag"); err != nil {
		errors["Tag"] = append(errors["Tag"], err)
	}

	if err := model.ValidateMin(v, "Tag", 1); err != nil {
		errors["Tag"] = append(errors["Tag"], err)
	}

	if err := model.ValidateMax(v, "Tag", 256); err != nil {
		errors["Tag"] = append(errors["Tag"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TaskList is undocumented.
type TaskList struct {
	Name aws.StringValue `json:"name"`
}

func (v *TaskList) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TerminateWorkflowExecutionInput is undocumented.
type TerminateWorkflowExecutionInput struct {
	ChildPolicy aws.StringValue `json:"childPolicy,omitempty"`
	Details     aws.StringValue `json:"details,omitempty"`
	Domain      aws.StringValue `json:"domain"`
	Reason      aws.StringValue `json:"reason,omitempty"`
	RunID       aws.StringValue `json:"runId,omitempty"`
	WorkflowID  aws.StringValue `json:"workflowId"`
}

func (v *TerminateWorkflowExecutionInput) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateRequired(v, "Domain"); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMin(v, "Domain", 1); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Domain", 256); err != nil {
		errors["Domain"] = append(errors["Domain"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TimerCanceledEventAttributes is undocumented.
type TimerCanceledEventAttributes struct {
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	StartedEventID               aws.LongValue   `json:"startedEventId"`
	TimerID                      aws.StringValue `json:"timerId"`
}

func (v *TimerCanceledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TimerFiredEventAttributes is undocumented.
type TimerFiredEventAttributes struct {
	StartedEventID aws.LongValue   `json:"startedEventId"`
	TimerID        aws.StringValue `json:"timerId"`
}

func (v *TimerFiredEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "StartedEventID"); err != nil {
		errors["StartedEventID"] = append(errors["StartedEventID"], err)
	}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TimerStartedEventAttributes is undocumented.
type TimerStartedEventAttributes struct {
	Control                      aws.StringValue `json:"control,omitempty"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	StartToFireTimeout           aws.StringValue `json:"startToFireTimeout"`
	TimerID                      aws.StringValue `json:"timerId"`
}

func (v *TimerStartedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Control", 32768); err != nil {
		errors["Control"] = append(errors["Control"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateRequired(v, "StartToFireTimeout"); err != nil {
		errors["StartToFireTimeout"] = append(errors["StartToFireTimeout"], err)
	}

	if err := model.ValidateMin(v, "StartToFireTimeout", 1); err != nil {
		errors["StartToFireTimeout"] = append(errors["StartToFireTimeout"], err)
	}

	if err := model.ValidateMax(v, "StartToFireTimeout", 8); err != nil {
		errors["StartToFireTimeout"] = append(errors["StartToFireTimeout"], err)
	}

	if err := model.ValidateRequired(v, "TimerID"); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMin(v, "TimerID", 1); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if err := model.ValidateMax(v, "TimerID", 256); err != nil {
		errors["TimerID"] = append(errors["TimerID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecution is undocumented.
type WorkflowExecution struct {
	RunID      aws.StringValue `json:"runId"`
	WorkflowID aws.StringValue `json:"workflowId"`
}

func (v *WorkflowExecution) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "RunID"); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateMin(v, "RunID", 1); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateMax(v, "RunID", 64); err != nil {
		errors["RunID"] = append(errors["RunID"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	WorkflowExecutionCancelRequestedCauseChildPolicyApplied = "CHILD_POLICY_APPLIED"
)

// WorkflowExecutionCancelRequestedEventAttributes is undocumented.
type WorkflowExecutionCancelRequestedEventAttributes struct {
	Cause                     aws.StringValue    `json:"cause,omitempty"`
	ExternalInitiatedEventID  aws.LongValue      `json:"externalInitiatedEventId,omitempty"`
	ExternalWorkflowExecution *WorkflowExecution `json:"externalWorkflowExecution,omitempty"`
}

func (v *WorkflowExecutionCancelRequestedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	causeEnum := []string{
		WorkflowExecutionCancelRequestedCauseChildPolicyApplied,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionCanceledEventAttributes is undocumented.
type WorkflowExecutionCanceledEventAttributes struct {
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	Details                      aws.StringValue `json:"details,omitempty"`
}

func (v *WorkflowExecutionCanceledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionCompletedEventAttributes is undocumented.
type WorkflowExecutionCompletedEventAttributes struct {
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	Result                       aws.StringValue `json:"result,omitempty"`
}

func (v *WorkflowExecutionCompletedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "Result", 32768); err != nil {
		errors["Result"] = append(errors["Result"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionConfiguration is undocumented.
type WorkflowExecutionConfiguration struct {
	ChildPolicy                  aws.StringValue `json:"childPolicy"`
	ExecutionStartToCloseTimeout aws.StringValue `json:"executionStartToCloseTimeout"`
	TaskList                     *TaskList       `json:"taskList"`
	TaskStartToCloseTimeout      aws.StringValue `json:"taskStartToCloseTimeout"`
}

func (v *WorkflowExecutionConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ChildPolicy"); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateRequired(v, "ExecutionStartToCloseTimeout"); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMin(v, "ExecutionStartToCloseTimeout", 1); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if err := model.ValidateRequired(v, "TaskStartToCloseTimeout"); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateMin(v, "TaskStartToCloseTimeout", 1); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionContinuedAsNewEventAttributes is undocumented.
type WorkflowExecutionContinuedAsNewEventAttributes struct {
	ChildPolicy                  aws.StringValue `json:"childPolicy"`
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	ExecutionStartToCloseTimeout aws.StringValue `json:"executionStartToCloseTimeout,omitempty"`
	Input                        aws.StringValue `json:"input,omitempty"`
	NewExecutionRunID            aws.StringValue `json:"newExecutionRunId"`
	TagList                      []string        `json:"tagList,omitempty"`
	TaskList                     *TaskList       `json:"taskList"`
	TaskStartToCloseTimeout      aws.StringValue `json:"taskStartToCloseTimeout,omitempty"`
	WorkflowType                 *WorkflowType   `json:"workflowType"`
}

func (v *WorkflowExecutionContinuedAsNewEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ChildPolicy"); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateRequired(v, "NewExecutionRunID"); err != nil {
		errors["NewExecutionRunID"] = append(errors["NewExecutionRunID"], err)
	}

	if err := model.ValidateMin(v, "NewExecutionRunID", 1); err != nil {
		errors["NewExecutionRunID"] = append(errors["NewExecutionRunID"], err)
	}

	if err := model.ValidateMax(v, "NewExecutionRunID", 64); err != nil {
		errors["NewExecutionRunID"] = append(errors["NewExecutionRunID"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionCount is undocumented.
type WorkflowExecutionCount struct {
	Count     aws.IntegerValue `json:"count"`
	Truncated aws.BooleanValue `json:"truncated,omitempty"`
}

func (v *WorkflowExecutionCount) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Count"); err != nil {
		errors["Count"] = append(errors["Count"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionDetail is undocumented.
type WorkflowExecutionDetail struct {
	ExecutionConfiguration      *WorkflowExecutionConfiguration `json:"executionConfiguration"`
	ExecutionInfo               *WorkflowExecutionInfo          `json:"executionInfo"`
	LatestActivityTaskTimestamp *aws.LongTimestamp              `json:"latestActivityTaskTimestamp,omitempty"`
	LatestExecutionContext      aws.StringValue                 `json:"latestExecutionContext,omitempty"`
	OpenCounts                  *WorkflowExecutionOpenCounts    `json:"openCounts"`
}

func (v *WorkflowExecutionDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ExecutionConfiguration"); err != nil {
		errors["ExecutionConfiguration"] = append(errors["ExecutionConfiguration"], err)
	}

	if err := model.ValidateRequired(v, "ExecutionInfo"); err != nil {
		errors["ExecutionInfo"] = append(errors["ExecutionInfo"], err)
	}

	if err := model.ValidateMax(v, "LatestExecutionContext", 32768); err != nil {
		errors["LatestExecutionContext"] = append(errors["LatestExecutionContext"], err)
	}

	if err := model.ValidateRequired(v, "OpenCounts"); err != nil {
		errors["OpenCounts"] = append(errors["OpenCounts"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionFailedEventAttributes is undocumented.
type WorkflowExecutionFailedEventAttributes struct {
	DecisionTaskCompletedEventID aws.LongValue   `json:"decisionTaskCompletedEventId"`
	Details                      aws.StringValue `json:"details,omitempty"`
	Reason                       aws.StringValue `json:"reason,omitempty"`
}

func (v *WorkflowExecutionFailedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DecisionTaskCompletedEventID"); err != nil {
		errors["DecisionTaskCompletedEventID"] = append(errors["DecisionTaskCompletedEventID"], err)
	}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionFilter is undocumented.
type WorkflowExecutionFilter struct {
	WorkflowID aws.StringValue `json:"workflowId"`
}

func (v *WorkflowExecutionFilter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "WorkflowID"); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMin(v, "WorkflowID", 1); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if err := model.ValidateMax(v, "WorkflowID", 256); err != nil {
		errors["WorkflowID"] = append(errors["WorkflowID"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionInfo is undocumented.
type WorkflowExecutionInfo struct {
	CancelRequested aws.BooleanValue   `json:"cancelRequested,omitempty"`
	CloseStatus     aws.StringValue    `json:"closeStatus,omitempty"`
	CloseTimestamp  *aws.LongTimestamp `json:"closeTimestamp,omitempty"`
	Execution       *WorkflowExecution `json:"execution"`
	ExecutionStatus aws.StringValue    `json:"executionStatus"`
	Parent          *WorkflowExecution `json:"parent,omitempty"`
	StartTimestamp  *aws.LongTimestamp `json:"startTimestamp"`
	TagList         []string           `json:"tagList,omitempty"`
	WorkflowType    *WorkflowType      `json:"workflowType"`
}

func (v *WorkflowExecutionInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	closeStatusEnum := []string{
		CloseStatusCanceled,
		CloseStatusCompleted,
		CloseStatusContinuedAsNew,
		CloseStatusFailed,
		CloseStatusTerminated,
		CloseStatusTimedOut,
	}
	if err := model.ValidateEnum(v, "CloseStatus", closeStatusEnum); err != nil {
		errors["CloseStatus"] = append(errors["CloseStatus"], err)
	}

	if err := model.ValidateRequired(v, "Execution"); err != nil {
		errors["Execution"] = append(errors["Execution"], err)
	}

	if err := model.ValidateRequired(v, "ExecutionStatus"); err != nil {
		errors["ExecutionStatus"] = append(errors["ExecutionStatus"], err)
	}

	executionStatusEnum := []string{
		ExecutionStatusClosed,
		ExecutionStatusOpen,
	}
	if err := model.ValidateEnum(v, "ExecutionStatus", executionStatusEnum); err != nil {
		errors["ExecutionStatus"] = append(errors["ExecutionStatus"], err)
	}

	if err := model.ValidateRequired(v, "StartTimestamp"); err != nil {
		errors["StartTimestamp"] = append(errors["StartTimestamp"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionInfos is undocumented.
type WorkflowExecutionInfos struct {
	ExecutionInfos []WorkflowExecutionInfo `json:"executionInfos"`
	NextPageToken  aws.StringValue         `json:"nextPageToken,omitempty"`
}

func (v *WorkflowExecutionInfos) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ExecutionInfos"); err != nil {
		errors["ExecutionInfos"] = append(errors["ExecutionInfos"], err)
	}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionOpenCounts is undocumented.
type WorkflowExecutionOpenCounts struct {
	OpenActivityTasks           aws.IntegerValue `json:"openActivityTasks"`
	OpenChildWorkflowExecutions aws.IntegerValue `json:"openChildWorkflowExecutions"`
	OpenDecisionTasks           aws.IntegerValue `json:"openDecisionTasks"`
	OpenTimers                  aws.IntegerValue `json:"openTimers"`
}

func (v *WorkflowExecutionOpenCounts) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "OpenActivityTasks"); err != nil {
		errors["OpenActivityTasks"] = append(errors["OpenActivityTasks"], err)
	}

	if err := model.ValidateRequired(v, "OpenChildWorkflowExecutions"); err != nil {
		errors["OpenChildWorkflowExecutions"] = append(errors["OpenChildWorkflowExecutions"], err)
	}

	if err := model.ValidateRequired(v, "OpenDecisionTasks"); err != nil {
		errors["OpenDecisionTasks"] = append(errors["OpenDecisionTasks"], err)
	}

	if err := model.ValidateMax(v, "OpenDecisionTasks", 1); err != nil {
		errors["OpenDecisionTasks"] = append(errors["OpenDecisionTasks"], err)
	}

	if err := model.ValidateRequired(v, "OpenTimers"); err != nil {
		errors["OpenTimers"] = append(errors["OpenTimers"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionSignaledEventAttributes is undocumented.
type WorkflowExecutionSignaledEventAttributes struct {
	ExternalInitiatedEventID  aws.LongValue      `json:"externalInitiatedEventId,omitempty"`
	ExternalWorkflowExecution *WorkflowExecution `json:"externalWorkflowExecution,omitempty"`
	Input                     aws.StringValue    `json:"input,omitempty"`
	SignalName                aws.StringValue    `json:"signalName"`
}

func (v *WorkflowExecutionSignaledEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateRequired(v, "SignalName"); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMin(v, "SignalName", 1); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if err := model.ValidateMax(v, "SignalName", 256); err != nil {
		errors["SignalName"] = append(errors["SignalName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionStartedEventAttributes is undocumented.
type WorkflowExecutionStartedEventAttributes struct {
	ChildPolicy                  aws.StringValue    `json:"childPolicy"`
	ContinuedExecutionRunID      aws.StringValue    `json:"continuedExecutionRunId,omitempty"`
	ExecutionStartToCloseTimeout aws.StringValue    `json:"executionStartToCloseTimeout,omitempty"`
	Input                        aws.StringValue    `json:"input,omitempty"`
	ParentInitiatedEventID       aws.LongValue      `json:"parentInitiatedEventId,omitempty"`
	ParentWorkflowExecution      *WorkflowExecution `json:"parentWorkflowExecution,omitempty"`
	TagList                      []string           `json:"tagList,omitempty"`
	TaskList                     *TaskList          `json:"taskList"`
	TaskStartToCloseTimeout      aws.StringValue    `json:"taskStartToCloseTimeout,omitempty"`
	WorkflowType                 *WorkflowType      `json:"workflowType"`
}

func (v *WorkflowExecutionStartedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ChildPolicy"); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "ContinuedExecutionRunID", 64); err != nil {
		errors["ContinuedExecutionRunID"] = append(errors["ContinuedExecutionRunID"], err)
	}

	if err := model.ValidateMax(v, "ExecutionStartToCloseTimeout", 8); err != nil {
		errors["ExecutionStartToCloseTimeout"] = append(errors["ExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "Input", 32768); err != nil {
		errors["Input"] = append(errors["Input"], err)
	}

	if err := model.ValidateMax(v, "TagList", 5); err != nil {
		errors["TagList"] = append(errors["TagList"], err)
	}

	if err := model.ValidateRequired(v, "TaskList"); err != nil {
		errors["TaskList"] = append(errors["TaskList"], err)
	}

	if err := model.ValidateMax(v, "TaskStartToCloseTimeout", 8); err != nil {
		errors["TaskStartToCloseTimeout"] = append(errors["TaskStartToCloseTimeout"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	WorkflowExecutionTerminatedCauseChildPolicyApplied = "CHILD_POLICY_APPLIED"
	WorkflowExecutionTerminatedCauseEventLimitExceeded = "EVENT_LIMIT_EXCEEDED"
	WorkflowExecutionTerminatedCauseOperatorInitiated  = "OPERATOR_INITIATED"
)

// WorkflowExecutionTerminatedEventAttributes is undocumented.
type WorkflowExecutionTerminatedEventAttributes struct {
	Cause       aws.StringValue `json:"cause,omitempty"`
	ChildPolicy aws.StringValue `json:"childPolicy"`
	Details     aws.StringValue `json:"details,omitempty"`
	Reason      aws.StringValue `json:"reason,omitempty"`
}

func (v *WorkflowExecutionTerminatedEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	causeEnum := []string{
		WorkflowExecutionTerminatedCauseChildPolicyApplied,
		WorkflowExecutionTerminatedCauseEventLimitExceeded,
		WorkflowExecutionTerminatedCauseOperatorInitiated,
	}
	if err := model.ValidateEnum(v, "Cause", causeEnum); err != nil {
		errors["Cause"] = append(errors["Cause"], err)
	}

	if err := model.ValidateRequired(v, "ChildPolicy"); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "Details", 32768); err != nil {
		errors["Details"] = append(errors["Details"], err)
	}

	if err := model.ValidateMax(v, "Reason", 256); err != nil {
		errors["Reason"] = append(errors["Reason"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowExecutionTimedOutEventAttributes is undocumented.
type WorkflowExecutionTimedOutEventAttributes struct {
	ChildPolicy aws.StringValue `json:"childPolicy"`
	TimeoutType aws.StringValue `json:"timeoutType"`
}

func (v *WorkflowExecutionTimedOutEventAttributes) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ChildPolicy"); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	childPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "ChildPolicy", childPolicyEnum); err != nil {
		errors["ChildPolicy"] = append(errors["ChildPolicy"], err)
	}

	if err := model.ValidateRequired(v, "TimeoutType"); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	timeoutTypeEnum := []string{
		WorkflowExecutionTimeoutTypeStartToClose,
	}
	if err := model.ValidateEnum(v, "TimeoutType", timeoutTypeEnum); err != nil {
		errors["TimeoutType"] = append(errors["TimeoutType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for SWF.
const (
	WorkflowExecutionTimeoutTypeStartToClose = "START_TO_CLOSE"
)

// WorkflowType is undocumented.
type WorkflowType struct {
	Name    aws.StringValue `json:"name"`
	Version aws.StringValue `json:"version"`
}

func (v *WorkflowType) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateRequired(v, "Version"); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMin(v, "Version", 1); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if err := model.ValidateMax(v, "Version", 64); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowTypeConfiguration is undocumented.
type WorkflowTypeConfiguration struct {
	DefaultChildPolicy                  aws.StringValue `json:"defaultChildPolicy,omitempty"`
	DefaultExecutionStartToCloseTimeout aws.StringValue `json:"defaultExecutionStartToCloseTimeout,omitempty"`
	DefaultTaskList                     *TaskList       `json:"defaultTaskList,omitempty"`
	DefaultTaskStartToCloseTimeout      aws.StringValue `json:"defaultTaskStartToCloseTimeout,omitempty"`
}

func (v *WorkflowTypeConfiguration) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	defaultChildPolicyEnum := []string{
		ChildPolicyAbandon,
		ChildPolicyRequestCancel,
		ChildPolicyTerminate,
	}
	if err := model.ValidateEnum(v, "DefaultChildPolicy", defaultChildPolicyEnum); err != nil {
		errors["DefaultChildPolicy"] = append(errors["DefaultChildPolicy"], err)
	}

	if err := model.ValidateMax(v, "DefaultExecutionStartToCloseTimeout", 8); err != nil {
		errors["DefaultExecutionStartToCloseTimeout"] = append(errors["DefaultExecutionStartToCloseTimeout"], err)
	}

	if err := model.ValidateMax(v, "DefaultTaskStartToCloseTimeout", 8); err != nil {
		errors["DefaultTaskStartToCloseTimeout"] = append(errors["DefaultTaskStartToCloseTimeout"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowTypeDetail is undocumented.
type WorkflowTypeDetail struct {
	Configuration *WorkflowTypeConfiguration `json:"configuration"`
	TypeInfo      *WorkflowTypeInfo          `json:"typeInfo"`
}

func (v *WorkflowTypeDetail) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Configuration"); err != nil {
		errors["Configuration"] = append(errors["Configuration"], err)
	}

	if err := model.ValidateRequired(v, "TypeInfo"); err != nil {
		errors["TypeInfo"] = append(errors["TypeInfo"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowTypeFilter is undocumented.
type WorkflowTypeFilter struct {
	Name    aws.StringValue `json:"name"`
	Version aws.StringValue `json:"version,omitempty"`
}

func (v *WorkflowTypeFilter) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Name"); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMin(v, "Name", 1); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Name", 256); err != nil {
		errors["Name"] = append(errors["Name"], err)
	}

	if err := model.ValidateMax(v, "Version", 64); err != nil {
		errors["Version"] = append(errors["Version"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowTypeInfo is undocumented.
type WorkflowTypeInfo struct {
	CreationDate    *aws.LongTimestamp `json:"creationDate"`
	DeprecationDate *aws.LongTimestamp `json:"deprecationDate,omitempty"`
	Description     aws.StringValue    `json:"description,omitempty"`
	Status          aws.StringValue    `json:"status"`
	WorkflowType    *WorkflowType      `json:"workflowType"`
}

func (v *WorkflowTypeInfo) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CreationDate"); err != nil {
		errors["CreationDate"] = append(errors["CreationDate"], err)
	}

	if err := model.ValidateMax(v, "Description", 1024); err != nil {
		errors["Description"] = append(errors["Description"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	statusEnum := []string{
		RegistrationStatusDeprecated,
		RegistrationStatusRegistered,
	}
	if err := model.ValidateEnum(v, "Status", statusEnum); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if err := model.ValidateRequired(v, "WorkflowType"); err != nil {
		errors["WorkflowType"] = append(errors["WorkflowType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// WorkflowTypeInfos is undocumented.
type WorkflowTypeInfos struct {
	NextPageToken aws.StringValue    `json:"nextPageToken,omitempty"`
	TypeInfos     []WorkflowTypeInfo `json:"typeInfos"`
}

func (v *WorkflowTypeInfos) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "NextPageToken", 2048); err != nil {
		errors["NextPageToken"] = append(errors["NextPageToken"], err)
	}

	if err := model.ValidateRequired(v, "TypeInfos"); err != nil {
		errors["TypeInfos"] = append(errors["TypeInfos"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// avoid errors if the packages aren't referenced
var _ time.Time
