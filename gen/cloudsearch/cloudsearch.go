// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package cloudsearch provides a client for Amazon CloudSearch.
package cloudsearch

import (
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/gen/endpoints"
	"github.com/stripe/aws-go/model"
)

// CloudSearch is a client for Amazon CloudSearch.
type CloudSearch struct {
	client *aws.QueryClient
}

// New returns a new CloudSearch client.
func New(creds aws.CredentialsProvider, region string, client *http.Client) *CloudSearch {
	if client == nil {
		client = http.DefaultClient
	}

	service := "cloudsearch"
	endpoint, service, region := endpoints.Lookup("cloudsearch", region)

	return &CloudSearch{
		client: &aws.QueryClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2013-01-01",
		},
	}
}

// BuildSuggesters indexes the search suggestions. For more information,
// see Configuring Suggesters in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) BuildSuggesters(req *BuildSuggestersRequest) (resp *BuildSuggestersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &BuildSuggestersResult{}
	err = c.client.Do("BuildSuggesters", "POST", "/", req, resp)
	return
}

// CreateDomain creates a new search domain. For more information, see
// Creating a Search Domain in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) CreateDomain(req *CreateDomainRequest) (resp *CreateDomainResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &CreateDomainResult{}
	err = c.client.Do("CreateDomain", "POST", "/", req, resp)
	return
}

// DefineAnalysisScheme configures an analysis scheme that can be applied
// to a text or text-array field to define language-specific text
// processing options. For more information, see Configuring Analysis
// Schemes in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DefineAnalysisScheme(req *DefineAnalysisSchemeRequest) (resp *DefineAnalysisSchemeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DefineAnalysisSchemeResult{}
	err = c.client.Do("DefineAnalysisScheme", "POST", "/", req, resp)
	return
}

// DefineExpression configures an Expression for the search domain. Used to
// create new expressions and modify existing ones. If the expression
// exists, the new configuration replaces the old one. For more
// information, see Configuring Expressions in the Amazon CloudSearch
// Developer Guide
func (c *CloudSearch) DefineExpression(req *DefineExpressionRequest) (resp *DefineExpressionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DefineExpressionResult{}
	err = c.client.Do("DefineExpression", "POST", "/", req, resp)
	return
}

// DefineIndexField configures an IndexField for the search domain. Used to
// create new fields and modify existing ones. You must specify the name of
// the domain you are configuring and an index field configuration. The
// index field configuration specifies a unique name, the index field type,
// and the options you want to configure for the field. The options you can
// specify depend on the IndexFieldType . If the field exists, the new
// configuration replaces the old one. For more information, see
// Configuring Index Fields in the Amazon CloudSearch Developer Guide .
func (c *CloudSearch) DefineIndexField(req *DefineIndexFieldRequest) (resp *DefineIndexFieldResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DefineIndexFieldResult{}
	err = c.client.Do("DefineIndexField", "POST", "/", req, resp)
	return
}

// DefineSuggester configures a suggester for a domain. A suggester enables
// you to display possible matches before users finish typing their
// queries. When you configure a suggester, you must specify the name of
// the text field you want to search for possible matches and a unique name
// for the suggester. For more information, see Getting Search Suggestions
// in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DefineSuggester(req *DefineSuggesterRequest) (resp *DefineSuggesterResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DefineSuggesterResult{}
	err = c.client.Do("DefineSuggester", "POST", "/", req, resp)
	return
}

// DeleteAnalysisScheme deletes an analysis scheme. For more information,
// see Configuring Analysis Schemes in the Amazon CloudSearch Developer
// Guide .
func (c *CloudSearch) DeleteAnalysisScheme(req *DeleteAnalysisSchemeRequest) (resp *DeleteAnalysisSchemeResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteAnalysisSchemeResult{}
	err = c.client.Do("DeleteAnalysisScheme", "POST", "/", req, resp)
	return
}

// DeleteDomain permanently deletes a search domain and all of its data.
// Once a domain has been deleted, it cannot be recovered. For more
// information, see Deleting a Search Domain in the Amazon CloudSearch
// Developer Guide .
func (c *CloudSearch) DeleteDomain(req *DeleteDomainRequest) (resp *DeleteDomainResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteDomainResult{}
	err = c.client.Do("DeleteDomain", "POST", "/", req, resp)
	return
}

// DeleteExpression removes an Expression from the search domain. For more
// information, see Configuring Expressions in the Amazon CloudSearch
// Developer Guide
func (c *CloudSearch) DeleteExpression(req *DeleteExpressionRequest) (resp *DeleteExpressionResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteExpressionResult{}
	err = c.client.Do("DeleteExpression", "POST", "/", req, resp)
	return
}

// DeleteIndexField removes an IndexField from the search domain. For more
// information, see Configuring Index Fields in the Amazon CloudSearch
// Developer Guide
func (c *CloudSearch) DeleteIndexField(req *DeleteIndexFieldRequest) (resp *DeleteIndexFieldResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteIndexFieldResult{}
	err = c.client.Do("DeleteIndexField", "POST", "/", req, resp)
	return
}

// DeleteSuggester deletes a suggester. For more information, see Getting
// Search Suggestions in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DeleteSuggester(req *DeleteSuggesterRequest) (resp *DeleteSuggesterResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DeleteSuggesterResult{}
	err = c.client.Do("DeleteSuggester", "POST", "/", req, resp)
	return
}

// DescribeAnalysisSchemes gets the analysis schemes configured for a
// domain. An analysis scheme defines language-specific text processing
// options for a text field. Can be limited to specific analysis schemes by
// name. By default, shows all analysis schemes and includes any pending
// changes to the configuration. Set the Deployed option to true to show
// the active configuration and exclude pending changes. For more
// information, see Configuring Analysis Schemes in the Amazon CloudSearch
// Developer Guide
func (c *CloudSearch) DescribeAnalysisSchemes(req *DescribeAnalysisSchemesRequest) (resp *DescribeAnalysisSchemesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeAnalysisSchemesResult{}
	err = c.client.Do("DescribeAnalysisSchemes", "POST", "/", req, resp)
	return
}

// DescribeAvailabilityOptions gets the availability options configured for
// a domain. By default, shows the configuration with any pending changes.
// Set the Deployed option to true to show the active configuration and
// exclude pending changes. For more information, see Configuring
// Availability Options in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DescribeAvailabilityOptions(req *DescribeAvailabilityOptionsRequest) (resp *DescribeAvailabilityOptionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeAvailabilityOptionsResult{}
	err = c.client.Do("DescribeAvailabilityOptions", "POST", "/", req, resp)
	return
}

// DescribeDomains gets information about the search domains owned by this
// account. Can be limited to specific domains. Shows all domains by
// default. To get the number of searchable documents in a domain, use the
// console or submit a matchall request to your domain's search endpoint:
// q=matchall&q.parser=structured&size=0 . For more information, see
// Getting Information about a Search Domain in the Amazon CloudSearch
// Developer Guide
func (c *CloudSearch) DescribeDomains(req *DescribeDomainsRequest) (resp *DescribeDomainsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeDomainsResult{}
	err = c.client.Do("DescribeDomains", "POST", "/", req, resp)
	return
}

// DescribeExpressions gets the expressions configured for the search
// domain. Can be limited to specific expressions by name. By default,
// shows all expressions and includes any pending changes to the
// configuration. Set the Deployed option to true to show the active
// configuration and exclude pending changes. For more information, see
// Configuring Expressions in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DescribeExpressions(req *DescribeExpressionsRequest) (resp *DescribeExpressionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeExpressionsResult{}
	err = c.client.Do("DescribeExpressions", "POST", "/", req, resp)
	return
}

// DescribeIndexFields gets information about the index fields configured
// for the search domain. Can be limited to specific fields by name. By
// default, shows all fields and includes any pending changes to the
// configuration. Set the Deployed option to true to show the active
// configuration and exclude pending changes. For more information, see
// Getting Domain Information in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DescribeIndexFields(req *DescribeIndexFieldsRequest) (resp *DescribeIndexFieldsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeIndexFieldsResult{}
	err = c.client.Do("DescribeIndexFields", "POST", "/", req, resp)
	return
}

// DescribeScalingParameters gets the scaling parameters configured for a
// domain. A domain's scaling parameters specify the desired search
// instance type and replication count. For more information, see
// Configuring Scaling Options in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DescribeScalingParameters(req *DescribeScalingParametersRequest) (resp *DescribeScalingParametersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeScalingParametersResult{}
	err = c.client.Do("DescribeScalingParameters", "POST", "/", req, resp)
	return
}

// DescribeServiceAccessPolicies gets information about the access policies
// that control access to the domain's document and search endpoints. By
// default, shows the configuration with any pending changes. Set the
// Deployed option to true to show the active configuration and exclude
// pending changes. For more information, see Configuring Access for a
// Search Domain in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DescribeServiceAccessPolicies(req *DescribeServiceAccessPoliciesRequest) (resp *DescribeServiceAccessPoliciesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeServiceAccessPoliciesResult{}
	err = c.client.Do("DescribeServiceAccessPolicies", "POST", "/", req, resp)
	return
}

// DescribeSuggesters gets the suggesters configured for a domain. A
// suggester enables you to display possible matches before users finish
// typing their queries. Can be limited to specific suggesters by name. By
// default, shows all suggesters and includes any pending changes to the
// configuration. Set the Deployed option to true to show the active
// configuration and exclude pending changes. For more information, see
// Getting Search Suggestions in the Amazon CloudSearch Developer Guide
func (c *CloudSearch) DescribeSuggesters(req *DescribeSuggestersRequest) (resp *DescribeSuggestersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &DescribeSuggestersResult{}
	err = c.client.Do("DescribeSuggesters", "POST", "/", req, resp)
	return
}

// IndexDocuments tells the search domain to start indexing its documents
// using the latest indexing options. This operation must be invoked to
// activate options whose OptionStatus is RequiresIndexDocuments
func (c *CloudSearch) IndexDocuments(req *IndexDocumentsRequest) (resp *IndexDocumentsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &IndexDocumentsResult{}
	err = c.client.Do("IndexDocuments", "POST", "/", req, resp)
	return
}

// ListDomainNames is undocumented.
func (c *CloudSearch) ListDomainNames() (resp *ListDomainNamesResult, err error) {
	resp = &ListDomainNamesResult{}
	err = c.client.Do("ListDomainNames", "POST", "/", nil, resp)
	return
}

// UpdateAvailabilityOptions configures the availability options for a
// domain. Enabling the Multi-AZ option expands an Amazon CloudSearch
// domain to an additional Availability Zone in the same Region to increase
// fault tolerance in the event of a service disruption. Changes to the
// Multi-AZ option can take about half an hour to become active. For more
// information, see Configuring Availability Options in the Amazon
// CloudSearch Developer Guide
func (c *CloudSearch) UpdateAvailabilityOptions(req *UpdateAvailabilityOptionsRequest) (resp *UpdateAvailabilityOptionsResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateAvailabilityOptionsResult{}
	err = c.client.Do("UpdateAvailabilityOptions", "POST", "/", req, resp)
	return
}

// UpdateScalingParameters configures scaling parameters for a domain. A
// domain's scaling parameters specify the desired search instance type and
// replication count. Amazon CloudSearch will still automatically scale
// your domain based on the volume of data and traffic, but not below the
// desired instance type and replication count. If the Multi-AZ option is
// enabled, these values control the resources used per Availability Zone.
// For more information, see Configuring Scaling Options in the Amazon
// CloudSearch Developer Guide .
func (c *CloudSearch) UpdateScalingParameters(req *UpdateScalingParametersRequest) (resp *UpdateScalingParametersResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateScalingParametersResult{}
	err = c.client.Do("UpdateScalingParameters", "POST", "/", req, resp)
	return
}

// UpdateServiceAccessPolicies configures the access rules that control
// access to the domain's document and search endpoints. For more
// information, see Configuring Access for an Amazon CloudSearch Domain
func (c *CloudSearch) UpdateServiceAccessPolicies(req *UpdateServiceAccessPoliciesRequest) (resp *UpdateServiceAccessPoliciesResult, err error) {
	if err = req.Validate(); err != nil {
		return
	}

	resp = &UpdateServiceAccessPoliciesResult{}
	err = c.client.Do("UpdateServiceAccessPolicies", "POST", "/", req, resp)
	return
}

// AccessPoliciesStatus is undocumented.
type AccessPoliciesStatus struct {
	Options aws.StringValue `xml:"Options"`
	Status  *OptionStatus   `xml:"Status"`
}

func (v *AccessPoliciesStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudSearch.
const (
	AlgorithmicStemmingFull    = "full"
	AlgorithmicStemmingLight   = "light"
	AlgorithmicStemmingMinimal = "minimal"
	AlgorithmicStemmingNone    = "none"
)

// AnalysisOptions is undocumented.
type AnalysisOptions struct {
	AlgorithmicStemming            aws.StringValue `xml:"AlgorithmicStemming"`
	JapaneseTokenizationDictionary aws.StringValue `xml:"JapaneseTokenizationDictionary"`
	StemmingDictionary             aws.StringValue `xml:"StemmingDictionary"`
	Stopwords                      aws.StringValue `xml:"Stopwords"`
	Synonyms                       aws.StringValue `xml:"Synonyms"`
}

func (v *AnalysisOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	AlgorithmicStemmingEnum := []string{
		AlgorithmicStemmingFull,
		AlgorithmicStemmingLight,
		AlgorithmicStemmingMinimal,
		AlgorithmicStemmingNone,
	}
	if err := model.ValidateEnum(v, "AlgorithmicStemming", AlgorithmicStemmingEnum); err != nil {
		errors["AlgorithmicStemming"] = append(errors["AlgorithmicStemming"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AnalysisScheme is undocumented.
type AnalysisScheme struct {
	AnalysisOptions        *AnalysisOptions `xml:"AnalysisOptions"`
	AnalysisSchemeLanguage aws.StringValue  `xml:"AnalysisSchemeLanguage"`
	AnalysisSchemeName     aws.StringValue  `xml:"AnalysisSchemeName"`
}

func (v *AnalysisScheme) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AnalysisSchemeLanguage"); err != nil {
		errors["AnalysisSchemeLanguage"] = append(errors["AnalysisSchemeLanguage"], err)
	}

	AnalysisSchemeLanguageEnum := []string{
		AnalysisSchemeLanguageAr,
		AnalysisSchemeLanguageBg,
		AnalysisSchemeLanguageCa,
		AnalysisSchemeLanguageCs,
		AnalysisSchemeLanguageDa,
		AnalysisSchemeLanguageDe,
		AnalysisSchemeLanguageEl,
		AnalysisSchemeLanguageEn,
		AnalysisSchemeLanguageEs,
		AnalysisSchemeLanguageEu,
		AnalysisSchemeLanguageFa,
		AnalysisSchemeLanguageFi,
		AnalysisSchemeLanguageFr,
		AnalysisSchemeLanguageGa,
		AnalysisSchemeLanguageGl,
		AnalysisSchemeLanguageHe,
		AnalysisSchemeLanguageHi,
		AnalysisSchemeLanguageHu,
		AnalysisSchemeLanguageHy,
		AnalysisSchemeLanguageID,
		AnalysisSchemeLanguageIt,
		AnalysisSchemeLanguageJa,
		AnalysisSchemeLanguageKo,
		AnalysisSchemeLanguageLv,
		AnalysisSchemeLanguageMul,
		AnalysisSchemeLanguageNl,
		AnalysisSchemeLanguageNo,
		AnalysisSchemeLanguagePt,
		AnalysisSchemeLanguageRo,
		AnalysisSchemeLanguageRu,
		AnalysisSchemeLanguageSv,
		AnalysisSchemeLanguageTh,
		AnalysisSchemeLanguageTr,
		AnalysisSchemeLanguageZhHans,
		AnalysisSchemeLanguageZhHant,
	}
	if err := model.ValidateEnum(v, "AnalysisSchemeLanguage", AnalysisSchemeLanguageEnum); err != nil {
		errors["AnalysisSchemeLanguage"] = append(errors["AnalysisSchemeLanguage"], err)
	}

	if err := model.ValidateRequired(v, "AnalysisSchemeName"); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidateMin(v, "AnalysisSchemeName", 1); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidateMax(v, "AnalysisSchemeName", 64); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidatePattern(v, "AnalysisSchemeName", `[a-z][a-z0-9_]*`); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudSearch.
const (
	AnalysisSchemeLanguageAr     = "ar"
	AnalysisSchemeLanguageBg     = "bg"
	AnalysisSchemeLanguageCa     = "ca"
	AnalysisSchemeLanguageCs     = "cs"
	AnalysisSchemeLanguageDa     = "da"
	AnalysisSchemeLanguageDe     = "de"
	AnalysisSchemeLanguageEl     = "el"
	AnalysisSchemeLanguageEn     = "en"
	AnalysisSchemeLanguageEs     = "es"
	AnalysisSchemeLanguageEu     = "eu"
	AnalysisSchemeLanguageFa     = "fa"
	AnalysisSchemeLanguageFi     = "fi"
	AnalysisSchemeLanguageFr     = "fr"
	AnalysisSchemeLanguageGa     = "ga"
	AnalysisSchemeLanguageGl     = "gl"
	AnalysisSchemeLanguageHe     = "he"
	AnalysisSchemeLanguageHi     = "hi"
	AnalysisSchemeLanguageHu     = "hu"
	AnalysisSchemeLanguageHy     = "hy"
	AnalysisSchemeLanguageID     = "id"
	AnalysisSchemeLanguageIt     = "it"
	AnalysisSchemeLanguageJa     = "ja"
	AnalysisSchemeLanguageKo     = "ko"
	AnalysisSchemeLanguageLv     = "lv"
	AnalysisSchemeLanguageMul    = "mul"
	AnalysisSchemeLanguageNl     = "nl"
	AnalysisSchemeLanguageNo     = "no"
	AnalysisSchemeLanguagePt     = "pt"
	AnalysisSchemeLanguageRo     = "ro"
	AnalysisSchemeLanguageRu     = "ru"
	AnalysisSchemeLanguageSv     = "sv"
	AnalysisSchemeLanguageTh     = "th"
	AnalysisSchemeLanguageTr     = "tr"
	AnalysisSchemeLanguageZhHans = "zh-Hans"
	AnalysisSchemeLanguageZhHant = "zh-Hant"
)

// AnalysisSchemeStatus is undocumented.
type AnalysisSchemeStatus struct {
	Options *AnalysisScheme `xml:"Options"`
	Status  *OptionStatus   `xml:"Status"`
}

func (v *AnalysisSchemeStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// AvailabilityOptionsStatus is undocumented.
type AvailabilityOptionsStatus struct {
	Options aws.BooleanValue `xml:"Options"`
	Status  *OptionStatus    `xml:"Status"`
}

func (v *AvailabilityOptionsStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BuildSuggestersRequest is undocumented.
type BuildSuggestersRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
}

func (v *BuildSuggestersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BuildSuggestersResponse is undocumented.
type BuildSuggestersResponse struct {
	FieldNames []string `xml:"BuildSuggestersResult>FieldNames>member"`
}

func (v *BuildSuggestersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateDomainRequest is undocumented.
type CreateDomainRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
}

func (v *CreateDomainRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// CreateDomainResponse is undocumented.
type CreateDomainResponse struct {
	DomainStatus *DomainStatus `xml:"CreateDomainResult>DomainStatus"`
}

func (v *CreateDomainResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DateArrayOptions is undocumented.
type DateArrayOptions struct {
	DefaultValue  aws.StringValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SourceFields  aws.StringValue  `xml:"SourceFields"`
}

func (v *DateArrayOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidatePattern(v, "SourceFields", `\s*[a-z][a-z0-9_]*\s*(,\s*[a-z][a-z0-9_]*\s*)*`); err != nil {
		errors["SourceFields"] = append(errors["SourceFields"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DateOptions is undocumented.
type DateOptions struct {
	DefaultValue  aws.StringValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SortEnabled   aws.BooleanValue `xml:"SortEnabled"`
	SourceField   aws.StringValue  `xml:"SourceField"`
}

func (v *DateOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineAnalysisSchemeRequest is undocumented.
type DefineAnalysisSchemeRequest struct {
	AnalysisScheme *AnalysisScheme `xml:"AnalysisScheme"`
	DomainName     aws.StringValue `xml:"DomainName"`
}

func (v *DefineAnalysisSchemeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AnalysisScheme"); err != nil {
		errors["AnalysisScheme"] = append(errors["AnalysisScheme"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineAnalysisSchemeResponse is undocumented.
type DefineAnalysisSchemeResponse struct {
	AnalysisScheme *AnalysisSchemeStatus `xml:"DefineAnalysisSchemeResult>AnalysisScheme"`
}

func (v *DefineAnalysisSchemeResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AnalysisScheme"); err != nil {
		errors["AnalysisScheme"] = append(errors["AnalysisScheme"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineExpressionRequest is undocumented.
type DefineExpressionRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
	Expression *Expression     `xml:"Expression"`
}

func (v *DefineExpressionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "Expression"); err != nil {
		errors["Expression"] = append(errors["Expression"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineExpressionResponse is undocumented.
type DefineExpressionResponse struct {
	Expression *ExpressionStatus `xml:"DefineExpressionResult>Expression"`
}

func (v *DefineExpressionResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Expression"); err != nil {
		errors["Expression"] = append(errors["Expression"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineIndexFieldRequest is undocumented.
type DefineIndexFieldRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
	IndexField *IndexField     `xml:"IndexField"`
}

func (v *DefineIndexFieldRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "IndexField"); err != nil {
		errors["IndexField"] = append(errors["IndexField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineIndexFieldResponse is undocumented.
type DefineIndexFieldResponse struct {
	IndexField *IndexFieldStatus `xml:"DefineIndexFieldResult>IndexField"`
}

func (v *DefineIndexFieldResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IndexField"); err != nil {
		errors["IndexField"] = append(errors["IndexField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineSuggesterRequest is undocumented.
type DefineSuggesterRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
	Suggester  *Suggester      `xml:"Suggester"`
}

func (v *DefineSuggesterRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "Suggester"); err != nil {
		errors["Suggester"] = append(errors["Suggester"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DefineSuggesterResponse is undocumented.
type DefineSuggesterResponse struct {
	Suggester *SuggesterStatus `xml:"DefineSuggesterResult>Suggester"`
}

func (v *DefineSuggesterResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Suggester"); err != nil {
		errors["Suggester"] = append(errors["Suggester"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteAnalysisSchemeRequest is undocumented.
type DeleteAnalysisSchemeRequest struct {
	AnalysisSchemeName aws.StringValue `xml:"AnalysisSchemeName"`
	DomainName         aws.StringValue `xml:"DomainName"`
}

func (v *DeleteAnalysisSchemeRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AnalysisSchemeName"); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidateMin(v, "AnalysisSchemeName", 1); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidateMax(v, "AnalysisSchemeName", 64); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidatePattern(v, "AnalysisSchemeName", `[a-z][a-z0-9_]*`); err != nil {
		errors["AnalysisSchemeName"] = append(errors["AnalysisSchemeName"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteAnalysisSchemeResponse is undocumented.
type DeleteAnalysisSchemeResponse struct {
	AnalysisScheme *AnalysisSchemeStatus `xml:"DeleteAnalysisSchemeResult>AnalysisScheme"`
}

func (v *DeleteAnalysisSchemeResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AnalysisScheme"); err != nil {
		errors["AnalysisScheme"] = append(errors["AnalysisScheme"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteDomainRequest is undocumented.
type DeleteDomainRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
}

func (v *DeleteDomainRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteDomainResponse is undocumented.
type DeleteDomainResponse struct {
	DomainStatus *DomainStatus `xml:"DeleteDomainResult>DomainStatus"`
}

func (v *DeleteDomainResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteExpressionRequest is undocumented.
type DeleteExpressionRequest struct {
	DomainName     aws.StringValue `xml:"DomainName"`
	ExpressionName aws.StringValue `xml:"ExpressionName"`
}

func (v *DeleteExpressionRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "ExpressionName"); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidateMin(v, "ExpressionName", 1); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidateMax(v, "ExpressionName", 64); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidatePattern(v, "ExpressionName", `[a-z][a-z0-9_]*`); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteExpressionResponse is undocumented.
type DeleteExpressionResponse struct {
	Expression *ExpressionStatus `xml:"DeleteExpressionResult>Expression"`
}

func (v *DeleteExpressionResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Expression"); err != nil {
		errors["Expression"] = append(errors["Expression"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteIndexFieldRequest is undocumented.
type DeleteIndexFieldRequest struct {
	DomainName     aws.StringValue `xml:"DomainName"`
	IndexFieldName aws.StringValue `xml:"IndexFieldName"`
}

func (v *DeleteIndexFieldRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "IndexFieldName"); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidateMin(v, "IndexFieldName", 1); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidateMax(v, "IndexFieldName", 64); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidatePattern(v, "IndexFieldName", `[a-z][a-z0-9_]*`); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteIndexFieldResponse is undocumented.
type DeleteIndexFieldResponse struct {
	IndexField *IndexFieldStatus `xml:"DeleteIndexFieldResult>IndexField"`
}

func (v *DeleteIndexFieldResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IndexField"); err != nil {
		errors["IndexField"] = append(errors["IndexField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSuggesterRequest is undocumented.
type DeleteSuggesterRequest struct {
	DomainName    aws.StringValue `xml:"DomainName"`
	SuggesterName aws.StringValue `xml:"SuggesterName"`
}

func (v *DeleteSuggesterRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "SuggesterName"); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if err := model.ValidateMin(v, "SuggesterName", 1); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if err := model.ValidateMax(v, "SuggesterName", 64); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if err := model.ValidatePattern(v, "SuggesterName", `[a-z][a-z0-9_]*`); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DeleteSuggesterResponse is undocumented.
type DeleteSuggesterResponse struct {
	Suggester *SuggesterStatus `xml:"DeleteSuggesterResult>Suggester"`
}

func (v *DeleteSuggesterResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Suggester"); err != nil {
		errors["Suggester"] = append(errors["Suggester"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAnalysisSchemesRequest is undocumented.
type DescribeAnalysisSchemesRequest struct {
	AnalysisSchemeNames []string         `xml:"AnalysisSchemeNames>member"`
	Deployed            aws.BooleanValue `xml:"Deployed"`
	DomainName          aws.StringValue  `xml:"DomainName"`
}

func (v *DescribeAnalysisSchemesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAnalysisSchemesResponse is undocumented.
type DescribeAnalysisSchemesResponse struct {
	AnalysisSchemes []AnalysisSchemeStatus `xml:"DescribeAnalysisSchemesResult>AnalysisSchemes>member"`
}

func (v *DescribeAnalysisSchemesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AnalysisSchemes"); err != nil {
		errors["AnalysisSchemes"] = append(errors["AnalysisSchemes"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAvailabilityOptionsRequest is undocumented.
type DescribeAvailabilityOptionsRequest struct {
	Deployed   aws.BooleanValue `xml:"Deployed"`
	DomainName aws.StringValue  `xml:"DomainName"`
}

func (v *DescribeAvailabilityOptionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeAvailabilityOptionsResponse is undocumented.
type DescribeAvailabilityOptionsResponse struct {
	AvailabilityOptions *AvailabilityOptionsStatus `xml:"DescribeAvailabilityOptionsResult>AvailabilityOptions"`
}

func (v *DescribeAvailabilityOptionsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDomainsRequest is undocumented.
type DescribeDomainsRequest struct {
	DomainNames []string `xml:"DomainNames>member"`
}

func (v *DescribeDomainsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeDomainsResponse is undocumented.
type DescribeDomainsResponse struct {
	DomainStatusList []DomainStatus `xml:"DescribeDomainsResult>DomainStatusList>member"`
}

func (v *DescribeDomainsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainStatusList"); err != nil {
		errors["DomainStatusList"] = append(errors["DomainStatusList"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeExpressionsRequest is undocumented.
type DescribeExpressionsRequest struct {
	Deployed        aws.BooleanValue `xml:"Deployed"`
	DomainName      aws.StringValue  `xml:"DomainName"`
	ExpressionNames []string         `xml:"ExpressionNames>member"`
}

func (v *DescribeExpressionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeExpressionsResponse is undocumented.
type DescribeExpressionsResponse struct {
	Expressions []ExpressionStatus `xml:"DescribeExpressionsResult>Expressions>member"`
}

func (v *DescribeExpressionsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Expressions"); err != nil {
		errors["Expressions"] = append(errors["Expressions"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeIndexFieldsRequest is undocumented.
type DescribeIndexFieldsRequest struct {
	Deployed   aws.BooleanValue `xml:"Deployed"`
	DomainName aws.StringValue  `xml:"DomainName"`
	FieldNames []string         `xml:"FieldNames>member"`
}

func (v *DescribeIndexFieldsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeIndexFieldsResponse is undocumented.
type DescribeIndexFieldsResponse struct {
	IndexFields []IndexFieldStatus `xml:"DescribeIndexFieldsResult>IndexFields>member"`
}

func (v *DescribeIndexFieldsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IndexFields"); err != nil {
		errors["IndexFields"] = append(errors["IndexFields"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeScalingParametersRequest is undocumented.
type DescribeScalingParametersRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
}

func (v *DescribeScalingParametersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeScalingParametersResponse is undocumented.
type DescribeScalingParametersResponse struct {
	ScalingParameters *ScalingParametersStatus `xml:"DescribeScalingParametersResult>ScalingParameters"`
}

func (v *DescribeScalingParametersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ScalingParameters"); err != nil {
		errors["ScalingParameters"] = append(errors["ScalingParameters"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeServiceAccessPoliciesRequest is undocumented.
type DescribeServiceAccessPoliciesRequest struct {
	Deployed   aws.BooleanValue `xml:"Deployed"`
	DomainName aws.StringValue  `xml:"DomainName"`
}

func (v *DescribeServiceAccessPoliciesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeServiceAccessPoliciesResponse is undocumented.
type DescribeServiceAccessPoliciesResponse struct {
	AccessPolicies *AccessPoliciesStatus `xml:"DescribeServiceAccessPoliciesResult>AccessPolicies"`
}

func (v *DescribeServiceAccessPoliciesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessPolicies"); err != nil {
		errors["AccessPolicies"] = append(errors["AccessPolicies"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSuggestersRequest is undocumented.
type DescribeSuggestersRequest struct {
	Deployed       aws.BooleanValue `xml:"Deployed"`
	DomainName     aws.StringValue  `xml:"DomainName"`
	SuggesterNames []string         `xml:"SuggesterNames>member"`
}

func (v *DescribeSuggestersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DescribeSuggestersResponse is undocumented.
type DescribeSuggestersResponse struct {
	Suggesters []SuggesterStatus `xml:"DescribeSuggestersResult>Suggesters>member"`
}

func (v *DescribeSuggestersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Suggesters"); err != nil {
		errors["Suggesters"] = append(errors["Suggesters"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DocumentSuggesterOptions is undocumented.
type DocumentSuggesterOptions struct {
	FuzzyMatching  aws.StringValue `xml:"FuzzyMatching"`
	SortExpression aws.StringValue `xml:"SortExpression"`
	SourceField    aws.StringValue `xml:"SourceField"`
}

func (v *DocumentSuggesterOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	FuzzyMatchingEnum := []string{
		SuggesterFuzzyMatchingHigh,
		SuggesterFuzzyMatchingLow,
		SuggesterFuzzyMatchingNone,
	}
	if err := model.ValidateEnum(v, "FuzzyMatching", FuzzyMatchingEnum); err != nil {
		errors["FuzzyMatching"] = append(errors["FuzzyMatching"], err)
	}

	if err := model.ValidateRequired(v, "SourceField"); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DomainStatus is undocumented.
type DomainStatus struct {
	ARN                    aws.StringValue  `xml:"ARN"`
	Created                aws.BooleanValue `xml:"Created"`
	Deleted                aws.BooleanValue `xml:"Deleted"`
	DocService             *ServiceEndpoint `xml:"DocService"`
	DomainID               aws.StringValue  `xml:"DomainId"`
	DomainName             aws.StringValue  `xml:"DomainName"`
	Limits                 *Limits          `xml:"Limits"`
	Processing             aws.BooleanValue `xml:"Processing"`
	RequiresIndexDocuments aws.BooleanValue `xml:"RequiresIndexDocuments"`
	SearchInstanceCount    aws.IntegerValue `xml:"SearchInstanceCount"`
	SearchInstanceType     aws.StringValue  `xml:"SearchInstanceType"`
	SearchPartitionCount   aws.IntegerValue `xml:"SearchPartitionCount"`
	SearchService          *ServiceEndpoint `xml:"SearchService"`
}

func (v *DomainStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainID"); err != nil {
		errors["DomainID"] = append(errors["DomainID"], err)
	}

	if err := model.ValidateMin(v, "DomainID", 1); err != nil {
		errors["DomainID"] = append(errors["DomainID"], err)
	}

	if err := model.ValidateMax(v, "DomainID", 64); err != nil {
		errors["DomainID"] = append(errors["DomainID"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "RequiresIndexDocuments"); err != nil {
		errors["RequiresIndexDocuments"] = append(errors["RequiresIndexDocuments"], err)
	}

	if err := model.ValidateMin(v, "SearchInstanceCount", 1); err != nil {
		errors["SearchInstanceCount"] = append(errors["SearchInstanceCount"], err)
	}

	if err := model.ValidateMin(v, "SearchPartitionCount", 1); err != nil {
		errors["SearchPartitionCount"] = append(errors["SearchPartitionCount"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DoubleArrayOptions is undocumented.
type DoubleArrayOptions struct {
	DefaultValue  aws.DoubleValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SourceFields  aws.StringValue  `xml:"SourceFields"`
}

func (v *DoubleArrayOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "SourceFields", `\s*[a-z][a-z0-9_]*\s*(,\s*[a-z][a-z0-9_]*\s*)*`); err != nil {
		errors["SourceFields"] = append(errors["SourceFields"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// DoubleOptions is undocumented.
type DoubleOptions struct {
	DefaultValue  aws.DoubleValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SortEnabled   aws.BooleanValue `xml:"SortEnabled"`
	SourceField   aws.StringValue  `xml:"SourceField"`
}

func (v *DoubleOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Expression is undocumented.
type Expression struct {
	ExpressionName  aws.StringValue `xml:"ExpressionName"`
	ExpressionValue aws.StringValue `xml:"ExpressionValue"`
}

func (v *Expression) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ExpressionName"); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidateMin(v, "ExpressionName", 1); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidateMax(v, "ExpressionName", 64); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidatePattern(v, "ExpressionName", `[a-z][a-z0-9_]*`); err != nil {
		errors["ExpressionName"] = append(errors["ExpressionName"], err)
	}

	if err := model.ValidateRequired(v, "ExpressionValue"); err != nil {
		errors["ExpressionValue"] = append(errors["ExpressionValue"], err)
	}

	if err := model.ValidateMin(v, "ExpressionValue", 1); err != nil {
		errors["ExpressionValue"] = append(errors["ExpressionValue"], err)
	}

	if err := model.ValidateMax(v, "ExpressionValue", 10240); err != nil {
		errors["ExpressionValue"] = append(errors["ExpressionValue"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ExpressionStatus is undocumented.
type ExpressionStatus struct {
	Options *Expression   `xml:"Options"`
	Status  *OptionStatus `xml:"Status"`
}

func (v *ExpressionStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IndexDocumentsRequest is undocumented.
type IndexDocumentsRequest struct {
	DomainName aws.StringValue `xml:"DomainName"`
}

func (v *IndexDocumentsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IndexDocumentsResponse is undocumented.
type IndexDocumentsResponse struct {
	FieldNames []string `xml:"IndexDocumentsResult>FieldNames>member"`
}

func (v *IndexDocumentsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IndexField is undocumented.
type IndexField struct {
	DateArrayOptions    *DateArrayOptions    `xml:"DateArrayOptions"`
	DateOptions         *DateOptions         `xml:"DateOptions"`
	DoubleArrayOptions  *DoubleArrayOptions  `xml:"DoubleArrayOptions"`
	DoubleOptions       *DoubleOptions       `xml:"DoubleOptions"`
	IndexFieldName      aws.StringValue      `xml:"IndexFieldName"`
	IndexFieldType      aws.StringValue      `xml:"IndexFieldType"`
	IntArrayOptions     *IntArrayOptions     `xml:"IntArrayOptions"`
	IntOptions          *IntOptions          `xml:"IntOptions"`
	LatLonOptions       *LatLonOptions       `xml:"LatLonOptions"`
	LiteralArrayOptions *LiteralArrayOptions `xml:"LiteralArrayOptions"`
	LiteralOptions      *LiteralOptions      `xml:"LiteralOptions"`
	TextArrayOptions    *TextArrayOptions    `xml:"TextArrayOptions"`
	TextOptions         *TextOptions         `xml:"TextOptions"`
}

func (v *IndexField) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "IndexFieldName"); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidateMin(v, "IndexFieldName", 1); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidateMax(v, "IndexFieldName", 64); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidatePattern(v, "IndexFieldName", `[a-z][a-z0-9_]*`); err != nil {
		errors["IndexFieldName"] = append(errors["IndexFieldName"], err)
	}

	if err := model.ValidateRequired(v, "IndexFieldType"); err != nil {
		errors["IndexFieldType"] = append(errors["IndexFieldType"], err)
	}

	IndexFieldTypeEnum := []string{
		IndexFieldTypeDate,
		IndexFieldTypeDateArray,
		IndexFieldTypeDouble,
		IndexFieldTypeDoubleArray,
		IndexFieldTypeInt,
		IndexFieldTypeIntArray,
		IndexFieldTypeLatlon,
		IndexFieldTypeLiteral,
		IndexFieldTypeLiteralArray,
		IndexFieldTypeText,
		IndexFieldTypeTextArray,
	}
	if err := model.ValidateEnum(v, "IndexFieldType", IndexFieldTypeEnum); err != nil {
		errors["IndexFieldType"] = append(errors["IndexFieldType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IndexFieldStatus is undocumented.
type IndexFieldStatus struct {
	Options *IndexField   `xml:"Options"`
	Status  *OptionStatus `xml:"Status"`
}

func (v *IndexFieldStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudSearch.
const (
	IndexFieldTypeDate         = "date"
	IndexFieldTypeDateArray    = "date-array"
	IndexFieldTypeDouble       = "double"
	IndexFieldTypeDoubleArray  = "double-array"
	IndexFieldTypeInt          = "int"
	IndexFieldTypeIntArray     = "int-array"
	IndexFieldTypeLatlon       = "latlon"
	IndexFieldTypeLiteral      = "literal"
	IndexFieldTypeLiteralArray = "literal-array"
	IndexFieldTypeText         = "text"
	IndexFieldTypeTextArray    = "text-array"
)

// IntArrayOptions is undocumented.
type IntArrayOptions struct {
	DefaultValue  aws.LongValue    `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SourceFields  aws.StringValue  `xml:"SourceFields"`
}

func (v *IntArrayOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "SourceFields", `\s*[a-z][a-z0-9_]*\s*(,\s*[a-z][a-z0-9_]*\s*)*`); err != nil {
		errors["SourceFields"] = append(errors["SourceFields"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// IntOptions is undocumented.
type IntOptions struct {
	DefaultValue  aws.LongValue    `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SortEnabled   aws.BooleanValue `xml:"SortEnabled"`
	SourceField   aws.StringValue  `xml:"SourceField"`
}

func (v *IntOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LatLonOptions is undocumented.
type LatLonOptions struct {
	DefaultValue  aws.StringValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SortEnabled   aws.BooleanValue `xml:"SortEnabled"`
	SourceField   aws.StringValue  `xml:"SourceField"`
}

func (v *LatLonOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Limits is undocumented.
type Limits struct {
	MaximumPartitionCount   aws.IntegerValue `xml:"MaximumPartitionCount"`
	MaximumReplicationCount aws.IntegerValue `xml:"MaximumReplicationCount"`
}

func (v *Limits) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "MaximumPartitionCount"); err != nil {
		errors["MaximumPartitionCount"] = append(errors["MaximumPartitionCount"], err)
	}

	if err := model.ValidateMin(v, "MaximumPartitionCount", 1); err != nil {
		errors["MaximumPartitionCount"] = append(errors["MaximumPartitionCount"], err)
	}

	if err := model.ValidateRequired(v, "MaximumReplicationCount"); err != nil {
		errors["MaximumReplicationCount"] = append(errors["MaximumReplicationCount"], err)
	}

	if err := model.ValidateMin(v, "MaximumReplicationCount", 1); err != nil {
		errors["MaximumReplicationCount"] = append(errors["MaximumReplicationCount"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ListDomainNamesResponse is undocumented.
type ListDomainNamesResponse struct {
	DomainNames map[string]string `xml:"ListDomainNamesResult>DomainNames"`
}

func (v *ListDomainNamesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LiteralArrayOptions is undocumented.
type LiteralArrayOptions struct {
	DefaultValue  aws.StringValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SourceFields  aws.StringValue  `xml:"SourceFields"`
}

func (v *LiteralArrayOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidatePattern(v, "SourceFields", `\s*[a-z][a-z0-9_]*\s*(,\s*[a-z][a-z0-9_]*\s*)*`); err != nil {
		errors["SourceFields"] = append(errors["SourceFields"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// LiteralOptions is undocumented.
type LiteralOptions struct {
	DefaultValue  aws.StringValue  `xml:"DefaultValue"`
	FacetEnabled  aws.BooleanValue `xml:"FacetEnabled"`
	ReturnEnabled aws.BooleanValue `xml:"ReturnEnabled"`
	SearchEnabled aws.BooleanValue `xml:"SearchEnabled"`
	SortEnabled   aws.BooleanValue `xml:"SortEnabled"`
	SourceField   aws.StringValue  `xml:"SourceField"`
}

func (v *LiteralOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudSearch.
const (
	OptionStateActive                 = "Active"
	OptionStateFailedToValidate       = "FailedToValidate"
	OptionStateProcessing             = "Processing"
	OptionStateRequiresIndexDocuments = "RequiresIndexDocuments"
)

// OptionStatus is undocumented.
type OptionStatus struct {
	CreationDate    time.Time        `xml:"CreationDate"`
	PendingDeletion aws.BooleanValue `xml:"PendingDeletion"`
	State           aws.StringValue  `xml:"State"`
	UpdateDate      time.Time        `xml:"UpdateDate"`
	UpdateVersion   aws.IntegerValue `xml:"UpdateVersion"`
}

func (v *OptionStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "CreationDate"); err != nil {
		errors["CreationDate"] = append(errors["CreationDate"], err)
	}

	if err := model.ValidateRequired(v, "State"); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	StateEnum := []string{
		OptionStateActive,
		OptionStateFailedToValidate,
		OptionStateProcessing,
		OptionStateRequiresIndexDocuments,
	}
	if err := model.ValidateEnum(v, "State", StateEnum); err != nil {
		errors["State"] = append(errors["State"], err)
	}

	if err := model.ValidateRequired(v, "UpdateDate"); err != nil {
		errors["UpdateDate"] = append(errors["UpdateDate"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudSearch.
const (
	PartitionInstanceTypeSearchM1Large   = "search.m1.large"
	PartitionInstanceTypeSearchM1Small   = "search.m1.small"
	PartitionInstanceTypeSearchM22xlarge = "search.m2.2xlarge"
	PartitionInstanceTypeSearchM2Xlarge  = "search.m2.xlarge"
)

// ScalingParameters is undocumented.
type ScalingParameters struct {
	DesiredInstanceType     aws.StringValue  `xml:"DesiredInstanceType"`
	DesiredPartitionCount   aws.IntegerValue `xml:"DesiredPartitionCount"`
	DesiredReplicationCount aws.IntegerValue `xml:"DesiredReplicationCount"`
}

func (v *ScalingParameters) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	DesiredInstanceTypeEnum := []string{
		PartitionInstanceTypeSearchM1Large,
		PartitionInstanceTypeSearchM1Small,
		PartitionInstanceTypeSearchM22xlarge,
		PartitionInstanceTypeSearchM2Xlarge,
	}
	if err := model.ValidateEnum(v, "DesiredInstanceType", DesiredInstanceTypeEnum); err != nil {
		errors["DesiredInstanceType"] = append(errors["DesiredInstanceType"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ScalingParametersStatus is undocumented.
type ScalingParametersStatus struct {
	Options *ScalingParameters `xml:"Options"`
	Status  *OptionStatus      `xml:"Status"`
}

func (v *ScalingParametersStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// ServiceEndpoint is undocumented.
type ServiceEndpoint struct {
	Endpoint aws.StringValue `xml:"Endpoint"`
}

func (v *ServiceEndpoint) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Suggester is undocumented.
type Suggester struct {
	DocumentSuggesterOptions *DocumentSuggesterOptions `xml:"DocumentSuggesterOptions"`
	SuggesterName            aws.StringValue           `xml:"SuggesterName"`
}

func (v *Suggester) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DocumentSuggesterOptions"); err != nil {
		errors["DocumentSuggesterOptions"] = append(errors["DocumentSuggesterOptions"], err)
	}

	if err := model.ValidateRequired(v, "SuggesterName"); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if err := model.ValidateMin(v, "SuggesterName", 1); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if err := model.ValidateMax(v, "SuggesterName", 64); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if err := model.ValidatePattern(v, "SuggesterName", `[a-z][a-z0-9_]*`); err != nil {
		errors["SuggesterName"] = append(errors["SuggesterName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// Possible values for CloudSearch.
const (
	SuggesterFuzzyMatchingHigh = "high"
	SuggesterFuzzyMatchingLow  = "low"
	SuggesterFuzzyMatchingNone = "none"
)

// SuggesterStatus is undocumented.
type SuggesterStatus struct {
	Options *Suggester    `xml:"Options"`
	Status  *OptionStatus `xml:"Status"`
}

func (v *SuggesterStatus) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "Options"); err != nil {
		errors["Options"] = append(errors["Options"], err)
	}

	if err := model.ValidateRequired(v, "Status"); err != nil {
		errors["Status"] = append(errors["Status"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TextArrayOptions is undocumented.
type TextArrayOptions struct {
	AnalysisScheme   aws.StringValue  `xml:"AnalysisScheme"`
	DefaultValue     aws.StringValue  `xml:"DefaultValue"`
	HighlightEnabled aws.BooleanValue `xml:"HighlightEnabled"`
	ReturnEnabled    aws.BooleanValue `xml:"ReturnEnabled"`
	SourceFields     aws.StringValue  `xml:"SourceFields"`
}

func (v *TextArrayOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "AnalysisScheme", `[\S]+`); err != nil {
		errors["AnalysisScheme"] = append(errors["AnalysisScheme"], err)
	}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidatePattern(v, "SourceFields", `\s*[a-z][a-z0-9_]*\s*(,\s*[a-z][a-z0-9_]*\s*)*`); err != nil {
		errors["SourceFields"] = append(errors["SourceFields"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// TextOptions is undocumented.
type TextOptions struct {
	AnalysisScheme   aws.StringValue  `xml:"AnalysisScheme"`
	DefaultValue     aws.StringValue  `xml:"DefaultValue"`
	HighlightEnabled aws.BooleanValue `xml:"HighlightEnabled"`
	ReturnEnabled    aws.BooleanValue `xml:"ReturnEnabled"`
	SortEnabled      aws.BooleanValue `xml:"SortEnabled"`
	SourceField      aws.StringValue  `xml:"SourceField"`
}

func (v *TextOptions) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidatePattern(v, "AnalysisScheme", `[\S]+`); err != nil {
		errors["AnalysisScheme"] = append(errors["AnalysisScheme"], err)
	}

	if err := model.ValidateMax(v, "DefaultValue", 1024); err != nil {
		errors["DefaultValue"] = append(errors["DefaultValue"], err)
	}

	if err := model.ValidateMin(v, "SourceField", 1); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidateMax(v, "SourceField", 64); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if err := model.ValidatePattern(v, "SourceField", `[a-z][a-z0-9_]*`); err != nil {
		errors["SourceField"] = append(errors["SourceField"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateAvailabilityOptionsRequest is undocumented.
type UpdateAvailabilityOptionsRequest struct {
	DomainName aws.StringValue  `xml:"DomainName"`
	MultiAZ    aws.BooleanValue `xml:"MultiAZ"`
}

func (v *UpdateAvailabilityOptionsRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "MultiAZ"); err != nil {
		errors["MultiAZ"] = append(errors["MultiAZ"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateAvailabilityOptionsResponse is undocumented.
type UpdateAvailabilityOptionsResponse struct {
	AvailabilityOptions *AvailabilityOptionsStatus `xml:"UpdateAvailabilityOptionsResult>AvailabilityOptions"`
}

func (v *UpdateAvailabilityOptionsResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateScalingParametersRequest is undocumented.
type UpdateScalingParametersRequest struct {
	DomainName        aws.StringValue    `xml:"DomainName"`
	ScalingParameters *ScalingParameters `xml:"ScalingParameters"`
}

func (v *UpdateScalingParametersRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateRequired(v, "ScalingParameters"); err != nil {
		errors["ScalingParameters"] = append(errors["ScalingParameters"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateScalingParametersResponse is undocumented.
type UpdateScalingParametersResponse struct {
	ScalingParameters *ScalingParametersStatus `xml:"UpdateScalingParametersResult>ScalingParameters"`
}

func (v *UpdateScalingParametersResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "ScalingParameters"); err != nil {
		errors["ScalingParameters"] = append(errors["ScalingParameters"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateServiceAccessPoliciesRequest is undocumented.
type UpdateServiceAccessPoliciesRequest struct {
	AccessPolicies aws.StringValue `xml:"AccessPolicies"`
	DomainName     aws.StringValue `xml:"DomainName"`
}

func (v *UpdateServiceAccessPoliciesRequest) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessPolicies"); err != nil {
		errors["AccessPolicies"] = append(errors["AccessPolicies"], err)
	}

	if err := model.ValidateRequired(v, "DomainName"); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMin(v, "DomainName", 3); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidateMax(v, "DomainName", 28); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if err := model.ValidatePattern(v, "DomainName", `[a-z][a-z0-9\-]+`); err != nil {
		errors["DomainName"] = append(errors["DomainName"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// UpdateServiceAccessPoliciesResponse is undocumented.
type UpdateServiceAccessPoliciesResponse struct {
	AccessPolicies *AccessPoliciesStatus `xml:"UpdateServiceAccessPoliciesResult>AccessPolicies"`
}

func (v *UpdateServiceAccessPoliciesResponse) Validate() *model.ValidationErrors {
	errors := model.ValidationErrors{}

	if err := model.ValidateRequired(v, "AccessPolicies"); err != nil {
		errors["AccessPolicies"] = append(errors["AccessPolicies"], err)
	}

	if len(errors) > 0 {
		return &errors
	} else {
		return nil
	}
}

// BuildSuggestersResult is a wrapper for BuildSuggestersResponse.
type BuildSuggestersResult struct {
	FieldNames []string `xml:"BuildSuggestersResult>FieldNames>member"`
}

// CreateDomainResult is a wrapper for CreateDomainResponse.
type CreateDomainResult struct {
	DomainStatus *DomainStatus `xml:"CreateDomainResult>DomainStatus"`
}

// DefineAnalysisSchemeResult is a wrapper for DefineAnalysisSchemeResponse.
type DefineAnalysisSchemeResult struct {
	AnalysisScheme *AnalysisSchemeStatus `xml:"DefineAnalysisSchemeResult>AnalysisScheme"`
}

// DefineExpressionResult is a wrapper for DefineExpressionResponse.
type DefineExpressionResult struct {
	Expression *ExpressionStatus `xml:"DefineExpressionResult>Expression"`
}

// DefineIndexFieldResult is a wrapper for DefineIndexFieldResponse.
type DefineIndexFieldResult struct {
	IndexField *IndexFieldStatus `xml:"DefineIndexFieldResult>IndexField"`
}

// DefineSuggesterResult is a wrapper for DefineSuggesterResponse.
type DefineSuggesterResult struct {
	Suggester *SuggesterStatus `xml:"DefineSuggesterResult>Suggester"`
}

// DeleteAnalysisSchemeResult is a wrapper for DeleteAnalysisSchemeResponse.
type DeleteAnalysisSchemeResult struct {
	AnalysisScheme *AnalysisSchemeStatus `xml:"DeleteAnalysisSchemeResult>AnalysisScheme"`
}

// DeleteDomainResult is a wrapper for DeleteDomainResponse.
type DeleteDomainResult struct {
	DomainStatus *DomainStatus `xml:"DeleteDomainResult>DomainStatus"`
}

// DeleteExpressionResult is a wrapper for DeleteExpressionResponse.
type DeleteExpressionResult struct {
	Expression *ExpressionStatus `xml:"DeleteExpressionResult>Expression"`
}

// DeleteIndexFieldResult is a wrapper for DeleteIndexFieldResponse.
type DeleteIndexFieldResult struct {
	IndexField *IndexFieldStatus `xml:"DeleteIndexFieldResult>IndexField"`
}

// DeleteSuggesterResult is a wrapper for DeleteSuggesterResponse.
type DeleteSuggesterResult struct {
	Suggester *SuggesterStatus `xml:"DeleteSuggesterResult>Suggester"`
}

// DescribeAnalysisSchemesResult is a wrapper for DescribeAnalysisSchemesResponse.
type DescribeAnalysisSchemesResult struct {
	AnalysisSchemes []AnalysisSchemeStatus `xml:"DescribeAnalysisSchemesResult>AnalysisSchemes>member"`
}

// DescribeAvailabilityOptionsResult is a wrapper for DescribeAvailabilityOptionsResponse.
type DescribeAvailabilityOptionsResult struct {
	AvailabilityOptions *AvailabilityOptionsStatus `xml:"DescribeAvailabilityOptionsResult>AvailabilityOptions"`
}

// DescribeDomainsResult is a wrapper for DescribeDomainsResponse.
type DescribeDomainsResult struct {
	DomainStatusList []DomainStatus `xml:"DescribeDomainsResult>DomainStatusList>member"`
}

// DescribeExpressionsResult is a wrapper for DescribeExpressionsResponse.
type DescribeExpressionsResult struct {
	Expressions []ExpressionStatus `xml:"DescribeExpressionsResult>Expressions>member"`
}

// DescribeIndexFieldsResult is a wrapper for DescribeIndexFieldsResponse.
type DescribeIndexFieldsResult struct {
	IndexFields []IndexFieldStatus `xml:"DescribeIndexFieldsResult>IndexFields>member"`
}

// DescribeScalingParametersResult is a wrapper for DescribeScalingParametersResponse.
type DescribeScalingParametersResult struct {
	ScalingParameters *ScalingParametersStatus `xml:"DescribeScalingParametersResult>ScalingParameters"`
}

// DescribeServiceAccessPoliciesResult is a wrapper for DescribeServiceAccessPoliciesResponse.
type DescribeServiceAccessPoliciesResult struct {
	AccessPolicies *AccessPoliciesStatus `xml:"DescribeServiceAccessPoliciesResult>AccessPolicies"`
}

// DescribeSuggestersResult is a wrapper for DescribeSuggestersResponse.
type DescribeSuggestersResult struct {
	Suggesters []SuggesterStatus `xml:"DescribeSuggestersResult>Suggesters>member"`
}

// IndexDocumentsResult is a wrapper for IndexDocumentsResponse.
type IndexDocumentsResult struct {
	FieldNames []string `xml:"IndexDocumentsResult>FieldNames>member"`
}

// ListDomainNamesResult is a wrapper for ListDomainNamesResponse.
type ListDomainNamesResult struct {
	DomainNames map[string]string `xml:"ListDomainNamesResult>DomainNames"`
}

// UpdateAvailabilityOptionsResult is a wrapper for UpdateAvailabilityOptionsResponse.
type UpdateAvailabilityOptionsResult struct {
	AvailabilityOptions *AvailabilityOptionsStatus `xml:"UpdateAvailabilityOptionsResult>AvailabilityOptions"`
}

// UpdateScalingParametersResult is a wrapper for UpdateScalingParametersResponse.
type UpdateScalingParametersResult struct {
	ScalingParameters *ScalingParametersStatus `xml:"UpdateScalingParametersResult>ScalingParameters"`
}

// UpdateServiceAccessPoliciesResult is a wrapper for UpdateServiceAccessPoliciesResponse.
type UpdateServiceAccessPoliciesResult struct {
	AccessPolicies *AccessPoliciesStatus `xml:"UpdateServiceAccessPoliciesResult>AccessPolicies"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
